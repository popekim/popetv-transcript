어떤.. 어떤 비디오인지 모르겠는데, 전에 어떤 비디오를 만들다가 제가 그런 얘길 했어요. 그.. 언어가 같은 거가 언어 디자인을 잘했냐 말았냐. 그러니까 뭐 언어라고 말했지만 영어가 아니라 프로그래밍 언어. 디자인을 잘했냐, 디자인이 어떠냐, 설계를 잘했냐 말았냐 하는 걸 판단을 할 때는 default behavior가 굉장히 중요하다고 말씀을 드렸어요.

default behavior라고 하면은, 아 뭐라고 그래야 돼. 기본 동작? 기본 작동 방법? 예를 들어서 어떤 코드를 짰을 때 내부적으로 어떤 게 기본이고, 그거를 default behavior로 바꾸려면 새로운 함수를 호출해야 하고 이런 것들이 있잖아요. 그거를 말하는 건데, 일단 제가 생각하는 훌륭한 언어 디자인의 기본적인 거는 프로그래머가 프로그램을 짰을 때 그 코드가 실제 어떻게 컴퓨터에서 돌 거냐라는 건지 대충 판단이 가능해야 한다고 생각을 하거든요.

그래서 저 같이 이제 좀 오래 프로그래밍 한 사람들, 예전부터 하드웨어 쪽에서 가깝게 프로그래밍 한 사람들은 C를 좋아하는 이유가 그거예요. 사실은 C나 C++를 굉장히 좋아하는 이유가, 코드를 딱 봤을 때 이 코드가 어떻게 어셈블리(assembly)로 갈지를 알고. 어셈블리라는 게 기계어 인스트럭션(instruction)이잖아요. 그래서 각 기계마다 지원하는 가장 낮은 수준의 명령어거든요.

뭐 그거를 보면서 대충 판단이 되는 거죠. 아 이런 하드웨어에서는 이게 어느 정도로 빠르게 돌 거고, 어떤 문제가 있을 거고, 기타 등등. 그다음에 나온 언어들을 보면 여러 가지 언어가 있지만, 여전히 그런 게 깔끔하게 보이게 디자인한 언어가 있고, 그런 걸 완벽히 뭉클어트려서 속에 도대체 어떤 식으로 작동할지를 모르게 하는 그런 언어들도 있어요.

제가 스크립트(script) 언어를 쓰긴 쓰는데, 스크립트 언어가 굉장히 마음에 안 드는 것 중의 하나는 단지 스크립트 언어라서 그런 건 아니죠. 사실은 그 형(type)이 정해져 있지 않은 것이 있잖아요. 타입이 언제나 바꿀 수 있는 그런… 그걸 별로 안 좋아해요.

그래서 C# 같은 경우에는 var나 C++에는 auto 같은 게 나오면서 그런 건 이제 타입을 추론은 가능하지만 바꿀 수 없게 하는, 그런 걸 strong 타입들이라고 하거든요. 타입을 언제나 정해야 하는. 그게 굉장히 좋아하는 이유도 그중에 하나죠. 딱 봤을 때 어떤 식으로 메모리에서 이게 어떻게 들어가고 코딩이 어떻게 돌 건지를 판단이 가능하고. 타입이 바뀔 때 과연 얘가 뒤에서 뭘 할지 저는 감이 안 오니까. 그러면 그 외에 옵티마이제이션(optimization)이 되는 이유도 있고요.

원래 말하려고 했던 본론으로 돌아가서, 그때 그 얘기를 했을 때 제가 swift 얘기를 잠깐 했고 막 이런 얘기를 했는데, 그때 어떤 사람이 답글로 swift 좀 막 까달라고 그랬거든요. (웃음) 그래서 오늘 차라리 얘기를 하는 김에 그거를 하려고 해요.

암… 제가 볼 때 그래서 swift, C#, 그리고 다른 언어까지 얘기를 할 것 같은데.

일단은 기본 behavior, default behavior에 대해서 좀 더 생각을 해볼게요. 뭐든 간에 C나 C++를 보면은 뭐 상당히 버그가 많았다고 하기는 어려운데, 알아야 되는 규칙이 굉장히 많았어요.

예를 들어서 뭐… 한국말로 승격이라고 하나? 그.. 만약에 숫자를 unsigned char 숫자를 넣어가지고 계산을 해가지고 이걸 int에 넣으면은 이게 integer로 자동으로 되는지, 뭐 앞에 무슨 브래킷 넣어가지고 그걸 int라고 해야지만 바뀌는지, int에서 char 갈 땐 어떤지 이런 여러 가지 룰이 있잖아요.

어찌 보면 비트 수 높은 걸로 올라간다 뭐 이런 건 좋은 예이긴 한데, 뭐 이해도 되고 가끔 애매한 경우도 있고요. 사실은 그런 데서 버그가 생기는 것도 가끔은 있어요. 이제 뭐 unsigned int나 int 간에 어떻게 왔다 갔다 하는지 이런 것부터 시작해서, C나 C++에서 상당히 잠재적인 그런 규칙이 많아요.

그러니까 딱 봤을 때 확실하게 이렇게 작동한다는 게 아니라, 이게 내부적으로는 스펙엔 있어요. 근데 그냥 코드만 보고 나서, 아니면 상식적으로 생각해서 그게 그렇게 작동을 한다고 판단하기가 어려운 부분이 있죠. 그래서 C나 C++가 굉장히 어려운 언어 중의 하나이기는 해요. 그런 의미에서.

그거를 굉장히 많이 고쳤던 언어 중에 하나가, 이제 뭐 중간에 다른 언어가 있었지만 델파이도 좀 그런 비슷한 이유 중 하나였다고 생각을 하는데, 그 델파이 개발자가 가서 만든 게 C#이잖아요.

C#을 보면은, C# 초기 한 1이나 2.0? 한 3.0까지 때만 해도 굉장히 깔끔했어요. 코드를 보면은 딱 감이 와. 아 이게 C하고 비슷할 수도 있지만, 대충 어떻게 어떻게 돌겠구나 감이 오면서도, 결과적으로 C에서 조금 위험하다고 여겨졌던 포인터라든가 이런 것들을 많이 뺐고. 물론 지원은 가능하지만 기본적으로 빠져 있죠.

뭐 그 이후에 포인터가 없어진 대신, 자바처럼 모든 게 reference 타입으로 전달이 되는데, reference 타입이 아니라 value 타입으로 되는 거는 이제 기본형들하고 struct. 그래서 뭐 integer라든가, short 이런 거 있잖아요. 그런 거 다 기본형들은 다 기본적으로 값으로 copy를 하죠. 레퍼런스 copy라는 거는 레퍼런스가 결과적으로 포인터랑 같은 의미예요. 근데 포인터에 직접 접근하지 못하는 것뿐이죠.

근데 이제 그러면 레퍼런스하고 밸류하고 차이가 생기다 보니까 한 가지 default behavior를 처음으로 도입을 해야만 했어요. 그게 뭐였냐면은 struct. 그러니까 물론 C#… C에서 생각할 때 class하고 struct하고 별 차이가 없잖아요. 근데 C#에서는 struct는 언제나 value 타입이에요. 그래서 struct로 들어가는 거는 struct를 그냥 함수에 전달할 때는 값을 전부 다 복사를 해요. C에서 얘기를 하면 그냥 Object를 집어넣는 거하고 똑같죠.

그리고 C에서는 class라는 게 있잖아요. 그걸 이제 C#에서는 개념이 똑같아요. class는. 근데 이제 class에 있는 그 오브젝트를 그냥 함수로 전달할 때는 이거는 암시적이라고 해야겠죠. implicit하게 알아서 포인터로 엮어, 레퍼런스하게 전달을 하죠. 그래서 거기서 한 가지 룰이 생겨난 거예요.

아… 모든 오브젝트, 클래스로 만든 오브젝트는 레퍼런스 타입으로 들어간다. 그리고 모든 struct는 밸류 타입으로 들어간다. 사실 C#을 전혀 몰랐던 사람들이라면, C++만 한 사람들이라면 이게 코드만 보고는 알 수는 없는 규칙이죠. 사실은. 근데 결과적으론 나중엔 알게 되고. 그래서 요 한 가지 규칙이 생겼어요. 그렇게 외우기 힘든 규칙은 아니죠.

그러고 뭐 이 struct하고 class 사이를 왔다 갔다 할 때가 있잖아요. 예를 들어서 integer도 class형의 integer가 있어요, C#에서는. 마찬가지 얘기로 container에 들어갈 때도 오브젝트로만 바꿔야 되는 경우도 있고, 뭐 요즘은 안 쓰지만.

그래서 그런 게 생기면서 이제 거기서 나오는 퍼포먼스 이슈의 문제도 생기기 시작했어요. 근데 그거는 말 그대로 규칙이 명확하니까 이해하기가 쉬웠죠. 다 좋았는데…

쩝. 이제 제 생각에는 C#을 원래 만드시는 분이 아마 그 팀을 더 이상 리드하지 않는 게 아닌가 싶은 생각도 들고. 버전이 조금 더 높아가면서 새로운 것들을 막 추가하기 시작을 했거든요.

그 가장… 뭐 링크도 그때 추가된 거고, 에이싱크(async)라는 것도 그때 추가된 거고, 패러럴 태스크(Parallel Task) 이런 것도 추가된 거고. 개인적으로 패러럴 팀은 굉장히 뛰어난 일을 했다고 생각해요. 그거는 제가 굉장히 좋아하고, 굉장히 깔끔하게 나왔다고 생각하고.

뭐 잡 시스템 만져보신 분들이라면 패러럴 태스크 시스템 써 보면, 아 이거 정말 제대로 만들었고. 뭐 실수할 순 있죠. 근데 굉장히 잘 만들었다는 생각이 딱 들어요 보면서.

쩝. 문제는, 제가 최근에 발견한 것 중의 하나예요. 웹 프로그래밍 하다 보니까 에이싱크나 뭐 이런 걸 쓸 일이 있어서. 아직도 개념이 100% 확실하진 않지만, 에이싱크가 굉장히 문제가 많더라고요.

에이싱크 작업을 하면서 보통 뭐 그런 거 있잖아요. 태스크 해서 이제 웨이트할 때 어웨이트 하는 거. C#에서 아시는 분들 아시겠지만, 그 어웨이트 할 때. 특히 웹, 웹 기반에서가 문제인 것 같아요. 이제 그 어떤 잡을 해 놓고 어웨이트할 때, 이게 태스크가 쫙 나갔다가 끝나고 돌아올 때 있잖아요. 그러면 이게 기본 동작이 되게 웃겨요.

기본 동작이 이 잡을 시작을 했던 컨텍스트, 뭐 이런 게 있잖아요. 그러면 이 에이싱크 잡을 실행을 하면서, 이게 끝났을 때 원래 컨텍스트로 돌아오려고 하는 게 기본 동작이에요. 그러니까 한마디로 컨텍스트(Context)라고 생각하면 그냥 스레드(Thread) 번호가 내가 1번에서 이거를 실행했다면, 끝나고 나서 1번으로 돌아오려고 하는 그런 작동을. 그거를 기본 작동으로 해요.

근데 그럴 필요가 없는 경우가 거의 대부분이거든요. 저는 왜 그럴 필요가 있는지도 잘 몰랐는데, 열심히 뒤지다 보니까 UI 쪽에선 그래야만 한대요. 저도 뭐 더 깊이 파진 않았어요. 제가 UI를 할 일이 없어서.

그래서 C#에서 UI에서 그런 에이싱크를 막 할 때 필요하잖아요, 아무래도. UI를 막으면 안 되니까. 그러면 그때 원래 컨텍스트로 돌아와야만 원래 UI를 업데이트하고 이런 게 있나 봐요. 뭐 WPF의 얘기일 수도 있고, 실버라이트 얘기일 수도 있는데 제가 정확히 어디의 UI인지는 모르겠어요. 그거를 위해 기본 동작을 원래 컨텍스트로 돌아오게 만들었다는데…

문제는 이거를 ASP.NET 웹 환경에서 돌리다 보면 데드락이 일어날 때가 있어요. 예를 들어서 얘는 에이싱크 시작되고 떠났는데, 돌아오는 순간에 이제 원래 컨텍스트로 돌아오려고 하죠. 근데 다른 리퀘스트 콜이 있어 가지고 웹 서버 쪽에 그 원래 있던 컨텍스트를 딴 놈이 가져가. 딴 놈이 가져가서 뭔가 또 실행을 하다가 얘도 누군가를 기다리면서 데드락이 걸리는 거예요.

그래서 저는 데드락을 테스트할 때는 안 나오다가, 프로덕션 서버에 올렸을 때 그걸 발견을 했거든요. 제가 짠 코드가 아니었고, 원래 있던 코드였는데 프로덕션에 올렸을 때 이렇게 막 스레드 수 많아지고, 뭐 거의 태스크 풀이 있잖아요 ASP.NET 쪽에는. 그게 많아지면서 그게 막 데드락이 걸리기 시작하는 거예요.

그래서 뒤지고 뒤진 끝에 찾았어요 문제가 뭔지. 해결하는 방법은 솔직히 간단해요. 그 다음에 함수를 호출할 때, 그 에이싱크 잡을 호출할 때 그 뒤에다 닷 하나 찍고 ConfigureAwait 어쩌구라는 함수가 있어요. 그거를 false로 해 주면, 원래 컨텍스트로 돌아가려고 하지 않는다 그러더라고요. 그래서 그건 그냥 리턴할 때 아무 컨텍스트나 또 잡아 갖고 계속 실행한다고.

그래서 그게 해결 방법은 간단한데, 문제는 코딩을 짜는 사람 입장에서 왜 그거를 언제나 넣어야 되는지가 말이 안 된다는 거죠. 기본적으로 코딩을 짜는 사람에선 기본 동작이 아무거나 잡아 갖고 데드락이 없는 상황으로 가게 하고, 정말 자기가 뭔가 위험한 일을 할 때, 아니면 특히 UI 쪽에 특별한 목적으로 그걸 해야 될 때. 그때는 ConfigureAwait를 자기가 직접 짜야죠.

그러니까 ConfigureAwait가 없으면 데드락 없이 그냥 아무 컨텍스트 잡아서 갈 수 있는 그런 개념으로 가고, 정말 원래 컨텍스트로 돌아가야만 하는 특별한 경우라면 그때 새로운 함수를 뒤에다 붙여야만 된다고 생각을 하거든요. 그래서 디자인을 잘못한 거예요. 그리고 그것 때문에 실제 저희 프로덕션에서 오류도 있었고.

제 생각에는 저희가 아직 모르는 그런 오류가 많을 수도 있어요. 데드락 계속 걸리기 시작하면은 보통 웹에서는 “어 페이지 안 뜨네? 그럼 F5 한 번 더 누르자.” 그러면 새로운 리퀘스트 가서, 운 좋게 데드락 안 걸리면 그 결과 받아오고. 그러다 보면 웹 서버에서 계속 데드락 걸리는 태스크가 있을 거고, 어느 순간 웹 서버가 너무 느려진다. “그래 다시 부팅하자.” 이 개념으로 가는 경우도 있을 것 같아요.

한마디로 모르는 거죠. 그래서 굉장히 위험한 default behavior라고 생각을 하고, 그게 기본으로 들어가 있다는 게 저는 불만스러워요.

그거.. 그건 하나고. 두 번째 또 (웃음).

C#에서 요즘 마음에 안 들던 거는 그 iterator 같은 거 있잖아요, C#에. 예를 들어서 뭐 링크(Linq) 해서, 셀렉트(Select) 해서 잡아 갖고 새로운 스트럭처 만드는 거, 컨테이너 만드는 거. 이게 C#에서 이제 레이지(lazy) 로딩이라는 걸 시작을 한 건데.

한마디로, 링크 안에 뭐 세 가지 셀렉트 잡을 넣어 가지고 배열 세 개를 만들려고 한다고 생각해 봐요. 그러면 실제 이 데이터가 쓰이기 전까지 이 실행문이 실행이 안 되는 거예요.

뭐 레이지 로딩 개념은 언제나 있어 왔지만, 그게 과연 default여야 할까라는 생각이 들기 시작을 하는 거죠. 기본적으로 이게 사실은 코딩을 짰을 때 레이지 로딩이 아니라고 가정을 하고 짜는 게 전 올바르다고 생각을 하거든요. 근데 이거를 레이지 로딩을 default로 했기 때문에 사람들은 코딩을 짜고, 레이지 로딩으로 나중에 되는 거죠.

물론 SQL이나 이런 걸 생각할 때는 당연히 그게 나을 수도 있는데… 쓰읍. 과연 코딩을 짜는 사람이 이게 짜면서 “아 이건 레이지 로딩이구나”라고 생각을 할까? 기본적으로 다들 이거는 곧바로 로딩(eager loading)이라고 생각하고 짜잖아요. 이그얼… 뭐라 그래. 열정적으로 곧바로 로딩한다? 그때그때 실행하는 거. 그게 저는 일반적인 프로그래머가 생각하는 거라고 생각을 해요.

근데 레이지 로딩을 그걸 기본으로 해놓다 보니까, 하아… 또 거기서 몇 가지 버그가 이리저리 발생을 하더라고요. 사람들은 당연히 이게 eager 로딩이라고 생각하고 썼는데, 나중에 보니까 레이지 로딩인 거야.

그거를 고치는 법은 있긴 한데, 일단 뭐 그거는 레이지 로딩이 필요하면 그냥 그걸 넣으면서 거기다 lazy라고 써야 되는 게 아닐까? 아까 디셀렉트(deselect) lazy 뭐 이런 식으로. 그럼 이거는 lazy라는 거 딱 보이게. 그러면은 그게 훨씬 좀 깔끔한 코드라고 생각하거든요.

그 기본 behavior가 전 잘못됐다고 생각을 해요. 근데 뭐 아까 말한 ConfigureAwait처럼 아주 잘못된 건 아니고, 그냥 제 선호 사항에서 잘못됐다고 생각을 하고.

여기서 오는 또 하나 버그를 발견한 게 되게 웃겼던 게 뭐냐면, 링크를 딱 해 갖고 셀렉트문 안에서 언제나 다른 함수를 호출하는 걸 셀렉트했다고 생각을 해봐요. 그러면 이 링크를 잡아다가 그 컨테이너를 foreach로 돌리면서 넥스트 멤버를 잡다 보면, 잡을 때마다 그 함수를 호출해 주는 거예요.

함수를 호출할 때 그 함수가 예를 들어서 숫자를 1씩 증가시켜서 반환하는 거다. 그런 함수라면 되게 재밌는 게 발생을 하더라고요. 링크 스테이트먼트(statement)에 셀렉트를 두 번을 해 갖고 넣는 거예요. 그러면 숫자가 0하고 1이 나오겠죠, 결과적으로는.

그리고 밑에서 그 링크 스테이트를 돌면서 foreach, 그 변수 잡아 주고 그 안에… 그러니까 각 링크 안에 셀렉트가 두 개 들어갔으니까 두 개만큼 돌리면서 그 값을 잡아 갖고 프린팅을 한다. 그러면 화면에 0하고 1이 출력이 돼요.

그다음에 또 재밌는 게, 이거예요. 그 위에 링크 오브젝트, 그거를 딱 잡고 프린트를 한 번 더 하면서 닷 퍼스트(First)를 하면은 이게 그 다음 번호가 나와요. 0, 1, 2 이렇게.

그게 왜 그러냐면 레이지 로딩이기 때문에 그렇죠. 그 안에 들어 있는 셀렉트문은 있고, 그 셀렉트문은 그냥 다른 함수를 호출하는 거기 때문에, 그거를 한 번 한 번 호출할 때마다 그렇게 되는 거예요.

근데 처음 링크를 캡쳐했을 때는 우리가 두 개를 잡는다고 이미 해놨으니까 두 개인 거까진 알고, 그거를 foreach로 돌릴 수는 있어요. 근데 그게 나온 경우에 이미 이 두 개를 호출했기 때문에… 아, 뭐. 그 함수가 숫자를 하나씩 증가해서 반환하는 거잖아요. 그 함수는 이미 1까지 반환을 한 거예요.

그러면 여기 호출하고, 다음 포인트가 여기로 와 있는 건데, 아직 아무것도 없는 거. 이 상황에서 “아 그래, 이거 두 개 돌려 가면서 0하고 1을 보여줬으니까. 그럼 이번에는 처음 거를 다시 보고 싶다”라는 개념으로 하면은 어, 함수에 First가 있네? 그러면 링크 닷 퍼스트 하면은, 이게 배열이라고 생각하고 처음 거라고 생각하잖아요.

근데 레이지 로딩이기 때문에 그 퍼스트가 사실은 넥스트예요. 아니면 현재 포인터 가리키고 있는 데가 퍼스트거나. 그래서 퍼스트를 하면은 이게 호출이 되면서, 아직 그 안에 들어가 있는 값이 없으니까 새로 함수를 호출해서 2가 나오더라고요.

그래서 저는 그 퍼스트라는 이름 자체도 굉장히 불만이 많아요, 사실은. 뭐 다른 iterator 쓰다 보면은 자바가 그랬던 것 같은데 넥스트(Next) 쓰잖아요, 언제나. 저는… 자바가 넥스트인가? C가 넥스트인가? 퍼스트가 아니라 언제나 넥스트라고 하거든요. getNext라든가 moveNext라든가. 그러면 개념이 딱 오잖아요. 아 넥스트니까 이거는 그 다음 거겠구나라는 거. 코드에서 확실히 볼 수가 있는데.

이거는 퍼스트다 보니까, 진짜 꼼꼼하게 생각하지 않으면 이게 퍼스트인지, 이게 다음 거인지 헷갈릴 수가 있더라고요. 실제 제가 그 버그를 코드에서 봤고, 다른 사람이 짠 거를.

뭐 이거를 해결하는 방법은 처음에 링크 스테이트먼트 넣고, 그 두 개의 셀렉트로 한 다음에 닷 투 어레이(ToArray) 하면은 해결은 돼요. 그러면 그때부터 배열이니까 첫 번째 거, 두 번째 거 보여 주고, 다시 첫 번째 거 보여 주면 배열에서 첫 번째 거거든요.

근데 또 하나의 문제는… 이게 옛날에 STL 같은 경우에서 가끔 나왔던 문제인 것 같긴 한데. STL 개념 자체가, STL 컨테이너 개념 자체가 그거였잖아요. 인터페이스는 똑같고 행동도 똑같아야 된다고 했나, 달라야 됐나? 그거까진 제가 모르겠네요. 제가 그쪽으로 하두 짧아서.

근데 제 개념은 그거였던 것 같았거든요. 그러니까 예를 들어서 어떤 형인지, 배열인지 리스트인지 상관없이 그냥 퍼스트부터 끝까지 이터레이터 하면서 볼 수 있다. 퍼스트 하면 언제나 퍼스트로 갈 수 있는 그 개념이라고 생각했거든요.

이거는 순식간에 캡쳐하는 게, 링크 enumerable 타입인지 아니면 배열 타입인지에 따라서 퍼스트의 behavior가 바뀌는 거라고 생각을 해요. 굉장히 혼란스럽고. 또 C# 같은 경우에서는 변수를 auto, var라고 해서 그냥 어떤 함수를 호출해서 이 함수가 enumerator를 반환을 했을 때 var로 해놓으면, 이 형이 뭔지는 코드상에선 안 보이지만 얘가 추론을 해서 “아 그래, 이게 enumerator구나” 하고 쓰잖아요.

그렇게 되기 시작하면은 이게 만약에 그게 함수가 바뀌어서 enumerator를 반환을 안 하고 배열을 반환하기 시작하면은, 코드 자체의 행동도 바뀌게 된다는 얘기거든요. 그래서 차라리 둘 간의 인터페이스를 공유하지 않는 게 훨씬 버그를 막을 수 있는 길인데, 왜 그랬을까? 저도 그것도 굉장히 마음에 안 드는 부분이기도 했어요.

레이지 로딩이 처음부터 아니고 eager 로딩이었으면 이런 문제가 조금 적었을 거고. 레이지 로딩이 필요하면 따로 레이지 로딩이라고 하면 되는 거고. 아니면 아까 말했던 그 링크 enumerable 인터페이스에 First라는 이름 자체가 잘못된 게 아니냐. 차라리 Next라든가 Current라든가, 이런 이름이 훨씬 나은 거죠.

그래서 그것도 좀 그렇고. 그 외에도 에이싱크 해보려고 그러면 앞에 async 붙이고 await 붙이고, 코드가 굉장히 더러워졌거든요. 그래서 아, 이게 어느 순간부터 갑자기 C#이 망가지는 게 보이는 거예요. 아, 이게 원래 설계자가 없는 게 아닌가 생각이 들 정도고.

C# 얘기는 거기까지. 그다음에 할 얘기는 Swift예요.

Swift를 처음 나왔을 때 스펙 다 읽어 보면서 검토를 해봤어요. 일단 Objective-C보다 훨씬 좋아요. 뭐 그것보다 안 좋을 수가 없죠. Objective-C 자체가 워낙에 개판이었던 랭귀지였으니까.

언어 자체로는 일단 뭐 제가 Swift 같은 거 좋아하는, 아니 뭐 Objective-C나 Swift를 다른 것보다 좋아했던 이유들 중에 하나는 그 레퍼런스 카운팅(Reference Counting) 때문이고요. 전에 왜 레프 카운팅이 왜 가비지 컬렉팅(Garbage Collecting)보다 낫냐라는 얘기를 몇 번이나 해왔고. 그거는 좋고.

굉장히 여러 가지 신경을 많이 썼어요. 뭐 예를 들어서 성능 향상을 위해서는 아무래도 변수보다는 상수가 중요하거든요. const 변수라고 하죠. 뭐 그런 것도 신경을 많이 썼고, extension부터 시작해서… 성능상으로 자동적으로 옵티마이제이션(optimization)하기가 훨씬 좋은 언어예요. 그러면서 사용자가 사용하기에는 그렇게 힘들지 않은 언어고.

한 가지 단점은 얘네가 정말 말도 안 되는 default behavior를 새로 만든 게 문제였어요. 개념이 이해가 안 되는 거야. 점점 얘네 왜 이 짓을 했을까. 제가 한 가지 딱 마음에 안 드는 게 있어요, 솔직히.

그게 뭐냐면, 어레이(Array)하고 딕셔너리(Dictionary)라고 그러나? 얘네 맵(Map)이라고 그러나, 해시테이블(HashTable)이라고 그러나. 뭐 어찌 되었든 C# 용어로 어레이하고 딕셔너리라고 할게요.

어레이가 있으면 C#에선 어레이가 오브젝트예요. 그래서 어레이를 다른 함수에, 그러니까 어레이를 딕셔너리를 똑같이 오브젝트이기 때문에 이거를 다른 함수에 인자로 전달을 해주면 이게 레퍼런스 단위로 들어가요. 복사가 안 일어나는 거죠. 그래서 그냥 그거를 가져다가 쓰면 되는 거고, 복사하는 데 시간 낭비하는 것도 없고.

그러고 그 값을 바꾸면 원본이 바뀌는 단점은 있어요. 근데 그거를 이미 당연하다고 써 온 사람들이 많고, 저는 그게 일반적인 지금 프로그래밍 패러다임이라고 보거든요. 그렇지 않으면 원래 어레이에 어떤 값을 추가하려고 할 때 이거를 함수로 전달 안 하면 어떻게 하겠다는 거야.

그쵸. 원래 어레이, 그러니까 원래 어레이. 어레이가 아니라 이거는 C# 용어로는 리스트라고 해야 될 거고, C++ 용어로는 벡터(Vector)라고 해야겠죠. STL 벡터. 거기에 원래 새로운 값들을 추가해서 그냥 그 원본에 계속 추가하고 싶은 경우가 있잖아요, 매개변수로. 그러면 그냥 레퍼런스로 가기 때문에 편하잖아요.

한마디로 뭐 C에선 포인터로 전달한다거나, 아니면 앰퍼샌드(&, Ampersand) 써 가지고 레퍼런스로 전달하거나 같은 얘기죠. 그게 기본 behavior였어요. 왜냐면 C#에서는 분명하게 말하니까. 오브젝트는 무조건 레퍼런스 타입으로 전달되고, struct는 무조건 밸류 타입으로 전달되기 때문에. Objective-C도 그랬거든요, 제가 알기론.

그런데 얘네들이 바꾼 거예요. 어레이하고 딕셔너리는 이제부터는 모두 다 밸류 타입이래요. 그래서 어레이랑 그거를 딴 데 대입을 하거나 패스를 하면 밸류 타입이 되면서 새로운 카피가 만들어지는 거예요. 혼란스럽죠?

이게 뭐야. 근데 더 혼란스럽게 만들었어요. 딕셔너리는 무조건 밸류 타입으로 해서 카피가 되는데, 어레이는 아니래요. 어레이는 패스가 되면 밸류 타입이긴 한데 복사가 이루어지지 않다가, 어레이 타입에 컨테이너 사이즈가 바뀌거나 그 안에 값이 바뀌면 그때 복사를 한대요.

들으면서 “이게 무슨 개소리야?” 이유는 알아요. 이유는 아까 말했듯이 복사 막고 성능을 빠르게, 좋게 하려고. 다 좋은데 문제는 이 코드를 봤을 때 보이지 않는 온갖 자잘한 규칙을 사람들이 왜 외워야 하는지 모르겠다는 거예요.

그리고 Objective-C에서 이거를 만든 이유가, 아무래도 아이폰 쪽 개발하는 사람들 중에 캐주얼한 사람들이 많다 보니까. C나 C++처럼 투철하게 프로그래밍하는 사람도 적고, 좀 대충하는 사람들이 많기 때문에 실수를 할 수 있다는 것 때문에. 이거를 실수가 적은 랭귀지를 만들려고 그 짓을 한 거거든요.

근데 그 사람들이 그 규칙을 외울 리가 없어. (웃음) 절대 안 외워요. 규칙은 말 그대로 한 가지, 두 가지 뚜렷한 규칙이 있고 이유가 있고 언제나 컨시스턴트(consistent)하게 되어야 하는데, 그게 아니라 “어레이를 하면 이게 그래, 내가 사이즈를 바꾸거나 내용을 바꾸면 그때 복사가 이루어나고…” 이런 거.

보면서 “이 언어, 저것 때문에 욕 디게 먹겠다.” 그런 생각이 딱 들었어요. 그래서 굉장히 잘못 설계한 부분이고. 언어 자체는 그나마 뛰어나요. 그 부분이 굉장히 잘못됐어요.

올바른 방법은 C# 부분이 옳아요. 왜냐면 C#에서 말 그대로 제가 딕셔너리가 있어요. 이거의 사본을 만들고 싶으면 그냥 닷 투 딕셔너리(ToDictionary) 이런 식으로 하면 돼요. 그러면 사본을 만들어 줘요. 아니면 그냥 함수를 따로 만들거나, Copy라는 함수를 만들어 주던가.

기본적으로는 원래 규칙상, 모든 오브젝트는 레퍼런스 타입이니까 레퍼런스 타입으로 전달이 되지만, 정말 네가 사본이 필요하면 함수 호출해서 닷 카피(.Copy)라든가 닷 투 어레이(.ToArray)라든가 이렇게 사본을 받으면 되는 거거든요. 그러면 얼마나 깔끔해. 내가 복사하고 싶으면 복사하고, 아니면 말고.

이거를 왜 그따위로 하는지 이해가 안 되더라고요. 그래서 제가 Swift를 깔 건 그것뿐이고, 사실은 그게 굉장히 마음에 안 들었어요.

언어 얘기가 나왔으니까 말인데, 요즘 진짜 제대로 언어를… 새로운 언어가 몇 개씩 나오거든요. 정말 제대로 디자인한 언어는 제가 최근에 본 것 중에는 모질라에서 만들고 있는 러스트(Rust) 하나뿐인 것 같아요.

걔네 개념은 이제 웹에서 도는 컴파일 되는 언어거든요. 웹에서 이제 스크립트 언어가 워낙 느리다 보니까, PHP 버추얼 머신 만들고 PHP로 컴파일하는 이런 개소리도 하고. 근데 걔네들은 아예 컴파일 되는 언어를 만들겠다는 거예요. 그래서 엄청 빠르게 돌 수 있는.

재밌는 거는 그런 비슷한 언어가 또 하나 있죠. 아… 구글의 고랭(Go lang)이라고. 걔네들 비슷한 개념으로 시작해서 만들었죠. 최근에 안 거지만, 예전에 C++나 이런 쪽을 디자인했던 뭔가 뛰어난 아저씨들이, 할아버지들이 모여서 만든 거다 뭐 이런 식으로 얘기를 하는데.

그래서 저도 한번 봤죠. 고랭을 많이 쓴다고 그래서, 구글에서. 딱 봤는데, 보고 튜토리얼 좀 보고 코드 좀 몇 번 짜보고 그냥 던졌어요. 짜잘하게 리스트 액션 이런 거 막 두어 가지 있고, 실수를 못 하게 하겠다는 의도 자체는 좋은데.

신택스(syntax) 딱 보는 순간 “아, 이거는 70년대, 80년대 신택스구나.” 정말 쓰기 싫은 신택스? 치다 보면 손가락이 아픈 신택스. 뭐 예를 들어서 시프트를 누를 일이 많다거나, 뭐 이런 이상한 짓들 보면서.

쩝. 저건 아니다. 저거는 코드 가독성에 문제가 생기는 언어더라고요, 저한테는. 신택스상의 문제로. 저거는 제가 정말 손대기 싫은 신택스고, 저는 죽어도 안 만지게 될 거고. 제가 안 만지면 다른 사람도 안 만질 거라고 봐요.

그래서 고랭은 그냥 제 생각에는 특화된 분야, 구글 쪽에서 열심히 쓰다가 알아서 사장될 것 같고. 제 생각에는… 쩝.

러스트 언어를 보면은, 정말 그 스위프트가 하려고 했던 거를 얘네가 일단 다 했고요. 최적화 가능할 수 있도록 기본 방식을 되게 잘했어요. 모든 변수는 기본적으로 모두 상수예요. 일단 대입을 하면은 바꿀 수가 없어요. 바꾸고 싶으면 변수를 선언할 때 이게 상수가 아니다라고 선언을 해야 돼요.

상당히 개념적으론 맞는 얘기거든요. 어찌 보면. 그러면은 컴파일러가 볼 때 상수인 거는 알아서 다 컴파일하고 최적화할 수 있는 거고, 변수는 안 하고. 그런 것도 잘 되어 있고.

이런 mutable, immutable 그런 얘긴데, 결과적으로는 이렇게 값이 변하지 않는 거면 멀티스레딩을 뽑을 때도 훨씬 안전하잖아요. 값이 변하지 않는 게 분명하고, 변하려면 이제 컴파일러가 에러를 주니까. 이건 변하지 않는 값이니까 멀티스레딩을 뽑아도 레이스 컨디션(Race Condition) 같은 거 날 경우도 없고.

문법도 되게 깔끔하고, 굉장히 모던한 문법도 많이 따라갔고요. 사실 약간 C하고 C#하고 비슷한 경향도 보이기도 하고. 옛날에 이상한 언어하고는 전혀 다르고. 아직도 열심히 개발 중인 거고, 아직도 초기이긴 한데.

일단 스펙 읽어보고 코드 읽어볼 때는, 보면서 이해가 돼요. “정말 깔끔하구나.” 그리고 최근 언어들이 지원하기 시작한 온갖 그런 것들 다 지원하고. 제가 볼 때는 가장 생각을 열심히 잘했고, 가장 기본 behavior를 확실하게 만들고 있는 언어 같긴 해요.

보면서 “아… 저 언어가 빨리 좀 나와서 메인스트림이 되면 참 좋겠다.” 그렇게 생각하는데. 최근에 삼성이 그거를 돕기 시작했다나 그래 가지고, 안 믿으시는 분들이 조금 있더라고요. “삼성이랑 모질라가 함께 하면 조금 이상하다.” 뭐 그거까지는 모르겠고.

오늘 하려고 했던 얘기는 그거예요. 언어가 좋고 나쁘고는 말 그대로 기본 동작이 뭐냐가 되게 중요한 것 같아요.

제가 예전에 마이크로소프트 포럼에서 가끔 답 달아줄 때, 어떤 학생들은 “왜 숫자가 1이 아니라 0부터 시작하냐, 어레이(Array) 같은 거 접근할 때. 너무 혼란스럽고 복잡하다.” 이런 얘기를 했는데.

뭐 10진수를 주로 써 온 사람, 그리고 일반적으로 1을 첫 번째 숫자로 생각하는 경우가 많잖아요. 사실은 1, 2, 3, 4, 5, 6, 7, 8 이런 식으로. 우리가 0, 1, 2, 3, 4 이렇게 따지진 않으니까. 거기서 오는 혼돈은 알겠는데.

어레이 접근을 할 때는, 특히 C++에서 메모리 포인터 연산하고 그게 또 맞아떨어지는 게 있거든요. 그래서 0이면 내가 시작하는 곳, 1이면 지금에서 한 발자국 더 나아간 곳. 이런 개념으로 들어가는 거기 때문에 시작이 0부터 하는 건데.

그런 기본 behavior도 어찌 보면은 보는 사람에 따라 다르게 볼 수가 있는 거죠. “아, 이거 정말 불편하다.” “아, 정말 편하다.” 근데 만약에 그 사람한테 이렇게 돼서 “이것 때문에 우리가 이런 규칙으로 가는 거다”라는 확실한 규칙을 보여줄 수 있다면, 저는 그거는 괜찮은 기본이라고 봐요.

오히려 저는 어레이 같은 거를 1, 2, 3, 4로 가는 거는 나중에 포인터 연산을 할 때마다 숫자 바꾸고 하는 거 따지면 오히려 버그를 만들 가능성이 높다고 생각하기 때문에.

기본 동작 제대로 박고, 확실하게 정립할 거 정립하고, 확실하게 강요할 거 강요하지만. 정말 말도 안 되는 기본 동작은 좀 그만 좀 만들었으면 좋겠어요.

아까 말했던 스위프트에서의 복사 문제도 그렇고. 뭐 C#에서 몇 가지 말했던 거. C#은 제가 나쁘게 말할 여지가 많던 게, 최근에 나쁜 면모를 많이 봐서 그래요.

그리고 나쁜 면모가 되게 웃긴 게, 코어 랭귀지(core language) 쪽보다는 나중에 이제 웹 쪽이나 UI 쪽을 서포팅을 어떻게 하면서 거기서 억지로 넣기 시작하면서 생긴 거에서 문제가 많이 생겼다는 게 되게 웃겨요.

제가 볼 땐 다른 팀이 만들었거나, 아니면 원래 기획자가 나간 것 같은데. 러스트는… 아, 모질라가 정말 제가 볼 때는 기술력은 뛰어난 것 같아요. 비즈니스 센스는 좀 안 좋을진 몰라도. 보면서 “야, 저 정도 언어를 그래도 만드는구나.”

물론 오픈소스죠. 오픈소스여야 하고, 열심히 같이 만드는 건데. 최종 결정은 아무래도 모질라 쪽 사람들이 하는 게 아닐까 싶어요. 회사라기보단 그쪽에 있는 사람들이.

보면서 “야, 저 언어 진짜 언제 쓰고 싶다.”라는 생각을 하는데… 쩝. 뭐 언어는 사실 툴이 따라와야죠. 그래서 비주얼 스튜디오만 한 툴이 저기에 들어가고, 아니면 비주얼 스튜디오가 러스트를 지원할 수 있다면 좋겠고.

아니면 쩝… 마소에서 새로운 언어를 만들어도 되고요, 사실은. 마소에서 C# 정도 만든 걸로 컴파일 되는 언어. C#을 컴파일하려고 하고는 있지만, 지금 C#이 좀 많이 더러워진 상태라… 하아~.

C#에 대해선 앞으로 걱정이 조금 많아요. 제가 C# 스펙 한 3.0에서 머무르고 2.0이나, 그러고 거기다가 패러럴 라이브러리 정도만 쓰는 거면은 굉장히 깔끔한 코드가 나올 텐데. 그 외에 문제가 좀 많더라고요.

하아… 프로그래밍 얘기를 하면 언제나 얘기가 길어져.

포프였습니다.