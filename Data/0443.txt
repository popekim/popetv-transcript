예 안녕하세요 포프입니다
저번 편에서 말한 거에 연장도 있고
요즘 최근에 코딩 이야기를 좀 별로 덜 하니까 사람들이 코딩 비디오 나올 때마다
와 오랜만에 코딩 이야기에요 라고 하는 게 있어서 또 코딩 얘기를 할게요
오늘 얘기할 거는 C#에서 이제 뭐 처음은 아니겠죠 근데
굉장히 많이 쓰던 언어 중에는 C#이 이거를 제대로 만든 게 처음이었고
그리고 어찌보면은 이 덕분에 이제 웹 프로그래밍을 갈 때 데이터와 함수를 이제 분리하면서도
오브젝트 오리엔티드 프로그래밍처럼 OOP처럼 쓸 수 있게 해주는 굉장히 훌륭한 그런 개념이라고 생각을 해서 설명을 해요
익스텐션 메서드라고 하는 거예요 익스텐션 메서드
뭐 C에는 C++에는 없는 것 같고 있는데 제가 모를 수도 있죠 아무도 안 써서
자바단에는 들어왔는지 모르겠는데
자바 쪽에는 제가 예전에 봤을 때는 없었어요 그래서 일단은 없다고 생각하고 시작을 할게요
그럼 이제 이게 나오게 된 계기가 뭐냐 물론 저는 몰라요 근데 제가 추측을 할게요
저한테 왜 유용성이 있는지 저번 편에서 제가 그런 얘기를 했어요
이건 예를 들어서 얘기하는 건데 일단 적용이 될 부분이 많은 것 같아요
저번 편에서 이제 뭐 DTO라던가 이런 데이터를 여러 서비스 단에서 어떻게 주고 받느냐
그리고 주고 받을 때 이 클래스 오브젝트 오브젝트 이런 데이터를 여러 서비스 단에서 어떻게 주고 받느냐

이런 데이터 오브젝트를 이제 표현하는 클래스는 데이터만 들어있는 퓨어 데이터 오브젝트여야 한다 라는 얘기를 했었어요 그죠
근데 왜 그래야 되냐 라고 질문을 하면은 되게 간단해요 사실은
왜냐면 이 데이터는 다른 이제 뭐 매체로 시어라이즈가 되고 디시어라이즈가 되는 그런 데이터라고 봐요
그러면 이 데이터를 리더빌리티 이슈나 이런 걸 생각을 할 때 딱 가장 좋은 거는 순수하게 프로퍼티만 쫙 있고 퍼블릭 프로퍼티만
거기에 getter, setter가 있는 게 제일 좋은 거예요
제가 말하는 getter, setter는 이제 뭐 get 이런 함수가 아니라 C# 프로퍼티에 있는 get, set 넣으면 알아서 get해주고 set해주고 이런 걸 얘기하는 거예요
그러면은 여기에 함수가 들어가거나 아니면은 다른 프로퍼티가 들어간다
그, 다른 프로퍼티 무슨 얘기냐면 이게 실제 텍스트나 이런 걸로 시리얼라이즈가, 시리얼라이즈나 디시리얼라이즈가 안 되고
다른 프로퍼티요
프로퍼티를 두 개를 더해서 값을 반환하면 이런 식의 add라는 함수가 있잖아요
그 함수 1을 대신하는
그런 프로퍼티가 들어가면 코드를 짤 땐 되게 편해요
데이터가 들어왔는데 이 데이터를 해석할 방법이 이미 함수에 있으니까
그러나 데이터를 표현하는 개체라는 의미에서는 리더빌리티가 굉장히 딸리고
실수로 만약에 그런 프로퍼티에 xmlignore라든가 jsonignore 이런 식의 attribute로 박지 않으면
그게 실제 데이터로 세이브가 되는데
그 데이터는 중복되는 데이터에서 필요가 없는 경우도 있고 이런 부분이 있어요
물론 이걸 또 상속을 해서 어떻게 해서 해결할 수도 있지만
그냥 가장 깔끔한 거는 순수하게 이 클래스가 있고
그 클래스에 데이터만 있는 게 깔끔하다는 건 누구나 이제 인정을 할 거예요
그럼 이렇게 가면은
아 그러면은 그래 데이터는 그렇게 유지를 하자
오케이 라고 얘기를 했어요
그럼 여기서 이제
아 여기서 아까 말했던 그 두 값을 프로퍼티를 더해갖고 어떤 일을 해야 될 때
그게 사실은 프로퍼티하고도 프로퍼티라고 할 수 있지만
파생된 프로퍼티라고 얘기를 많이 하거든요 파생된 멤버 변수
기존에 있는 두 멤버 변수 아니면 둘 이상의 멤버 변수로
그 값을 조합해서 나올 수 있는 다른 프로퍼티가 있는데
이거를 왜 오브젝트에서 또 프로퍼티를 넣냐
아 그러면은 그래 데이터는 그렇게 유지를 하자 OK라고 얘기를 했어요 그럼 여기서 이제 아 여기서 아까 말했던 그 두 값을 프로퍼티를 더해갖고 어떤 일을 해야 될 때
이거는 중복되는 게 필요가 없다라는 게 일반적인 이제 사람들의 선택이라고 저는 믿고 싶고 그냥
왜냐하면은 그게 아니라면 또 뭐 이 데이터가 잘못됐을 때
한쪽에 기본이 되는 데이터가 잘못되고
거기서 드라이브된 파생된 이 데이터가 잘못되지 않았을 경우에 또
좀 데이터의 뭐라 그러죠 그거를?
무슨 유효성 아니야 데이터에게 검증 뭐 이런 게 되게 애매해질 수도 있고
어쨌든 그 뭔가 검증을 할 때 데이터는 하나에서 다른 걸로 유추할 수 있다면
그 유출될 수 있는 걸 버리고 기본이 되는 것만 갖고 있는 게 정상이라고 보통 얘기를 하고
저도 그렇게 믿으니까 그러면은 이제 이런 함수를 만들게 해야 될 거 아니에요
그러면 가장 흔히 생각할 수 있는 함수가 어 그래? 그러면은 스태틱 함수를 만들어서
한마디로 글로벌 함수죠 거기다가 이 오브젝트를 던져주면은 그 오브젝트에서 프로퍼티 두 개 읽어서 값을 반환하는 거죠

값을 반환하는 형식으로 만들면 되겠구나
그럼 이거는 완벽하게 프로세저럴로 돌아가는 거예요
C 스타일에 스트럭트가 있고 단 이제 함수가 이제 글로벌 함수로 다 있고
거기에 어떤 스트럭트를 넣어주냐에 따라 이제 그 함수가 호출되게 되는 거고
함수 오버로딩이 있으니까 그럼 거기서 그 값을 계산해서 결과를 반환하는 거죠
그러면 이제 OOP를 열심히 했는데 갑자기 코드가 막 글로벌 함수의 개념이 되는 거예요 말도 안 되게
그러면 이제 또 약간 짜증이 나거든요
야 그 함수 자체는 이 오브젝트에서만 이 클래스에서만 호출이 되는 건데
이거를 아무거나 집어넣으면 되는 게 말이 안 되잖아
이런 문제가 생겨요
그래서 이런 문제들을 실제 내부적으로는 똑같이 이렇게 둘 거라고 전 생각을 하는데
실제 그럴 거예요
이 문제들을 그냥 약간 OOP적으로 바꿔준 게 익스텐션 메서드라는 거예요 이 C#에서
이 개념은 어떠냐
일단 익스텐션 메서드를 만들 때는
일단 아까 말했던 오브젝트에 클래스 A라는 게 있다고 생각해봐요
이게 순수하게 데이터예요
그러면 이제 또 다른 클래스를 만들어요
근데 이 클래스는 스태틱 클래스예요 한마디로 글로벌 함수예요 사실은
근데 스태틱 클래스를 만들고 그 함수 그 안에 함수를 또 스태틱 함수로 넣어야 되죠
넣는데 반환 값 넣고 스태틱이라고 넣고 이제 뭐 함수 이름 적은 다음에
그 다음에
그 뒤에 되게 재밌는 문법이 나오는데
이 앞에 dis를 넣어요 THIS
그리고 한 칸 띄고 어떤 타입을 넣어요
저희가 얘기한 익스텐션 메서드가 아까 A라는 클래스의 익스텐션 메서드를 만드는 거거든요
그래서 A를 넣어야 돼요
dis 한 칸 띄고 A 넣고 이제 변수명 넣고 이제 그리고 닫은 다음에 그 안에 함수를 짜면 돼요
그럼 이 함수를 어떻게 호출하느냐
물론 아까 글로벌 함수 호출하듯이 뭐 이 익스텐션 클래스 가서 다 찍고 함수 이름 찍은 다음에
이 오브젝트를 패스해주는 방법도 있지만
그러면은 정말 이거는 C-Style procedural language고 좀 OOP적으로 보이게 하기 위해서
이거 어떻게 하냐면은 아까 오브젝트 있잖아요 A
거기서 오브젝트 만든 게 small character A라고 해봐요
그러니까 소문자 A 그럼 A.extensionMethod 함수 이름을 넣고 가로 열고 그냥 닫으면 이 함수가 호출이 돼요
컴파일러 단에서 이걸 다 바꿔주는 거예요 사실은
보면서 아 이게 A.extensionMethod 스태틱 함수 호출했으니까
C처럼 아까 procedural language 호출하는 것처럼 해주면 되겠구나
내부적으로는 그렇게 해주는데 코드에서 볼 때는 일단은 굉장히 OOP적으로 보이고 말이 되죠
내가 글로벌 함수 호출해갖고 데이터 던지는 게 아니라 이 데이터를 시작해서 야 이 데이터가 있어
이 데이터에서 이 새로운 값을 구해줘 이렇게 하는 거죠
이게 그전 비디오하고 왜 관련이 있다고 얘기하냐
그전 비디오에서 그런 얘기 했잖아요
엔티티 프레임워크 단에서 세이브된 데이터를 서비스 위쪽으로 올려주는 겁니다
근데 그게 말이 안 된다
새로운 오브젝트를 만들어서 DTO를 만들어서 보내줘야 된다
그럼 이걸 어떻게 만드냐
보통 new 한 다음에 막 property 하나씩 넣고 막 이렇게 했을 거예요
근데 그게 아니라 아까 말했던 엔티티 있잖아요
엔티티 프레임워크에 쓰는 그 엔티티 오브젝트 그 클래스
그 타입용으로 extension 메서드를 만들어주면 돼요
그리고 거기 이제 뭐 함수 이름 자체를 그냥 뭐 to 뭐 DTO 뭐 to 어쩌고 DTO
이런 식으로 해놓고 그 extension 메서드 안에서
제가 좀 전에 말했던 손으로 막 new 뭐 DTO 오브젝트 만들고 assignment하고 이런 거를
그 안에 extension 메서드 넣으면 되는 거예요
그럼 코드 짤 때는 되게 간단해요
엔티티 모델 딱 불러온 다음에 db 긁어서 갖고 오면 거기다가 딱 닫히고
to 어쩌고 DTO
물론 이게 코드가 재사용할 필요가 없는데
함수를 만든다는 거에서는 조금 이제 뭐 재사용성 함수 얘기
예전에 말한 제가 말한 코딩 스탠다드하고는 약간 반하는 부분이 있어요
근데 이걸 사람들이 손코딩할 때
손코딩을 하기 시작을 하면은 이제 비슷한 DTO를 여기저기서 반환하거든요
한 함수가 아니라 여러 함수에서
근데 사람들이 그냥 손코딩을 계속 복붙하면서 하기 시작하거나
뭐 그러면 이제 한 군데 고치기만 하면 되는 걸
만약에 엔티티가 바뀌었어요 새로운 필드가 추가됐어
그럼 DTO에서 값을 반환하는 로직이 바뀔 수도 있어요
그거를 모든 곳에서 쓰인 곳을 찾아가면서 바꿔간다는 것 자체도
조금 힘든 부분도 있고 그리고 남이 그렇게 서비스단에서
이 코드 새로운 DTO 만드는 코드를 작성해 놓은 거를
한눈에 보고 그걸 고치 재사용을 하려는 사람들이 생각보다 좀 적은 것도 있었어요
그래서 이거는 어찌보면은 OOP적인 좀 깔끔함 플러스
워낙 그 딥이 긁어오는 코드가 굉장히 길고 장문이고
약간 좀 읽기 편하지 않은 부분이 있어서 사람들이 헷갈릴 수 있다는 부분
그런 거를 고려해서 원래 함수는 뭐
함수는 재사용을 하지 않느냐 만들지 않는다는 규칙을 약간은
예외를 만든 거라고 할 수가 있어요
그리고 어찌보면은 되게 정형화된 패턴이라서 그냥 함수를 만들기로 결정한 걸 수도 있고
당연히 엔티티가 있으면 DTO 만들어야 되고 DTO가 나면 당연히 B모델 만들어야 되고
그리고 지금 잠깐 말했듯이 DTO에서 B모델 갈 때도 똑같이 익스텐션 메서드를 써서 만들 수가 있어요
그래서 익스텐션 메서드 이렇게 쓰면 되게 편하다
그리고 익스텐션 메서드를 제가 또 다르게 쓴 경우가 뭐가 있었냐면은
이거는 어찌보면은 이제 다른 OOP에서 겪었던 문제는 있을 거예요 똑같은 문제가
예를 들어서 제가 외부 라이브러리를 받았어요 외부 라이브러리를
근데 제가 소스코드가 없고 뭐 DLL만 있거나 바이너리만 있는 거예요
근데 이거를 내가 확장을 해서 좀 더 뭔가를 하고 싶어
그러면 저희가 할 수 있는 게 보통 그거잖아요 상속을 받아서 오브젝트를 확장을 해버리잖아요
근데 문제는
이
이
그 오브젝트 자체가
그 라이브러리 단에서 오브젝트를 만들어서 던져주는 경우가 있어요
그러면 내가 이거를 내 함수를 쓰기 위해서 캐스팅을
children 함수로 아니 children 이제 오브젝트로 캐스팅을 해서 쓸 수도 있는데
굉장히 핵하잖아요 사실 말 자체가
원랜 그러면 안 되는 거고 이제 뭐 메모리 구조상 위치상 함수만 추가된 오브젝트로
이제 캐스팅을 해서 새로운 함수를 호출하는 거는 문제는 안 돼요 문제는 당연히 안 되는데
그런 게 코드에 보이면 보일수록 이제 사람들이 클래스를 따보고 이게 그런지 아닌지 고민하는 게 있어야 되기 때문에 그게 안 되거든요
그럼 얘네는 이제 약간 뭐 디자인 패턴에서 약간 커맨드 패턴 비슷하기도 한데
그런 결과적으로 아까 말했던 그런 글로벌 함수 만들어갖고 거기에 오브젝트 던져줘갖고 그 오브젝트에서 이제 함수를 실행하는 개념인데 그걸 약간 패턴을 만들어서
패턴화 시킨 것들이 있겠죠 당연히 이제 커맨드 패턴은 약간 다르긴 한데 그런 식으로 하는 거예요 내가 어떤 클래스를 만들어두고
이 클래스는 어떤 커맨드를 그냥 호출하는 클래스일 뿐이에요 그럼 그 안에 커맨드 메서드가 있고 그럼 이 커맨드를 어떤 개체에 이제 호출을 할 거냐
그리고 이 개체를 받아야 되잖아요 그 개체를 이제 매개면수로 들어오거나 뭐 컨스트럭터 할 때 거기에 매개면수를 들어가서 들고 있다가 호출하거나 이런 방식으로 이제 만드는 건데
이런 걸 만들다 보면은 뭐 이게 추상화가 좋고 뭐 이게 확장성이 좋고 다 좋은 얘기인데 가독성이 더럽게 안 좋아요 왜 쓸데없이 값 두 개 더하는 거를 이런 식으로 클래스를 또 만들어서 해야 되나요 라는 게 할 수는 있어요 할 수는 있는데 사람이 보통 인식하는 물체라는 개념과는 다르기 때문에 더 애매해지게 돼요
근데 C샵에서는 이게 익스텐션 메소드로 해결이 가능하다는 거죠 그게 재밌는 거예요
그래 내가 우리 라이브러리 사왔는데 거기 DLL에서 받는 오브젝트가 있어 내가 이 오브젝트 안에 함수를 추가할 수는 없거든 상속을 받아 갖고 캐스팅하는 건 또 아닌 거 같아 그런 경우에 그냥 익스텐션 메소드로 만들면 돼요
아까 말한 오브젝트가 클래스가 이게 뭐 B라고 했다 그럼 익스텐션 메소드 하나 만들고 스태틱 클래스 스태틱 메소드로 그리고 그 안에다가 디스 B 뭐 그리고 뭐 스몰 캐릭터 뭐 뭐 패러미터 뭐 A 뭐 어쨌든 간에 그건 변수 이름
타입 변수 이름 이렇게 넣고 그 안에 로직 돌려갖고 리턴하는 것만으로도 실제 코드를 짤 때는 이 클래스에 실제 있는 처음은 B 클래스에 있는 함수마냥 호출하고 쓸 수가 있는 거예요
물론 이제 그 안에 있는 프라이빗 멤버나 프로텍트 멤버는 읽을 수가 없지만 최소한 노출이 돼 있는 모든 데이터를 제 마음대로 바꿔서 그 기능을 추가할 수가 있는 거죠 그래서 익스텐션이라고 이름이 붙은 게 그 이유예요
그래서 이거 굉장히 많이 쓰여요 굉장히 많이 써요 굉장히 많이 써요
C샵 이제 마이크로소프트에서 보면은 HTTP 클라이언트 웹 API 쓰는 클라이언트가 있잖아요 거기에 들어간 함수는 굉장히 제한적이에요 왜냐하면 뭐 굉장히 복잡한 거 쓸 필요 없으니까 포스트하고 겟하고 뭐 이런 게 전부잖아요
근데 거기서 포스트나 겟을 할 때 이제 제이썬 파일을 자동으로 만들어주기 위해서 오브젝트를 넣을 수 있는 그런 익스텐션들이 있어요
그게 HTTP 클라이언트 안에 들어있는 게 아니라 익스텐션으로 함수를 따로 만들어주고
만들어주는 거예요 그럼 그 익스텐션 메서드에서 뭐 하냐 그거 읽어와서 그 읽어온 거를 제이썬 스트링으로 바꿔주고 헤더를 애플리케이션 제이썬으로 넣어준 다음에 포스트를 쏴주는 거예요 그냥
그러면은 그 정말 단순하게 굉장히 가벼운 클래스만 쓰고 싶은 사람들은 아까 말했던 코어 HTTP 클라이언트만 쓰면 되는 거고 그 외에 어 나 제이썬이나 이런 거 추가하는 게 필요해
그러면 이제 그거를 익스텐션 메서드만 인클루이드해서 쓸 수가 있는 거죠
그러면은 그냥 상속에 상속을 드럽게 받아서 뭐 뭐 HTTP 클라이언트가 있고
JsonHttp 클라이언트가 있을 거고 여러 가지가 있었겠죠
익스텐션 메서드가 들어오는 이내에서 굉장히
코드 구조가 깔끔하고 리더빌리티가 좋아지고
그리고 어찌보면 이제 인터페이스의 남용을 막을 수 있는 것도 그거였어요
왜냐하면은 HTTP 클라이언트를 만들었을 때
Vielleicht Json 클라이언트가 있게 다른 클라이언트가 있고 막 이러면은
그거를 이제 무엇보다 부모 클래스를 잡고 있거나
인터페이스 클래스로 해서 잡고 있고
그럼 그 안에 무슨 형이 뭔지도 모르는 상황에서 막 되게
실행 중에 형 변환하고 형 판단하고 복잡한 부분이 있거든요
근데 익스텐션 메서드를 통해서
글로벌 함수를 굉장히 OOP처럼 보이게 약간 꼼수를 써놓은 건데
실제 그 처음 들어오는 매개변수, 디스 매개변수는
실제 그 오브젝트를 받아놓은 거기 때문에
OOP 내부적으로 도는 거랑 또 차이가 없어요
그게 이제 OOP만 윗단에서 대충 어설프게 보신 분들은
이게 OOP가 되게 다르더라고 생각하실 텐데
실제로는 결과적으로는 뭐 어셈블리 단으로 내려가서
컴퓨터가 이해해야 되는 그런 뭐 기계어로 바뀌는 거기 때문에
결과적으로는 그냥 함수가 있고 점프 테이블이 있는 것뿐이고
그리고 첫 번째 매개변수로 오브젝트가 들어오는 게 전부거든요
사실 어셈블리 단에서는 그렇게 볼 수밖에 없어요
뭐 C단에서도 그렇게 봐야 되고
그럼 결과적으로는 그 어셈블리에 도는 그대로 방식과
이렇게 익스텐션 메서더를 만드는 방식과 똑같은 거고
뭐 성능상의 이제 문제가 있다는 거는
뭐 메모리상에서 로컬리티, 데이터 캐시의 문제, 인스트럭션 캐시의 문제 그게 전부고
이걸로 인해 OOP보다 느려질 부분은 솔직히 없어요
그냥 구조상으로 그냥 캐시나 CPU 아키텍처나 이런 거 다 빼고 봤을 때 그냥은
그렇게 보면 되게 재밌어지는 거죠
그리고 이렇게 함으로 인해서 오히려 뭐 버추얼 함수를 줄일 수 있다
그러면 뭐 당연히 이 함수로 치기 위해서 한 번 더 점프를 하는 이런 것들이 있지만
버추얼 함수를 줄일 수 있다는 거에서는
이제 뭐 안 쓰는 것보단 줄어들 것 같아요
상속을 통해서 인터페이스 하는 건 당연히 버추얼 함수가 줄어들 수밖에 없고
그러면 오히려 성능이 나아질 수도 있는 거거든요
그래서 보면은 굉장히 누가 생각을 했는지 몰라도 처음 시작이 어딘지 저는 모르겠지만
그래서 보면은 굉장히 누가 생각을 했는지 몰라도 처음 시작이 어딘지 저는 모르겠지만

굉장히 똑똑한 아이디어였구나 아이디어였구나
오래 써보고 느끼고 있는 거야
아 내부적으로 이렇게 돌겠구나 이렇게 되는 거구나
똑똑한 아이디어였구나
이거를 C#에 도입한 그 C# 창시자겠죠
그분도 제가 언제나 말하지만 이분은 되게 똑똑하신 분이에요
언어 구조 프로그래밍 언어를 설계하는 사람 중에는
이 사람보다 뛰어난 사람이 과연 있을까 싶을 정도로 되게 뛰어난 사람이고
이 사람이 만든 개념이 아닐 수도 있어요
그냥 어디서 갖고 와서 보고 있는 사람이고
보고 나서 아 이거를 이렇게 차용을 해야겠다
그리고 신텍스적으로 이렇게 만들어야지만 혼란이었고 좋겠다
이런 식으로 해서 만드신 것 같고
그래서 그분도 대단하다고 생각을 하고요
그래서 C#을 이제 제가 다른 언어보다 낫다고 하는 부분도
이런 식으로 굉장히 뛰어난 아이디어가 있을 때 복잡하지 않게
혼란스럽지 않게 딱 코드를 짜면서 이제 딱 리니어
선형적으로 이해가 가능하게 만들었다는 부분에서 훈련을 했고
딱 코드를 짜면서 이제 딱 리니어 선형적으로 이해가 가능하게 만들었다는 부분에서 훈련을 했죠
딱 코드를 짜면서 이제 딱 리니어 선형적으로 이해가 가능하게 만들었다는 부분에서 훈련을 했죠
딱 코드를 짜면서 이제 딱 리니어 선형적으로 이해가 가능하게 만들었다는 부분에서 훈련을 했죠
그래서 아 한 번쯤 C# 광고도 했고
익스텐션 메서드 안 쓰신 분들은 이런데 쓰시는 거예요 이런데
많이 쓰는 게 좋아요 굉장히 좋아요 굉장히 편해요
그래서 다른 언어에서 없기 때문에 없는 개념이기 때문에 흔히 쓰는 언어들에서
익스텐션 메서드를 잘 모르시고 안 쓰시는 분들도 많은데
C#을 쓰시는 분들이라면 한 번쯤 꼭 보시도록 해요
그래서 굉장히 좋은 거다
그래서 오늘은 또 C#을 열심히
찬양하고 광고를 하는 비디오를 만들었으니까 마술사에서도 좋아하겠지?
포프였습니다
