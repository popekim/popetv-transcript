예 안녕하세요 포프입니다 요즘은 참 세상이 재밌어지고 있는 것 같아요
이제 기계들이 되게 발전하고 뭐 인공지능 로봇 이런 게 발전하면서
굉장히 모든 거에 자동화가 되고 인간의 삶을 편하게 하는 그런 세상이
왔죠 그리고 이제 한 10년 20년 있으면 그 기계 인공지능이 워낙 발달을
해서 이제 그 사람들이 이제 지구를 정복을 하고 저희가 이제 로봇을
섬기는 몸종이 되는 그런 즐거운 난날이 올 건데 여기까지 농담이고요
사실 그런 공포는 언젠가 있었지만 아 제가 볼 때 뭐 그 정도로 인공지능
이 발전하기 좀 어려울 것 같고 제가 하고 싶은 얘기는 사실 그거
에요 저희 저희는 엔지니어잖아요 저는 엔지니어예요 보시는 분들
다는 아니겠지만 엔지니어의 단점 중에 하나는 저희는 굉장히 뭔가
논리적인 걸 좋아하고 기계로서 상당히 많은 일을 해결할 수 있을
거라고 생각합니다.
뭐 저만 그런가 아닐 거라고 믿고 그렇기 때문에 뭐 어떤 거에서
자동화가 되고 있고 그걸로 인해 저희 그 힘든 그런 그런 반복작업
뭐 이렇게 세세한 그런 귀찮은 일들을 고칠 수가 있다면 저희는 그걸 언제나
하고 싶어하죠 그리고 그런 거에 가장 먼저 익사이팅하는 사람들이
기도 하고 그런 거를 가장 먼저 접목하는 받아들이는 사람들이기도
하고 그래서 저도 집에 일단 마누라 봇이 하나 있고요 마누라 봇이라고
해봐요 로봇청소기 그게 하나 있고 그리고 이제는 심지어는 그
바닥 닦는 청소기까지 살까라고 생각 바닥 닦는 로봇이죠 그것까지
살까라고 고민을 하고 있는데 뭐 여러 가지 홈 자동화부터 그렇고
제가 지금 하려고 하려는 말씀은 그런 뭐라 그래요 자기 게임에 빠져서
오히려 인생 귀찮게 하지 말라는 거예요 그러는 경우가 실제 게임
업계에서 너무나 너무나 자주 일어나고 있고 저도 몇 번이나 겪었고 그래서
저는 그런 예를 한번 들어 드릴게요 오늘 하고 싶은 말은 결국은 그거
에요 자동화 좋고 기계 만능주의도 좋지만 결국에는 어느 순간에는
그 기계 만능주의 때문에 오히려 사람이 피곤해지는 경우가 있고
적당한 자동화와 사람의 손길을 딱 접목을 시켜야 새로운 인류가
탄생 아니 그 새로운 굉장히 괜찮은 그 시스템이 탄생을 하면서 그게
오히려 효율성에 도움이 된다는 거죠.
그래서 제가 이런 것들을 많이 알고 있는 분들이고 c++ 쪽으로
코딩을 많이 짜주시는 분들은 아마 빌드 서버를 다 알고 계실 거예요
이제 저희가 코드를 보통 짜갖고 서버에 집어넣으면은 서버 쪽에서
알아서 코드를 빌드를 하면서 에라 가 있으면 알려주고 에라가 없으면
통과시키고 그게 반드시 코드에 제한되는 게 아니라 asset도 그렇게
해서 가는 경우가 있죠 그래서 저희는 그걸 보통 다 통칭해서 빌드
서버라고 해요 그래서 이 빌드 서버에 대한 호러스토리는 상당히 많아요.
왜냐하면 저희가 코드 체크인 할 때 분명히 빼먹고 코드 체크인 하는
경우가 있고 그리고 제가 당장에 체크인 할 수 없는 거를 빼고 나머지
코드만 넣었을 때 이 들어간 코드가 제 코드에 종속관계가 있어가지고
어떻게 에라가 나는 경우도 있고 그래서 그런 거를 확인하기 위해서
빌드를 하는 건 좋은 거죠.
자동화 빌드.
그리고 두 번째가 빌드에 끝나지 말고 빌드는 말 그대로 코드가 제대로
빌드 되고 asset 제대로 빌드 된다는 걸 증명하는 거고 그 외에 테스트
머신을 많이 또 돌리기도 해요.
실제 새로 된 빌드 갖고 가져다가 그거를 테스트를 돌려 게임이 제대로
도는지를 판단해주는 뭐 스모크 테스트라고도 하고 뭐 별별 이름은
있겠지만 그래서 그 두 가지를 보통 많이 하죠 게임 쪽에서.
뭐 아주 영세한 규모의 회사에서는 그러진 않겠지만 어느 정도 규모
가 있는 사람은 분명히 그걸 할 거고 분명히 그거를 보신 사람도
있을 거고 그리고 그거에 대한 토크 도 뭐 gdc나 이런 데서 몇 번이나
나온 적도 있고요.
여러 가지 문제가 있어요 여기에는.
일단은.
가장 큰 문제는 언제나 그거예요 속도가 느리다 일단 c++ 기반의 코드
빌드 시스템은 언어적인 문제 때문에 빌드가 상당히 느리죠.
그리고 이 빌드가 그냥 단순히 디버그 빌드 하나 하는 거면 상관이 없는데
디버그 빌드 만들고 릴리스 빌드 만들고 프로파일 빌드 만들고 패스트
디버그 빌드 만들고 여기서 끝이지 않죠 이거 이제 멀티 플랫폼일 때
pc용 빌드 만들고 엑스박스용 만들고 ps3용 만들고 ps4용 만들고 ps2 만들고
그러면 5 곱하기 5 하면 한 25개 정도 빌드하면.
각 빌드마다 20분이 걸려도 시간이 오래 걸리죠.
그런데 이거를 멀티빌드 기계를 여러 개 둬서 동시에 빌드를 해도 25분
이 걸리죠.
또 하나 문제점은 pc용 빌드 기반 은 굉장히 뛰어난데 콘솔용 빌드
기반은 굉장히 느린 경우가 많아요 .
심지어는 예전 같은 경우에는 pc용 빌드가 뭐 20분이 걸렸다면 어떤
콘솔용 빌드는 1시간 이상이 걸린 적도 있어요.
그래서 이제 또 그거를 해결하기 위해 인크레드 빌드라던가 이런
훌륭한 제품들이 나왔지만 그거는 컴파일 타임만 빨리 해 줄 것뿐
이고.
링크 시간이 다시 20분이 걸린다
이런 문제가 있어요.
그래서 이런 문제가 있었을 때 제가 있던 회사들마다 이거를 처리하는
방법은 다 달랐어요.
그런데 저는 언제나 빌드 서버를 보면 느낄 때마다 빌드 서버는 목적
이 두 개예요.
그러니까 근본적인 목적은 원래 하나예요.
어떤 빌드가 들어가든 간에 그 빌드 가 제대로 된 빌드고 아무 문제가
없는지를 확인하는 게 가장 근본적인 목적이죠.
그런데 여기서 한 가지 문제가 뭐냐면
그 고장난 거를 발견해서
그거를 빨리 고쳐야 되는 것도 사실은 굉장히 중요한 부분이에요.
그래서 그걸 찾기 위해서 빌드 머신 을 돌리는 거고.
그런데 빌드 머신이 단순히 코드 가 아니라 에셋이어도 빌드 하나
하는데 40분이 걸린다.
그러면 어떤 버그가 들어갔을 때 그 버그가 들어갔다는 걸 찾기까지
가 40분이 걸리는 거고요.
그러면 그 버그가 있다는 걸 찾는데 40분이 걸렸을 때 누군가 고쳐갖고
새로 또 뭔가를 집어넣어도 그걸 고쳐갖고 제대로 된 빌드가 나오는데
또 하나가 40분이 나오는 거예요.
그러면 이 중간에 어떻게 더 이상 일을 못하는 경우가 있는 사람도
있어요.
당장 이거를 받아야 되는데 새로운 빌드를 받아야만 일을 할 수 있는데
그 빌드가 고장이 나고 이미 받은 거를 못하고 다시 전에 거로 돌려
야 되고 뭐 이런 엉뚱한 것들.
그 이렇게 빌드가 깨지는 게 40분 에 고쳐지면 다행이지만 40분 내에
고쳐갖고 놓는데 내가 고치는 동안에 또 다른 놈이 계속 체크인을 한
거야.
그럼 걔 거에 또 고장이 났어.
그럼 또 그걸 또 고쳐야 돼.
이런 문제 때문에 솔직히 빌드 서버 에 문제가 생기는.
가장 큰 원인은 저는 언제나 빌드 타임이었어요.
차라리 누가 코드를 넣었을 때 재빨리 그게 고장난 거를 잡을 수 있다면
1분 2분 안에 잡을 수 있다면 그 1 2분 안에 나온 결과를 프로그래머
가 재빨리 보고 고쳐갖고 다시 고친 거를 넣을 수가 있죠.
그러면 뭐 이것저것 해보면 한 10분 안에 모든 일이 고쳐지고 그 10분
안에 누군가 또 나쁜 코드를 넣을 확률은 40분 안에 넣을 확률보다
4분의 1이 작은 거고요.
뭐.
넣고 고치고를 따지면 솔직히 1시간 20분일 수도 있지만 그래서 그런
걸 따졌을 때 저는 빌드 속도가 굉장히 중요한 거라고 보거든요
.
근데 제가 아까 그랬잖아요.
제가 간 회사마다 그 대처 방식 이 달랐다고.
한 군데 회사 나쁜 회사 이 회사는 뭐 어느 회사인지 반드시 말씀드리
지는 않을게요.
근데 이 회사는 아 그 빌드 서버 를 관리하는 그걸 결정을 하는 그
리드 프로그램의 입장이 그거였 어요.
.
그 리드가 들어갈 때마다 그 빌드 가 나올 때마다 모든 플랫폼에 대해
이 빌드가 완벽해야 되고 아 그리고 뭐 인크레멘탈 빌드가 있고 처음부터
는 프레시 빌드가 있잖아요.
인크레멘탈 빌드를 했을 때 프레시 빌드를 해야 되는 상황을 컴파일러
가 제대로 측정을 못 해갖고 문제가 생길 수도 있으니까 언제나 풀빌드
로 가야 되고 언제나 모든 게 맞다 고 확인을 해서 모든 플랫폼이 맞은
경우에만 모든 빌드가 맞다고 통과 를 시켜주겠다는 거예요.
.
그리고 그 통과하는 그 옵션에는 빌드가 잘 됐다는 것뿐만이 아니라
스모크 테스트까지 같이 놓았고 빌드 됐고 게임도 전이랑 상관없이
무사히 돌면은 그게 통과다.
처음에 코드가 작을 때는 문제가 없었죠.
ss이 작을 때도 문제가 없었고 근데 이게 부피가 늘어나면서 제가 사실
이걸 처음부터 제가 이러지 말자 고 얘기를 했었는데 cr도 안 막혔
었죠.
그러다가 마지막에 게임 정말 마무리 할 때쯤 돼서 막 그 팀원 대회가


100명 가고 이랬을 때 그 엄청난 게 막 깨지기 시작하는 거예요
.
빌드 하나 하는데 1시간 20분이 걸려 .
그럼 1시간 20분 동안 사람들 자기 빌드를 넣어놓고 자기가 코드 체크인
ss 체크인 해놓고 1시간 20분을 거기 앉아갖고 기다리면서 빌드가 통과
했나를 볼 만한 그런 집중력이 있는 사람도 없어요 사실은.
오히려 그 사람들한테는 빌드 넣고 3 4분 만에 빌드 딱 나와서 통과
실패를 보여줬을 때 그때 오히려 그래 통과다라고 생각하고 다른
일에 넘어가고 신경을 안 쓰는 게 나은 거지.
어 그래 1시간 걸리니까 다른 일 해야지 그래서 다른 일 하다가 이게
뽀개졌는데도 모르는 게 나은 거지 .
그런 경우가 많죠.
뭐 이메일이 날라오고 안 보는 경우도 있고 그럼 누가 갖고 그냥 고쳐라
그러고.
이게 얼마나 이상한 프로세스가 되는 거예요.
그래서 이 회사의 마음가짐은 그거 였어요.
이 빌드 서버라는 기계가 이 모든 검증이라든가 모든 걸 완벽하게
해서 그거 fwap하지 않는 건 무조건 빠꾸를 시킨다.
근데 여기서 또 하나의 문제가 그거 였어요.
일단 빌드 시간이 플랫폼마다 달랐 고 특정 플랫폼 하나가 굉장히 빌드
시간이 느렸고 그리고 그 스모크 테스트를 돌리는 것도 그 플랫폼
에서 특히 느렸어요.
그래서.
그래서 이 모든 빌드가 끝났어도 그 플랫폼 하나를 기다리면서 빌드
가 기다려야 돼요.
솔직히 다른 빌드는 한 30분 안에 끝났거든요.
근데 나머지 한 50분을 그 빌드가 끝날 때까지 기다려야 되는 거예요
.
그래서 그것 때문에 굉장히 문제가 많았죠.
그래서 제가 이 문제를 다시 한번 제기를 했을 때 그 니드 프로그래머
가 사실은 배경이 자기는 멀티 플랫폼 개발 배경이라고 하는데 마이크로소프트
쪽에서 왔던 사람이기 때문에 엑스박스 밖에 개발한 적이 없는 사람이에요
.
그게 뭐가 문제냐고.
스모크 테스트가 시간이 오래 걸리면.
그냥 엑스박스 데브 킷 엄청 사갖고 한 100개 같이 돌리면 되지 않냐
고.
그 사람 말은 맞아요.
엑스박스 데브 킷은 굉장히 싸 거든요.
그래서 그거는 맞는데 문제는 전혀 ps3 데브 킷이 문제였어요.
ps3 데브 킷은 한 100대 사면 아파트 몇 채 살 거예요.
그 정도로 비싸요.
그래서 그거를 저희가 그렇게 살 그런 것도 없었고 현실적으로 말이
안 되고.
그래서 결과적으로는 그 당시 이제 새로 툴 빌드 서버 툴팀을
해서 이제 담당하던 사람이 또 새로 왔거든요.
그 사람하고 저하고 작당을 해서 결국엔 빌드 서버를 분리를 시켰어요
.
어떻게 분리를 시켰냐면 빌드는 따로 스모크 테스트는 따로 그러니까
빌드가 일단 통과되면은 이 빌드 는 끝났다고 빌드 서버는 마무리를
짓고 그리고 그다음 빌드를 잡아서 빌드 서버가 빌드하기 시작해요
.
그리고 스모크 테스트는 다른 서버 가 가져가서 스모크 테스트를 돌리
고 그래서 이게 페일하면은 나중에 다시 빌드 서버에 가서 이게 페일
했다고 그때 이제 태깅을 해주는 거고.
.
그리고 또 하나 우리가 한 거는 플랫폼을 다 분리시켰어요.
이유는 회사에서 실제 개발용으로 쓰고 있는 플랫폼은 pc가 90%였거든
요.
나머지는 말 그대로 콘솔에서 돌리기 위해서 테스트하기 위해서 쓰는
거였지만 실제 매일매일매일 아티스트 가 쓰는 빌드나 프로그래머가 주로
쓰는 빌드가 90%가 pc였어요.
근데 단순히 ps3하고 엑스박스가 실패했다고 해서 그 빌드를 패스
를 안 시켜줘갖고 개발의 효율성을 저하시키는 게 말이 안 됐죠.
그래서 제가 처음부터 주장했던 방법도 이거였는데 그 당시 그
때 그 빌드 서버를 관장하던 그 리드 프로그래머가 반대를 했던
이유는 그러면 사람들이 엑스박스 나 ps3가 망가졌을 때 신경을 안
쓰고 그냥 그거는 무시한 채 pc만 계속 만든다는 거였거든요.
그래서 어찌보면 저는 물론 그에 대한 해결책도 갖고 있었는데 이
사람이 그걸 이해하지 못했지만 결과적으로는 그게 문제였어요
.
.
.
그래서 이 사람의 마음가짐은 누군가 사람이 와서 뭔가를 해야
될 일이 있는 부분에서 사람을 투입 하기 싫기 때문에 그냥 그거를 기계
한테다 맡겨버리고 기계가 굉장히 까다롭게 그렇게 규칙을 강요하겠다는
거예요.
그래서 문제는 규칙을 강요해서 얻는 이득은 사실은 거의 없었죠
.
언제나 모든 플랫폼이 완벽하게 돈다 절대 그런 일이 없었죠.
언제나 모든 플랫폼이 깨졌죠 계속 .
그래서 결과적으로 마지막에는 그걸 고치긴 고쳤는데 너무 늦었
고 워낙 사람들이 고통을 많이 받고 실제 거기서 100명 되는 직원이 하루에
1시간씩 일 못하면 100시간을 낭비 한 건데 그런 식으로 낭비도 워낙
많았고 이거에 대한 해결법이 제가 있다
그랬잖아요.
이거에 대한 해결법은 솔직히 굉장히 간단해요.
각 플랫폼마다 담당 인원을 한 명 을 만들면 돼요.
예를 들어서 그런 일을 하는 회사 들을 제가 옛날에 봤고요.
그리고 보통 렌더링 프로그래머 들이 그 일을 좀 많이 해요.
.
왜냐하면 뭔가 심하게 뽀개졌을 때 저희는 실제 플랫폼을 열어보고
좀 로우 레벨까지 디버깅 할 수 있는 능력이 있으니까 네트워킹 프로그래머
도 비슷한 능력이 있죠 사실은.
그래서 제가 볼 때는 네트워킹이나 렌더링 프로그래머가 가장 거기에
맞는 사람들이고 어떤 식으로 가야 되냐면 pc를 담당하는 프로그래머
가 하나 있고 ps3를 담당하는 프로그래머 가 하나 있고 xbox3c를 담당하는 프로그래머
가 따로따로 있는 거예요.
예를 들어서 이 사람들은 그걸 다 코딩을 만드는 사람이 아니라
개념성으로 문지기 빌드 문지기 .
.
그래서 빌드가 지나갔는데 ps3가 뽀개졌다고 나왔다.
그럼 제가 ps3 담당이면 들어가서 코드를 열어보는 거예요.
어떤 체인지가 있었나 그래서 뭐가 뭐가 뭐가 해서 이런 문제가 있다
라고 제가 판단이 됐을 때 제가 고칠 수 있으면 고치겠지만 그게
아니라 어떤 사람이 집어넣은 코드 가 그게 문제였다는 걸 제가 발견
을 하는 거죠.
그럼 저는 그 사람한테 가서 이 코드가 지금 문제니까 당장 고치라고
얘기를 하는 거고 여기서 문제가 되는 건 그 사람이 내 말을 안 듣고
안 고친다고 하면 어떻게 할 거냐 .
그 사람이 나보다 훨씬 senior여서 그런 문제가 있는데 그거는 말 그대로
팀 안에서 제일 윗사람이나 리드 들이 우선순위를 확실히 정해주면
되는 거예요.
만약에 얘가 얘는 심지어 좀 junior고 intermediate이지만 너한테 와서 빌드
가 깨졌다.
그러면 너는 반드시 그걸 먼저 고쳐야 된다.
라는 그런 강한 규칙을 적용하면 되는 거고 그 규칙에 따르면 당연히
훨씬 더 빠른 거죠.
사람들 개발하는 거 멈추지도 않고 어떤 플랫폼이 고개났을 때 이거는
곧바로 또 고치려고 할 거고 그리고 그 플랫폼을 당장 고칠 수 없는 일
이어도 그 플랫폼 하나 못 쓰는 거니까 그런 장점이 있죠.
근데 또 하나의 여기서 단점이라고 그 전에 리드가 봤던 거는 이거는
어떻게 보면 누구를 이제 blame하는 게임이 될 수 있다는 그런 거였던
거 같아요.
그러니까 저는 언제나 빌드 깨지는 걸 짜증내 할 거고 보면 이거 고장
냈으니까 고쳐주세요.
라고 말하는 거 자체를 사람들이 좋게 안 받아들일 수 있다는 그런
거기도 한데 저는 그게 무슨 상관 인가 싶어요.
어차피 기계가 자동으로 알아내서 이메일 보내왔고 고장 냈습니다.
라고 하면은 어차피 그거는 모든 게 뭐 이메일로 자료가 남으니까
그게 오히려 더 쪽팔리지 않나 차라리 그냥 빌드 문제기가 가서 아 저 이거
고장 난대요.
남들 알기 전에 빨리 고쳐주세요 라는 게 훨씬 그 사람의 자존심
을 지키는데 훨씬 도움이 되는 게 아닌가라는 생각이 들고 어찌보면
은 그냥 그런 나쁜 소리를 하기 싫은 사람이었기 때문에 그냥 기계에
의존하려고 했던 거 같아요.
그래서 기계 만능화 자동 만능화 쪽으로 가려고 했던 거 같고요.
실제 빌드 머신의 목적이 있지만 그 목적 1차 목적이 있죠 빌드를
verification하는 그 목적이 과연 2차 목적이 뭐냐 이 빌드를 빨리 고치고
사람들이 언제라도 시간이 다운되지 않고 일할 수 있게 해야 된다는
그 목적 자체를 보지 못하는 단점 일 수도 있어요.
아니면 오히려 엔지니어의 입장 에서 그냥 아 기계가 이런 이런
일을 할 수 있고 자동으로 다 처리 해 주고 솔직히 굉장히 익사이링
하잖아요.
내가 귀찮게 하나다 코드 열어볼 필요 없고 그래서 그런 기계 만능
화를 해서 자기 삶을 좀 편하게 하려고 했으나 오히려 그로 인해
팀 전체의 효율성을 굉장히 무너 트리는 그런 경우였다고 보거든요
.
그래서 제가 하고 싶은 말은 기계 만능화를 너무 믿지 마세요.
기계는 굉장히 좋은 거고 기계가 자동으로 해주는 건 굉장히 좋아요
.
근데 거기에다가 적당히 사람의 판단력과 사람의 그런 터치 그런
게 포함이 될 때 훨씬 일도 효율적 이고 일도 빨라진다는 거를 좀 알아
야 할 거 같아요.
그래서 혹시라도 뭐 이런 뭐 빌드 자동화 머신이라든가 이런 걸 만드시는
분들 특히 큰 회사에서 그런 부분을 생각해 보세요.
아무리 자동화가 열심히 잘 돼 봐야 오히려 개발이 힘들어지는 경우가
상당히 많아요.
뭐 대표적인 예로 이제 제가 예전 에도 한 번 얘기했듯이 무슨 코딩
스타일 자동화 자동으로 판단해 주기 뭐 이런 플러그인도 있거든요
.
제가 최근에는 씨샵 쪽을 하면서 이제 뭐 씨샤퍼라는 거 이런 것도
좀 봤는데 그래서 거기서 제공하는 뭐 이런 이런 뭐라 그래 어드바이스
.
그러니까 이렇게 고쳐라 코드를 그러면 고치고 싶으면 버튼 하나
누르면 다 고쳐주는 굉장히 많은 사람들이 그렇게 그냥 쓸 것 같
다는 생각은 해요.
근데 그런 어드바이스로 나오는 코드 중에 상당히 코드 가독성을
떨어뜨리고 버그를 만드는 거를 굉장히 쉽게 해주는 그런 것도 많이
봤어요.
그게 이제 링크 쪽에서 좀 문제가 많이 생기는데 워낙에 링크를 많이
쓰라고 이제 씨샵에선 하지만 실제 제가 링크를 봤을 때 링크의 디폴트
비에이비어.
그러니까 기본적인 그 동작 방식 에서.
네.
왜냐하면 이 동작이 우리 팀에 있는 부분이 좀 있어요.
거기에 씨샵을 내 속을 완벽히 알고 그런 프로그램은 상관없지만 코드
가독성이 중요한 이유는 초창기 프로그래머만 이 팀에 있는 게 아니라
실제 그 정도 수준까지 아직 덜 올라갔거나 아니면 평생 안 올라
갔거나 하는 사람까지도 같이 코딩 을 하고 협업을 해야 되기 때문에
그런 사람들까지 같이 실수를 안 만들고 코드에서 버그를 줄이기
위해서는 가독성이 되게 중요한 거거든요.
제가 말하는 가독성은 말 그대로.
무슨 뭐.
뭐 변수림이 잘 되어있느냐를 떠나서
코드를 읽었을 때 이 코드가 내부적으로 어떤 일을 하는지까지
한 번에 알 수 있는 그런 코드가 중요하다고 봐요
근데 이제 그런 자동화를 통해서 그런 코드가 오히려 더 망가지는 경우도 봤고
그리고 뭐 요즘 이렇게 뭐 타입 출원하는 거 많잖아요
Auto라든가 Var라든가 C#에선 Var고 C+에선 Auto고
타이핑 줄여지고 굉장히 장점도 많지만
그걸 남용하다 보면은 오히려 코드만 읽어서 그냥
아 이건 Boolean이구나 이건 이거겠구나 라고 알 수 있는 것까지
오히려 너무 추상화를 시키는 단점도 있어요
그래서 제가 요즘 코드 자동 컴플리트 기능을 보면서 걱정이 되는 건
그런 부분이 좀 걱정이 돼요
거기에서 오는 장점도 있지만 오히려 코드 가독성을 줄이는 경우도 많다는
그런 경우가 있어서 그거에 대한 비디오는 아마 나중에 만들 거고
제가 오늘 드리고 싶은 말씀은 그거예요
자동화 물론 좋지만 자동화를 통해서 이룰 수 있는 게 정말 근본적인 목적이 뭐고
그 목적을 이루기 위해서 정말 자동화만이 길인지 아니면
자동화하고 사람의 손길을 적당히
섞는 게 중요한지를 판단해 주시는 게 좋을 것 같아요
그래서 엔지니어들이 흔히 빠질 수 있는 그런 흔히 저지를 수 있는 실수
그거라고 말씀을 드리고
이 정도에서 오늘 퍼프TV는 끝낼게요
퍼프였습니다
