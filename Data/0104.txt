안녕하세요. 포프입니다. 요즘은 참 세상이 재밌어지고 있는 것 같아요. 기계들이 되게 발전하고 인공지능, 로봇 이런 게 발전하면서 굉장히 모든 것이 자동화가 되고 인간의 삶을 편하게 하는 그런 세상이 왔죠. 그리고 이제 한 10년, 20년 있으면 그 기계의 인공지능이 워낙 발달해서 이제 그 사람들이 이제 지구를 정복하고, 그래서 저희가 이제 로봇을 섬기는 몸종이 되는 그런 즐거운 나날이 올 건데, 여기까지 농담이고요. 사실 그런 공포는 언제나 있었지만 제가 볼 때 그 정도로 인공지능이 발전하기 좀 어려울 것 같고요.

제가 하고 싶은 얘기는 사실 그거예요. 저희는 엔지니어잖아요? 그리고 저는 엔지니어예요. 보시는 분들 다는 아니겠지만 엔지니어의 단점 중에 하나는, 저희는 굉장히 뭔가 논리적인 걸 좋아하고 기계로서 상당히 많은 일을 해결할 수 있을 거라고 생각해요. 뭐 저만 그런가? 아닐 거라고 믿고요. 그렇기 때문에 어떤 거에서 자동화가 되고 있고, 그걸로 인해 저희 그 힘든 그런 반복 작업 뭐 이렇게 세세한 그런 귀찮은 일들을 고칠 수가 있다면 저희는 그걸 언제나 하고 싶어 하죠. 그리고 그런 거에 가장 먼저 익사이팅하는 사람들이기도 하고, 그런 거를 가장 먼저 접목하고 받아들이는 사람들이기도 하죠.

그래도 저도 집에 일단 마누라봇이 하나 있고요. 마누라봇이라고 해봐야 로봇청소기 그게 하나 있고요. 그리고 이제는 심지어는 그 바닥 닦는 청소기까지 살 거라고 고민을 하고 있는데, 여러 가지 홈 자동화 봇도 그렇고요. 제가 지금 하려는 말은, 그런 자기 꾐에 빠져서 오히려 인생을 귀찮게 하지 말라는 거예요. 그러는 경우가 실제 게임 업계에서 너무나 자주 일어나고 있고요. 저도 몇 번이나 겪었고, 그래서 제가 그런 예를 한번 들어드릴게요.

오늘 하고 싶은 말은 결국은 그거예요. 자동화 좋고, 기계 만능주의도 좋지만, 결국에는 어느 순간에는 그 기계 만능주의 때문에 오히려 사람이 피곤해지는 경우가 있어요. 적당한 자동화와 사람의 손길을 딱 접목을 시켜야 새로운 인류가 탄생.. 아니 그 새로운.. 굉장히 괜찮은 시스템이 탄생하면서 그게 오히려 효율성에 도움이 된다는 거죠. 게임 쪽에서 일하시는 분들이고, C++ 쪽으로 코딩을 많이 짜보신 분들은 아마 빌드 서버를 다 알고 계실 거예요.

이제 저희가 코드를 보통 짜서 서버에 집어넣으면, 서버 쪽에서 알아서 코드를 빌드를 하면서 에러가 있으면 알려주고, 에러가 없으면 통과시키고, 그게 반드시 코드에 제한되는 게 아니라 애셋도 그렇게 해서 가는 경우가 있죠. 그래서 저희는 그걸 보통 다 통칭해서 빌드 서버라고 해요. 그래서 이 빌드 서버에 대한 호러 스토리는 상당히 많아요. 빌드 서버가 필요 없다는 얘기는 아니에요. 반드시 필요하죠. 왜냐면 저희가 코드 체크인 할 때 분명히 빼먹고 코드 체크인 하는 경우가 있고요. 그리고 제가 당장에 체크인할 수 없는 거를 빼고, 나머지 코드만 넣었을 때 이 들어간 코드가 제 코드에 종속 관계가 있어서 뭐 어떻게 에러가 나는 경우도 있죠. 그래서 그런 거를 확인하기 위해서 자동화 빌드를 하는 건 좋은 거죠.

그리고 두 번째가 빌드에서 끝나지 않고, 빌드는 말 그대로 코드가 제대로 빌드되고 애셋이 제대로 빌드된다는 걸 증명하는 거죠. 그 외 테스트 머신을 많이 돌리기도 해요. 그 실제 새로 된 빌드를 가져다가 그걸 테스트를 돌려서 게임을 제대로 도는지를 판단해 주는, 별별 이름은 있겠지만 스모크 테스트라고도 하죠?

그래서 저 두 가지를 보통 많이 하죠. 게임 쪽에서는 뭐 아주 영세한 규모의 회사에서는 그러진 않겠지만, 어느 정도 규모가 있는 사람은 분명히 그걸 할 거고, 분명히 그거를 보시는 사람도 있을 거예요. 그리고 그거에 대한 토크도 GDC나 이런 데서 몇 번이나 나온 적도 있고요.

여러 가지 문제가 있어요. 그러나 일단 가장 큰 문제는 언제나 그거예요. 속도가 느리다. 일단 C++ 기반의 코드 빌드 시스템은 언어적인 문제 때문에 빌드가 상당히 느리죠. 그리고 이 빌드가 그냥 단순히 디버그 빌드 하나 하는 거면 상관이 없는데, 디버그 빌드 만들고, 릴리스 빌드 만들고, 프로파일 빌드 만들고, 패스트 디버그 빌드 만들고, 여기서 끝이 아니죠? 멀티 플랫폼일 때 PC용 빌드 만들고, 엑스박스용 만들고, PS3용 만들고, PS4용 만들고, PS2 만들죠. 그러면 5 곱하기 5 하면, 25개 정도 빌드하면 각 빌드마다 20분이 걸려도 시간이 오래 걸리죠. 그런데 이거를 멀티 빌드, 그러니까 기계를 여러 개 둬서 동시에 빌드를 해도 25분이 걸리죠?

또 하나 문제점은 PC용 빌드 기반은 굉장히 뛰어난데, 콘솔용 빌드 기반은 굉장히 느린 경우가 많아요. 심지어는 예전 같은 경우에는 PC용 빌드가 뭐 20분이 걸렸다면, 어떤 콘솔용 빌드는 1시간 이상이 걸린 적도 있어요. 그래서 이제 또 그거를 해결하기 위해 Incredibuild라던가 이런 훌륭한 제품들이 나왔지만, 그건 컴파일 타임만 빨리 해주실 것뿐이고요. 링크 시간이 다시 20분이 걸린다던가 이런 문제가 있어요.

그래서 이런 문제가 있었을 때 제가 있던 회사들마다 이거를 처리하는 방법은 다 달랐어요. 근데 저는 언제나 빌드 서버를 보면 느낄 때마다 빌드 서버는 목적이 두 개예요. 아니 그러니까 근본적인 목적은 원래 하나예요. 어떤 빌드가 들어가든 간에 그 빌드가 제대로 된 빌드고, 아무 문제가 없는지를 확인하기 가장 근본적인 목적이죠. 근데 여기서 한 가지 문제가 뭐냐면, 그 고장 난 거를 발견했을 때 빨리 고쳐야 하는 것도 사실은 굉장히 중요한 부분이에요. 그래서 그걸 찾기 위해서 빌드 머신을 돌리는 거니까요. 근데 빌드 머신이 뭐 단순히 코드가 아니라 에셋이어도 빌드 하나 하는데 40분이 걸린다면, 어떤 버그가 들어갔을 때 그 버그가 들어갔다는 걸 찾기까지가 40분이 걸리는 거고요. 그러면 그 버그가 있다는 걸 찾는데 40분이 걸렸을 때, 누군가 고쳐서 새로 뭔가를 집어넣어도, 고친 버전으로 제대로 된 빌드가 나오는데 또 하나 40분이 더 걸리는 거예요. 그러면 이 중간에 어떻게 더 이상 일을 못하는 경우가 있는 사람들도 있어요. 당장 이거를 받아야 하고 새로운 빌드를 받아야만 일을 할 수 있는데, 그 빌드가 고장이 나서 이미 받은 거를 못하고 다시 전에 거로 돌려야 되고 뭐 이런 엉뚱한 것들이요. 그렇게 빌드가 깨지는 게 40분에 고쳐지면 다행이지만 40분 내에 고쳐서 놓는데 내가 고치는 동안에 또 다른 사람이 이 계속 체크인을 한 거야. 그럼 그 사람 거에 또 고장이 났다면 그럼 또 그걸 고쳐야 돼요.

이런 문제 때문에 솔직히 빌드 서버에 문제가 생기는 가장 큰 원인은 저는 언제나 빌드 타임이었어요. 차라리 누가 코드를 놓을 때 재빨리 1~2분 안에 잡을 수 있다면, 그 1~2분 안에 나온 결과를 프로그래머가 재빨리 보고 고쳐서 다시 고친 사항을 넣을 수가 있죠. 그러면 뭐 이것저것 해보면 한 10분 안에 모든 일이 고쳐지고요. 그 10분 안에 누군가 또 나쁜 코드를 넣을 확률은, 40분 안에 넣을 확률보다 4분의 1이 작은 거고요. 이것저것 넣고 고치고 따지면 솔직히 1시간 20분일 수도 있지만요. 그래서 그런 거를 따졌을 때 저는 빌드 속도가 굉장히 중요한 거라고 보거든요.

근데 제가 아까 그랬잖아요. 제가 간 회사마다 그 대처 방식이 달랐다고요. 이 회사가 어느 회사인지 반드시 말씀드리진 않을게요. 근데 이 회사는 그 빌드 서버를 관리하고 결정하는 그 리드 프로그래머의 입장이 그거였어요. 언제나 모든 빌드가 들어갈 때마다, 빌드가 나올 때마다 모든 플랫폼에 대해 이 빌드가 완벽해야 한대요. incremental 빌드가 있고, 처음부터는 fresh 빌드가 있잖아요. incremental 빌드로 했을 때, fresh 빌드를 해야 되는 상황을 컴파일러가 제대로 측정을 못 해서 문제가 생길 수 있으니까 언제나 full 빌드로 가야 한다는 거예요. 언제나 모든 게 맞다고 확인을 해서 모든 플랫폼이 맞은 경우에만 모든 빌드가 맞다고 통과를 시켜주겠다는 거예요. 그리고 그 통과하는 그 옵션에는, 빌드가 잘 됐다는 것뿐만이 아니라 smoke 테스트까지 같이 넣어서 빌드 됐고 게임도 전이랑 상관없이 무사히 돌면은 그게 통과라는 거죠.

처음에 코드가 작을 때는 문제가 없었죠. 애셋이 작을 때도 문제가 없었고요. 근데 이게 크기가 커지는 걸 보면서, 제가 이걸 처음부터 제가 이러지 말자고 얘기를 했었는데 씨알도 안 먹혔었죠. 그러다가 마지막에 게임이 정말 마무리할 때쯤 돼서, 팀원들 100명 넘어가고 이랬을 때 그 엄청난 게 마구 깨지기 시작하는 거예요. 빌드 하나 하는데 1시간 20분이 걸려요. 그럼 1시간 20분 동안 사람들이 자기 빌드를 넣어놓고 자기가 코드 체크인 해놓고 1시간 20분을 거기 앉아서 기다리면서 빌드가 통과했나를 보는 그런 집중력이 있는 사람도 사실은 없었어요. 오히려 그 사람들한테는 빌드 3-4분 만에 결과를 통과 또는 실패를 보여줬을 때, 오히려 통과다라고 생각하고 다른 일로 넘어가고 신경을 안 쓰는 게 나온 거죠. 그런데 1시간이나 넘게 걸리니까 다른 일 해야지 그래서 다른 일 하다가 이게 빠개졌는데도 모르는 경우가 많죠. 뭐 그걸 이메일이 와도 안 보는 경우도 있고요. 그럼 누가 와서 또 고쳐라 그러고 하죠. 이게 얼마나 이상한 프로세스가 되는 거예요.

그래서 이 회사의 마음가짐은 그거였어요. 이 빌드 서버라는 기기가 이 모든 검증이라든가 모든 걸 완벽하게 해서 그거에 부합하지 않으면 그거에 부합하지 않는 건 무조건 빠꾸를 시키는 거죠. 근데 여기서 또 하나의 문제가 그거였어요. 일단 빌드 시간이 플랫폼 하나 달랐고, 특정 플랫폼 하나가 굉장히 빌드 시간이 느렸고, 그리고 그 스모크 테스트를 돌리는 것도 그 플랫폼에서 특히 느렸어요. 그래서 이 모든 빌드가 끝났어도 그 플랫폼 하나를 기다리면서 빌드가 기다려야 돼요. 솔직히 다른 빌드는 한 30분 안에 끝났거든요. 근데 나머지 한 50분을 그 빌드가 끝날 때까지 기다려야 되는 거예요. 그래서 그것 때문에 굉장히 문제가 많았죠. 그래서 제가 이 문제를 다시 한번 제기를 했을 때, 그 리드 프로그래머가 사실은 배경이 자신은 멀티 플랫폼 개발 배경이라고 하는데, 마이크로소프트 쪽에서 왔던 사람이기 때문에 엑스박스 밖에 개발한 적이 없는 사람이에요.

"그게 뭐가 문제냐, 스모크 테스트가 시간이 오래 걸리면 그냥 엑스박스 데브킷 왕창 사 갖고 한 100개 같이 돌리면 되지 않냐"라고 말했죠. 그 사람 말은 맞아요. 엑스박스 데브킷은 굉장히 싸거든요. 그래서 그거는 맞는데요. 문제는 저는 PS3 데브킷이 문제였어요. PS3 데브킷은 한 100대 사면 아파트 몇 차 살 거예요. 그 정도로 비싸요. 그래서 그거를 저희가 그렇게 살 여건도 없었고 현실적으로 말이 안 되고요. 그래서 결과적으로는 그 당시 이제 빌드 서버 툴팀을 이제 담당하던 사람이 또 새로 왔거든요? 그 사람하고 저하고 작당을 해서 결국엔 빌드 서버를 분리시켰어요. 어떻게 분리시켰냐면 빌드는 따로, 스모크 테스트는 따로 하도록요. 그러니까 빌드가 일단 통과되면, 이 빌드는 끝났다고 빌드 서버는 마무리를 짓고요. 그리고 그다음 빌드를 잡아서 빌드하기 시작해요. 그리고 스모크 테스트는 다른 서버가 가져가서 스모크 테스트 돌리고, 이게 Fail 하면 나중에 다시 빌드 서버에 가고 이게 Fail 했다고 그때 이제 태깅을 해주는 거죠.

그리고 또 하나 우리가 한 건 플랫폼을 다 분리시켰어요. 이유는 회사에서 실제 개발 용어를 쓰고 있는 플랫폼은 PC가 90%였거든요. 나머지는 말 그대로 콘솔에서 돌리기 위해서 테스트하기 위해서 쓰는 거였지만, 실제 매일 아티스트가 쓰는 빌드나 프로그래머가 주로 쓰는 빌드가 90%가 PC였어요. 근데 단순히 PS3하고 엑스박스가 실패했다고 해서, 그 빌드를 패스를 안 시켜줘서 개발의 효율성을 저하시키는 게 말이 안 됐죠. 

그래서 제가 처음부터 주장했던 방법도 이거였는데요. 그 당시 그때 빌드 서버를 관장하던 그 리드 프로그래머가 반대를 했던 이유는, "그러면 사람들이 엑스박스나 PS3가 망가졌을 때 신경을 안 쓰고 그냥 그거는 무시한 채 PC만 계속 만든다"는 거였거든요. 저는 물론 그에 대한 해결책도 갖고 있었는데 이 사람이 그걸 이해하지 못했지만 결과적으로 그게 문제였어요. 이 사람이 마음가짐은 누군가 사람이 와서 뭔가를 해야 될 일이 있는 부분에서 사람을 투입하기 싫으니까 그거를 기계한테 맡겨버리고, 기계가 굉장히 까다롭게 그렇게 규칙을 강요하겠다는 거예요.

그러나 문제는 규칙을 강요해서 얻는 이득은 사실은 거의 없었죠. 언제나 모든 플랫폼이 완벽하게 돈다? 절대 그런 일이 없었죠. 언제나 모든 플랫폼이 계속 깨졌죠. 그래서 결과적으로 마지막에는 그걸 고치긴 고쳤는데 너무 늦었고요. 워낙 사람들이 고통을 많이 받고 실제 거기서 100명 되는 직원이 뭐 하루에 1시간씩 일 못하면 그게 뭐 100시간 낭비한 건데, 그런 식으로 낭비도 워낙 많았고요. 이거에 대한 해결법에 제가 있다고 그랬잖아요. 솔직히 굉장히 간단해요. 각 플랫폼마다 담당 인원 한 명을 만들면 돼요. 

그런 일을 하는 회사들을 제가 옛날에 봤고요. 그리고 보통 렌더링 프로그래머들이 그 일을 좀 많이 해요. 왜냐하면 뭔가 심하게 빠개졌을 때 저희는 실제 플랫폼을 열어보고, 로우 레벨까지 디버깅할 수 있는 그 능력이 있으니까요. 사실 네트워킹 프로그래머도 비슷한 능력이 있죠. 그래서 제가 볼 때는, 네트워킹이나 렌더링 프로그래머가 가장 거기에 맞는 사람들이고요.

어떤 식으로 가야 되냐면, PC를 담당하는 프로그래머가 하나 있고, PS3를 담당하는 프로그래머가 하나 있고, 엑스박스 애셋을 담당하는 프로그래머가 따로따로 있는 거예요. 예를 들어서 이 사람들은 그걸 다 코딩을 만드는 사람이 아니라 개념상으로 문지기, 빌드 문지기죠. 그래서 빌드가 지나갔는데 PS3가 빠개졌다고 나왔다면, 제가 PS3 담당이면 들어가서 코드를 열어보는 거예요. 어떤 체인지가 있었나. 그래서 어떤 원인으로 이런 문제가 있다고 판단이 됐을 때, 제가 고칠 수 있으면 고치겠지만, 그게 아니라 어떤 사람이 집어넣은 코드가 그게 문제였다는 걸 제가 발견하는 거죠.

그럼 저는 그 사람한테 가서 이 코드가 지금 문제니까 당장 고쳐라고 얘기를 하는 거고요. 여기서 문제가 되는 건, 그 사람이 내 말을 안 듣고 안 고친다고 하면 어떻게 할 거냐는 거죠. 그 사람이 나보다 훨씬 시니어여서 그런 문제가 있는데, 그거는 말 그대로 팀 안에서 제일 윗사람이나 리드들이 그걸 우선순위를 확실히 정해주면 되는 거예요. 심지어 좀 주니어고 인터미디어이지만 너한테 와서 "빌드가 깨졌다" 그러면 "너는 반드시 그걸 먼저 고쳐야 된다"라는 그런 강한 규칙을 적용하면 되는 거죠. 그 규칙에 따르면은 당연히 훨씬 더 빠른 거죠.

사람들 개발하는 거 멈추지 않고, 어떤 플랫폼이 고장 났을 때 이거는 곧바로 또 고치려고 할 거고요. 그리고 그 플랫폼을 당장 고칠 수 없는 일이어도, 그 플랫폼 하나 못 쓰는 거니까 그런 장점이 있죠. 근데 또 하나의 여기서 단점이라고 하면, 그전에 리드가 봤던 거는 어떻게 보면 누구 한 명을 블레임 하는 게임이 될 수 있다는 그런 거였던 거 같아요.

그러니까 저는 언제나 빌드 깨지는 거를 짜증 내 할 거고 보면은 이거 고장 났으니까 고쳐주세요라고 말하는 거 자체를 사람들이 좋게 안 받아들일 수 있다는 그런 거기도 한데요, 저는 그게 무슨 상관인가 싶어요. 어차피 기계가 자동으로 알아내서 이메일 보내와서 고장 냈습니다라고 하면은 어차피 그거는 모든 게 뭐 이메일로 자료가 남으니까 그게 오히려 더 쪽팔리지 않을까요? 차라리 그냥 빌드 문제기가 가서 "이거 고장 났대요. 남들 알기 전에 빨리 고쳐주세요"라고 하는 게 그 사람의 자존심을 지키는데 훨씬 도움이 되는 게 아닌가 하는 생각이 들고요.

어찌 보면은 그냥 그런 나쁜 소리를 하기 싫은 사람이었기 때문에, 그냥 기계에 의존하려고 했던 거 같아요. 그래서 기계 만능화, 자동 만능화 쪽으로 가려고 했던 거 같고요. 실제 빌드 머신의 목적이 있지만, 1차 목적인 빌드를 베리피케이션이 있죠. 이 빌드를 빨리 고치고 사람들이 언제라도 시간이 다운되지 않고 일할 수 있게 해야 된다는 그 목적 자체를 보지 못한 단점일 수도 있어요. 아니면 오히려 엔지니어의 입장에서, 그냥 아 기계가 이런 일을 할 수 있고 자동으로 다 처리해 주고 솔직히 굉장히 exciting 하잖아요. 내가 귀찮게 하나 코드 열어볼 필요 없으니까요. 그래서 그런 기계 만능화를 해서 자기 삶을 좀 편하게 하려고 했으나, 오히려 그로 인해 팀 전체의 효율성을 굉장히 무너뜨린 그런 경우였다고 보거든요.

그래서 제가 하고 싶은 말은, 기계 만능화를 너무 믿지 마세요. 기계는 굉장히 좋은 거고, 기계가 자동으로 해주는 건 굉장히 좋아요. 근데 거기에다가 적당히 사람의 판단력과 사람의 그런 터치가 포함이 될 때 훨씬 일도 효율적이고, 일도 빨라진다는 거를 좀 알아야 할 것 같아요. 혹시라도 뭐 이런 뭐 빌드 자동화 머신이라던가 이런 걸 만드시는 분이 계시면 특히 큰 회사에서 그런 부분을 생각해 보세요. 아무리 자동화가 열심히 잘 돼 봐야 오히려 개발이 힘들어지는 경우가 상당히 많아요. 대표적인 예로 이제 제가 예전에도 한번 얘기했듯이, 무슨 코딩 스타일 자동화 자동으로 판단해 주기 뭐 이런 플러그인도 있거든요. 제가 최근에는 C# 쪽을 하면서 이런 것도 좀 봤어요. 그래서 거기서 제공하는 어드바이스들이 "코드를 이렇게 고쳐라" 그러면, 버튼 하나만 누르면 다 고쳐주는 굉장히 많은 사람들이 그렇게 그냥 쓸 것 같다는 생각을 해요. 근데 그런 어드바이스로 나오는 코드 중에 상당히 코드 가독성을 떨어뜨리고, 버그를 만드는 거를 굉장히 쉽게 해주는 그런 것도 많이 봤어요. 대표적으로 링크 쪽에서 좀 문제가 많이 생기는데, 워낙 링크를 많이 쓰라고 C#에서는 말하거든요. 실제 제가 링크를 봤을 때 링크의 default behavior, 그러니까 기본적인 그 동작 방식에서 문제가 있는 부분이 좀 있어요. C#의 속을 완벽히 아는 프로그래머는 상관이 없지만요, 코드 가독성이 중요한 이유는 초천재 프로그래머만이 팀에 있는 게 아니라, 실제 그 정도 수준까지 아직 덜 올라갔거나 아니면 평생 안 올라갔거나 하는 사람까지도 같이 코딩을 하고 협업을 해야 되기 때문이에요. 그런 사람들까지 같이 실수를 안 만들고 코드에서 버그를 줄이기 위해선 가독성이 되게 중요한 거거든요.

제가 말하는 가독성은 말 그대로 무슨 변수이름이 잘 돼있느냐를 떠나서 코드를 읽었을 때, 이 코드가 내부적으로 어떤 일을 하는지 한 번에 알 수 있는 그런 코드가 중요하다고 봐요. 근데 이제 그런 자동화를 통해서 그런 코드가 오히려 더 망가지는 경우도 봤고요. 그럼 요즘 이렇게 뭐 타입 추론하는 거 많잖아요. C#에서 var, C++는 auto 이런 거요. 타이핑 줄여지고 굉장히 장점도 많지만, 그걸 남용하다 보면은 오히려 코드만 읽었을 때 그냥 '아 이건 Boolean이구나, 이건 이거겠구나'라고 알 수 있는 것까지 오히려 너무 추상화를 시키는 단점도 있어요. 그래서 제가 요즘 코드 자동 컴플리트 기능을 보면서 그런 부분이 좀 걱정이 돼요. 거기에서 오는 장점도 있지만, 오히려 코드 가독성을 줄이는 경우도 많다는 그런 경우가 있어서요.

그거에 대한 비디오는 아마 나중에 만들 거고요. 제가 오늘 드리고 싶은 말씀은 그거예요. 자동화 물론 좋지만 자동화를 통해서 이룰 수 있는 게 정말 근본적인 목적이 뭐고, 그 목적을 이루기 위해서 정말 자동화만이 길인지, 아니면 자동화하고 사람의 손길에 적당히 섞는 게 중요한지를 판단해 주시는 게 좋을 것 같아요. 그래서 엔지니어들이 흔히 빠질 수 있는 그런 흔히 저지를 수 있는 실수 그거라고 말씀을 드리고요. 이 정도에서 오늘 포프 TV는 끝낼게요. 포프였습니다.