예 안녕하세요 포피입니다
최근에 제가 또 어떤 게임들을 최적화를 해준 적이 있어요
특히 콘솔 쪽 최적화를 많이 해줬는데
이 콘솔 최적화를 하다보면 저희가 흔히 아무 생각도 안 하던
PC에서는 그냥 보통 빠르니까 요즘은 PC가 더 빠르잖아요
생각 안 하던 것들을 생각해야 될 경우들이 있어요
그런 게 바로 아무 생각 없이 사용하는 함수 하나
이게 가끔은 엄청 느릴 때가 있거든
워낙 많이 호출이 돼서
최근에 봤던 그런 함수 중에 하나는 맴카피였어요
맴카피 C++ 사용하시는 분들이면 아무 생각 없이 사용하죠
변수 하나하나 대입하는 것보다 맴카피가 빠르니까
맴카피 호출하자 어디든 사용할 수 있잖아
이런 생각을 하세요
그러나 맴카피도 사실은 PC에서도 그렇고
특히 특정한 콘솔에서도 그렇고
어떤 규칙에 따라 어떤 제약이 들어가면
훨씬 빠르게 돌 수 있는 경우들이 있어요
그거를 좀 잘 생각을 하면
좀 엉뚱한 짓을 덜 할 수가 있죠
그런 게 뭐냐면 첫 번째는 특정 콘솔에 가면
맴카피를 호출하는 순간 대부분 맴무브 함수로 바꿔서
알아서 컴파일되는 경우들이 있어요
그건 그 콘솔에서는 맴무브가 일반적으로 맴카피보다 빠르다
이런 경우일 수도 있고
그건 여러 가지가 있는데
그런 부분은 프로그래머가 신경 써야 할 이유는 보통은 없어요
그리고 두 번째는 또 뭐냐면 맴카피를 할 때
이 맴카피를 시작하는 주소
그 주소가 어떤 바이트 단위
4바이트 단위든 16바이트 단위든
심지어는 64킬로바이트 단위든
어떤 바이트 단위로 정렬이 되어 있을 때
속도가 엄청 빠른 컴파일을 하는 경우들도 있습니다
그거는 컴파일 중에 알 수 있으면 그렇고
알지 못하면 그 안에 if else가 들어가서
그게 4바이트 단위면 빠른 거 호출하고
아닌 거 호출하고 이렇게 갈 수도 있지만
결과적으로는 그런 것 따라 또 빨라지는 경우들이 있어요
두 번째 경우는
역시 콘솔 기계에 따라
하드웨어에 따라 다를 수 있지만
그 내부 구조에 따라 다르거든요
하지만 내가 메모리를 할당할 때
뭐 c나 c++ 코딩을 할 때 할당을 할 때
이거는 메모리 카피가 많이 일어나는 거면
기본적으로 메모리가 4바이트 단위든 16바이트 단위든
정렬을 되게 해주는 게
그냥 알아서 속도가 빨라지는 경우들이 있어요
물론 메모리가 워낙 없는 플랫폼이면 그게 문제가 되겠지만
요즘 플랫폼들은 보통 메모리가 충분하죠
그래서 그런 거 생각하시면
두 번째 거
프로그래머가 할 수 있는 건
메모리 할당할 때 특정 바이트 단위로
얼라인 하는 거 좀 더 고민하는 방법들이 있죠
세 번째는 이건 약간은 블랙매직일 수도 있고
아닐 수도 있는데
요거는 제가 요번에 췌적하면서
굉장히 많이 봤던 문제였어요
뭐냐면은
맴 카피는 범용적인 함수예요
4바이트를 카피할 수도 있고
16바이트를 카피할 수도 있고
5천 킬로바이트를 카피할 수도 있죠
자 그러면 과연 맴 카피가 빠르냐
아니면은 바이트를 하나씩 하나씩 대입하는 게 빠르냐
이런 문제가 있을 수가 있어요
그럼 바이트 하나씩 대입하는 건 대부분 느려요
그러나 30비트 머신
아니면 64비트 머신에서 4바이트씩 대입하는 게
4바이트를 맴 카피하는 것보다 빠를까?
그러면 보통 빠릅니다
그리고 특정한 바이트 크기까지는
실제 그런 4문을 돌려서 하든
아니면은 뭐 4문 돌리는 것처럼
컴파일 최적화되면서 알아서 또
그냥 언룹을 해주거든요
그래서 결과적으로는 바이트 단위로
뭐 몇 개를 복사해 주든
4바이트 단위든 16바이트 단위든
아니면 맴 카피라든 그 둘 중에 하나인데
특정 바이트 크기까지는
요즘 컴퓨터들
데스크탑 컴퓨터들이나 콘솔 같은 경우는
직접 바이트 단위가 아니죠
어떤 뭐 워드 단위라고 할게요
워드 단위로 대입을 해주는 게 훨씬 빠릅니다
근데 이런 거는 이게 벡터라이제이션이라고 보통 해요
왜냐면은 CPU에 요즘은 벡터 프로세서가 들어가 있고
그래서 한 번에 4바이트가 아니라
한 번에 뭐 16바이트 정도를
그냥 대입을 할 수 있는 방법들이 있어요
CPU 레지스터에서 곧바로
그런 식으로 하면은 맴 카피보다 빠릅니다
왜? 맴 카피는 결과적으로는 어떤 함수로 호출하는 거기 때문에
함수는
함수 호출에 따라 느린 게 있고
그리고 특정 조건에만은 최적화가 안 들어갈 수밖에 없으니까
그래서 그거를 한 손 한 손 코드로 하시는 분들도 있었는데
한동안은 요즘은 웬만한 컴파일러에서는
그냥 적당히 봐서
어 얘가 한 64바이트 정도 맴 카피를 하네
그럼 알아서 대입문으로 바꿔줘요
그것도 아까 말했던 벡터 프로세서
사용해서 그거 대입해 주는 걸로 바꿔줍니다
하지만 여기서 문제가 되는 거
제가 이번에 봤던 거는 뭐냐면
그거를 프로그래머가 멍청하게 꺼버릴 수도 있어요
그게 문제였어요
어떤 부분의 문제였냐면
요게 크로스 플랫폼 게임 엔진이었어요
그 게임 엔진에서 GPU에 대입해야 되는 그런 변수들
쉐이더 변수라고 하죠
쉐이더 매개변수들
그 매개변수를 할당을 해줄 때
뭐 4바이트짜리 벡터
아니 4바이트가 아니구나
16바이트짜리도 있고
벡터 4를 집어넣으면 16바이트니까
아니면 64바이트짜리도 있어요
어 그건 매트릭스 같은 경우 행렬 같은 경우
그리고 당연히 4 곱하기 3 행렬 아니고
4 곱하기 3 행렬
뭐 벡터도 3 벡터도 있고

뭐 배열 4개짜리 기타 등 따지면은
대충 정해진 크기들의 변수
매개변수를 대입해주는
인자를 대입해주는 그런 함수들이 있었고
그게 memcpy를 내부적으로 이용했어요
어떤 개념이냐면
함수가 여러 개 있는 거예요
야 벡터 4 매개변수 설정해주기
매트릭스 4 곱하기 4
그거 설정해주기
이런 함수가 따로 있었고
그 함수는 내부적으로 memcpy를 호출해서
뭐 4바이트를 복사
아니 16바이트를 복사하든
64바이트를 복사하든 하고 있었죠
그런데 요거를 포팅해주겠다고
들어온 어떤 다른 회사가
아 요 위에 함수들은 그냥 다
그냥 유틸리티 함수일 뿐이고
내부적으로는 결과적으로
이 메모리 주소 가져다가
몇 바이트를 복사해라 라고
하나의 공통된 함수를 만들 수 있겠구나
라고 해서 그 공통된 함수를 만들어버린 거야
그런데 컴파일을 하다 보니까
결과적으로 게임 쪽에서는
야 벡터 16바이트 복사해
매트릭스 64바이트 복사해라고 그냥 알려주는데
그 함수에서 곧바로 memcpy를 호출했으면
16바이트 64바이트
딱
상수로 들어가 있잖아요
그럼 컴파일러가 알아서 그거를 아까 말했던
레지스터에서
그렇게 벡터라이저 해갖고
곧바로 대입해주는 방식
memcpy 호출 안 하고
그 방식으로 최적화를 해줬는데
거기서 함수를 한 번 더 호출해주는 순간
공통된 함수를 호출해주는 순간
그 함수에서는 그냥 변수로 들어오잖아요
그 바이트 사이즈가
그래서 아 얘는 그렇게 대체를 못 해주겠구나
라는 식으로 생각을 해서
그냥 memcpy를 모든 순간에 호출해버리더라고
그래서 CPU가 알아서 최적화해줄 수 있었던 그 부분을
다 함수 호출로 바뀌면서
그게 워낙 많이 호출됐어요
그래픽 쪽 관련된 함수로처럼 엄청 호출되니까
실제 CPU 속도
그니까 한 프레임에서 도는 몇 밀리세컨드 이런 게 있잖아요
게임 한 프레임 그릴 때
거기서 10% 넘게 차지하는 결과가 나서
게임이 엄청 느렸던 이유가 그거였어요
그래서 그거를 다시 그냥 그 함수 들어올 때
곧바로 16바이트라고 상수 넣어서 복사하기
64바이트 넣어서 복사하기로 바꾸는 것만으로
한.. 뭐..
7~8% 다시 향상이 돼버렸죠 10%에서
그래서 그런 걸 보면서
요게 그 단순하게 컴파일러가 다 최적화해주겠지
라고 믿어서 그런 걸 수도 있어요
왜냐면 그걸 몰랐던 회사는 아닌 거 같아요
보면은 최적화에 대한 감은 있는데
제 생각에는 본인들이 주로 사용해왔던 컴파일러
그게 비주얼 스튜디오 쪽 컴파일러 거예요
그쪽은 최적화 굉장히 잘 되기 때문에
그게 그런 일을 해줬었는데
지금 이 콘솔에서 사용하는 클랭 컴파일러가
그 일을 안 해줬던 거 같아요
그래서 거기서 문제가 생겨요
그래서 그런 식으로 좀 느려지는 것들을 제가 봤죠
그래서 요런 거를 생각하면은
조금 안타까운 부분들이 있어요
그런 거 아무 생각 없이 그냥 원래부터 있던 코드를
왜 굳이 그렇게 바꾸면서 검증도 안 했는지
라는 그런 안타까움들이 있더라고요
오늘은 그렇게 memcopy가 최적화가 될 수 있는 경우
한 3가지 정도를 제가 그냥 말씀을 드린 거예요
하나는 memcopy할 때 그게 내부적으로
훨씬 더 유리한 함수로 바꿔서 호출할 수도 있다
그거는 프로그래머가 웬만해서 할 일은 없다
컴파일러가 알아서 해주는 거고
제품마다 플랫폼으로
제품마다 알아서 될 거다
두 번째는 메모리 바이트 얼라인
그게 어떻게 되느냐에 따라 정말 빨라지는 부분들이 있다
그래서 그거는 잘 생각해서 CPU에 적당한 메모리 얼라인먼트를
충분히 넣어주는 게 좋다
왜냐하면 그것 때문에 낭비하는 메모리가
큰 문제가 아닌 경우들이 요즘 많으니까
메모리는 보통 충분히 달려 나오는 경우들이 많으니까
세 번째가 지금 말했던 특정한 바이트 사이즈
몇 바이트까지 요런 거를 memcopy할 때는
내부적으로 컴파일러가 추적할 할 것 같다
가능성이 굉장히 높다
그래서 그런 경우에 굳이 하나의 함수로 합쳐서
뭐 호출하려고 하지 말아라
그러는 순간 이 컴파일러 추적화가 깨질 수도 있다
정도를 말씀드린 거예요
뭐 이 정도면은 그래도 모르셨던 분도 있을 것 같고
아시는 분들은 음 그랬지 하고 넘어갈 수도 있는 것 같아요
그래서 혹시 뭐 제가 잘못 말한 게 또 있다거나
그러면 추가로 알려주시면 고맙고요
이 정도로 그냥 오늘 또 memcopy 얘기는 마치겠습니다
포프였습니다
