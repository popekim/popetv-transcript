안녕하세요 포프입니다.
오늘 제목은 좀 재미있게 나갈 거 같아요.
아마 이렇게 내보낼 거예요.
컴퓨터는 추상적으로 돌지 않는다.
제가 여태까지 하드웨어가 중요하다 이런 예기를 해왔던거랑 일맥상통 하는 예긴데
최근 들어서 알고리즘의 의미를 제대로 드디어 들었어요
여태까지 알고리즘은 이런게 알고리즘이다 이렇게만 알고 있었지만
제가 정의를 제대로 들은 적이 없었던 것 같아요.
그만큼 제 공부가 헛된 공부였다는
그런 예기일 수도 있는데
거기부터 예기를 시작할게요
지금 하려는 얘기는
한빛 강의에서 할 내용이기도 해요 사실은
한빛 저자강의
이 비디오가 나가는 순간 이미 저자강의는 끝났을 테니까
재탕하는 기분으로 아무 죄책감 없이 만들려고 하는 거죠
그 외에 다른 내용이 있을 거예요 어차피
최근에 넷플릭스를 뒤지다가
거기보면 알고리즘이라는 티비쇼였던 것 같은데 하나 있어요.
딱 단편짜린데
영국의 무슨 교수가 나와서 알고리즘을 설명해 주는 것 같아요
근데 이 사람이 알고리즘이라고 하길래 전 당연히
되게 단순하게 컴퓨터 알고리즘이라고만 생각을 했어요
근데 이 사람이 알고리즘의 예를 들면서 설명한 게
최소공배수인데, 유클리드의 최소공배수 맞을 거예요.
그거를 설명하면서, 알고리즘은
그냥
그 사람이 직접 말한 건 아니지만,
컴퓨터에만 있는 게 아니라 실생활의 어디에나 알고리즘이 있다
이렇게 이야기를 해요.
그리고 그 사람의 설명을 들으면서 제가 느꼈던 게
아 세상은 알고리즘으로 도는게 맞구나 제가 느꼈어요
그럼 그 이유를 그 사람이 든 최소공배수로부터 설명을 할게요
최소공배수가 뭐냐? 그러면 대부분 아실 것 같지만
최소공배수 맞나? 아닌거 같은데,
최대공약수
최대공약수 인 것 같아요. 죄송해요.
어 제가...
영어로 들어서 한국말로 대입이 안되는데
최소공배수나 최대공약수 둘 중에 하난데
그 둘 중에 하나 제가 말하는 거 중에 맞는 거 보시면 될 거 같아요.
뭘 말하려 하는 거냐면,
숫자가 예를 들어서 두 개가 있어요. 음 뭐가 있다고 할까?
21이 있고 28이 있어요
그럼 이제 이 둘을 나머지가 없게 나눌 수 있는 분모 중 가장 큰 값이 뭔가를 찾는 거예요
가장 큰 값이고, 나누는 거니까, 최대 공약수가 맞는 것 같아요
뭐...아니면 욕하세요.
그러면, 21하고 28은 7로 둘 다 아니잖아요.
그리고 그게 동시에 나뉘는 가장 큰 숫자예요 7*3=21 7*4=28 이니까.
그러면 그 값은 7이예요.
근데 이게 막 복잡해지면, 숫자가 막 15263 하고 85215조 막 이렇게 나가면은
이 숫자를 찾기가 그렇게 쉽지는 않죠.
그런데 이제
이미 유클리드는, 유클리드가 맞을 거예요, 틀리지 않길 바라는데
이미 그 분이 살아 계시던 시절부터
수학적으로 최대 공약수를 찾는 법을 설명해 왔고
그걸 실생활에 적용하는 방법도 알고리즘을 만들어 놨다는 거예요.
알고리즘이 뭔지 설명하기 전에 최대공약수를 어떻게 찾는지 설명을 드릴게요
이 비디오에서 얘기했던 내용은 뭐냐면
니가 화장실에 타일을 깔아야 돼
화장실이 직사각형이예요, 화면처럼, 직사각형의 화장실인데,
거기에 타일을 깔고 싶은데, 이 타일을 깨지 않도록 네모낳게 다 들어가도록 크기를 찾고 싶다는 거예요
결과적으로 그게 뭐냐면
윗면과 옆면의 길이가 다르잖아요, 그러면
이걸 공통적으로 나누는 방법중에 가장 큰 값을 찾는 방법
그러면서 했던 예기가 뭐냐면 되게 간단했어요
유클리드가 맞을거예요, 그 사람이 정해놓은 바에 따르면
시작을 정사각형으로 시작을 하면 된데요
정사각형의 길이는 짧은변,
높이죠 지금은 저희가 볼 때는,
높은 변의 길이에 딱 맞는 정사각형을 만들어서
그거를 타일링을 한데요
아 이거 너무 커서 보기가 힘든가?
타일링을 하면은 한 타일이 딱 들어가고 나머지가 요 옆에 이렇게 남잖아요 요만큼이
그럼 이제 거기서 요기 남은
직사각형에서 짧은 쪽을
이렇게 할게요, 이렇게 직사각형이 있으면
짧은 변을 해서 정사각형을 넣어요
그러면 이만큼이 채워지겠죠
그리고 남은 건 이만큼이 남을거예요 그쵸?
그럼 다시 짧은변을 잡아서 정사각형을 만들어 채워넣어요
그럼 다시 끝에 짜투리가 남고, 정사각형을 만들어 채워넣고
채워넣고 하다보면, 어느순간에 딱 맞는 크기가 나와요
그럼 그게 바로 최대공약수고
고만한 타일로 화면을 다 깔아버리면
중간에 짤리는 부분 없이 예쁘게 깔린다는 거예요.
알고리즘으로 이걸 봤을 땐 되게 간단한 거예요
일단 이렇게 넓이가 있으면
가장 짧은면, 그죠, 좁은면에 정사각형을 만들어 넣는다.
더이상 정사각형을 넣을 수 없을 때는
다시 남은 부분을 똑같이 직사각형을 떼서
짧은 변에 해당 하는 길이를 잡고
똑같은 과정을 반복하다가 그게 끝나서 딱 정사각형이 들어가는 경우
더이상 남은 공간이 없는 경우 그게 바로 너의 최대공약수이다. 예요.
저는, 아니, 이사람이 말했던 알고리즘의 정의가 뭐냐면
알고리즘을 찾고 만드는데 걸리는 시간이라던가 노력은
굉장히 천재들이 만들 수 있는 영역이라고 얘길 해요.
그러나 일단 그사람들이 알고리즘을 만들어 놓으면
어느 누구나 순서대로 따라할 수 있고
순서대로 따라했을 때 언제나 원하는 결과가 나오는 것을 알고리즘이라고 해요.
그러면, 들어보면은, 저는 맨날 컴퓨터에서 말하는 버블소트니
뭐 정렬, 정렬이 소트구나
그래프 시오리(Theory
)니 길찾기니 이런 것만 알고리즘이라 생각을 했었죠
근데 결과적으로 그것도 하는 건 뭐냐면
이렇게 이렇게 정해진 룰이 있고 그 룰대로 한단계 한단계 따라가다 보면은
값은 보인다 예요.
그게 알고리즘의 정의예요.
물론 알고리즘에 쉽게 걸리는 것도 있고 오래 걸리는 것도 있고 그건 다른 이야기고
그럼 이걸 생각해 봤을 때
제가 왜 세상은 알고리즘으로 돌아간다고 말을 했냐면
저는 보통 여태까지 그걸 프로세스라고 이야기를 해왔어요
이런 프로세스를 잘 잡으면 이게 된다.
근데 저희가 하고 있는 그 무수한 것들 있잖아요
사회를 살면서, 뭐
예를 들어서 내가 집에서 저기까지 가려면 어떻게 가나
예를 들어 전철을 타고 갈 때
전철역에 가서 표를 사거나 표를 이미 갖고 있거나 표를 찍고 들어가서
1호선 어디에 갈아탄 다음 어디까지 가서 환승하고 2호선 어디에서 다시 내리고 가면은 갈 수 있다.
그게 반드시 효율적인 길은 아니지만 대충 효율적인 길이고
요즘 사람들은 또, 나오잖아요 몇번 출구, 몇번 문에서 내리면 환승이 곧바로 있다.
그러면 기다리는 동안 몇 번 문까지 가서 거기서 기다리고 있다가 들어갔다가  내렸다가
이런게 알고리즘 인 거예요. 심지어 커피를 내리는 법 이런거 봐도 메뉴얼이 따라 나오잖아요 순서대로.
1번. 커피를 간다던가, 꽂고 넣고 물을 데우고 뭘 하고 씻고 넣는다.
이거 자체가  그냥 알고리즘 인 거고
중간중간 보면 표면이 뜨거우니 손잡지 마세요 이런 것들이 있잖아요
그게 바로 사고를 막기 위해서 안전하게  이걸 따라만 하면은
내가 몸에 피해가 없고도, 맛있는 커피를 만들 수 있는 과정을 정해놓은게  순수하게 알고리즘이었던 거예요
그래서 프로세스와 알고리즘의 정의가 모호해지면서 아 이게 같은거였구나 생각이 드는거예요.
그러면 결과적으로 알고리즘의 정의라는게 아까 말했듯이
단계별로 따라하기만 하면 결과가 나오는거고
그걸 따라하는게 일반인이 하기에도 멍청하거나 문제가 있는 사람이 아니면 어렵지 않은 것들
저희가 사회에서 말할때도 그런 말 많이 하잖아요
야 너 이거 이거 해 라면서 이거 이거 하면 돼 이렇게 말하면은
이거 이걸 따라하는 사람이 되게 잘 해요 한두개 실수는 하지만
그런데 그것도 못 따라 하는 애들이 있잖아요
그럼 알고리즘이 그 사람에게 너무 어려운 거거나
그 사람이 일반 사람에 비해 그런 걸
따라 할 정도의 능력이 안되거나, 지능이 안되거나 아니면 신경을 안 쓰거나 아예 그들 중에 하나죠 사실
그러나 따라만 한다면 쉽게 될 수 있는 부분이 그런 것 같아요
여기까지 사회의 굉장히 많은 것들이 순서를 정해서 하는 것들 규칙을 따라 하는 것들이 사실은
많은 알고리즘이라고 생각을 하면 돼요.
캔 따는 것 부터 똑같아요. 캔을 들어올린다. 딴다. 따진다. 이런 것들 그죠?
아니면 둥글둥글 캔 돌려따는 것도 있잖아요 그것도 똑같은 거고
그런데
그러면 컴퓨터에는 왜 알고리즘을 많이 쓰냐
그런 얘기를 하잖아요? 그냥 컴퓨터는
이렇게 정형화된 과정들이 있을 때
단계단계별로 정형화된 과정들이 있을 때 그거를 굉장히, 사람보다 빨리 돌릴 수 있는 기계 중에 하나예요
그냥 그게 전부인 거예요.
그래서 컴퓨터가, 그걸 만드신 분이 그렇게 만들었겠지만
주목을 받고 있고 온 세상이 컴퓨터로 돌아가는 이유도
그냥 저희가 당연하게 단계별로 만들어 왔던 과정들
심지어는 예전 고대부터 불붙일려면 장작을 쌓고 짚을 넣고 부싯돌을 해서 불이 오르면 바람을 후 불고..
이런 과정을 쌓아왔던 것들이 그걸 컴퓨터로 옮기면 굉장히 빨리 할 수 있다는 거예요
그리고 컴퓨터가 생기고 나서 부터
저희의 일상이 빨라진 것도 있지만
그만큼 저희가 무슨 일을 해도 빨리 처리하게 되고 효율적으로 살 수가 있는 거잖아요.
그래서, 아  그렇구나 라고 생각을 했고
결국 알고리즘이 현재 사회에서 돌고 있던 건데 컴퓨터를 도입해서 더 빨리 돌게 하는 것 뿐이구나
심지어는 정렬만 생각해도
버블소트 이런 건 아시잖아요 그것만 하더라도 실제 사회에서 우리가
여러가지 숫자를 두고 숫자를 정렬을 하려면 어떤 방식으로 할거냐
그러면 끝에부터 보면서 제일 큰 거 찾아서 하나씩 바꾼다 이런 사람도 있고
그게 제가 알기로는 인서트 소트 일 거예요 아마.
그게 아니면 2개씩 비교해가면서 바꿔가는 애들이 있고
큰거 큰거 계속 올라가게, 그게 버블소트고
결국은 그거였거든요
그럼 제가 옛날에 되게 그런 얘기를 많이 했어요
좋은 엔지니어는 생활 습관부터 다르다는 얘기
그게 어찌보면 저는 뭘 본거냐면
아까 말했던 프로세스를 잘 따르는 사람들
심지어는 프로세스를 자기가 만들 수 있는 천재 영역에 있는 사람들
아주 뛰어난 천재는 아니겠지만 천재와 중간에 있는 사람들
그런 사람들이 결과적으로 프로그래밍에 봤을때도
그런 가속화된  단계별로 알고리즘을  따라가는 가속화된 컴퓨터를 어떻게 돌릴지를 안다는거죠
컴퓨터가 할 수 있는 건 그것 뿐이니까.
그런 개념에서 제가 그런 얘기를 많이 해 왔던 것 같아요
니가 원래부터 남들보다 프로세스를 잘 따라, 또는 잘 따르려고 해
아니면 남들보다 프로세스를 좀 더 잘 만들어
그런 문제점을 발견하고 훨씬 더 좋은 알고리즘을 만들 수 있는 사람이야
그러면은 당연히 엔지니어도 나아질 수 있는 거고 아니면 이게 훈련이 가능도 한거죠
근데 이 두개가 분리되는 순간 컴퓨터는 전혀 새로운 거 내 일상은 전혀 새로운거 생각하는 순간 이미 잘못 생각하고 있다는 거죠
실제 도는 기반은 똑같고 속도의 차이일 뿐인데
그 얘기를 하고 싶었고, 두번째는
제가 추상화의 위험성에 대해서 되게 많이 얘기를 했어요
예전부터, 컴퓨터 어떻게 도는지 이해 못하는 사람들이
자꾸만 약 팔려고 이상한 컨셉 던져놓고 결과적으로는 사람들이 못 따라해서
개발자들이 못 따라해서 그런 개념 다 망가지고 반짝 약팔고 사라진다고 그런 얘기를 되게 많이 했어요
그것도 똑같은 얘기예요. 아까 그
누구야 그 비디오 나왔던 교수님이 말 했던 것도 그렇잖아요
알고리즘이라는 거는 일반 사람들이 되게 쉽게 따라할 수 있는 차근차근한 과정을 거쳐서 되는게 알고리즘이다라는 예기를 했어요
근데 추상화를 너무 해버리면 이런 추상화에 스텝바이스텝 가이드가 있는 게 아니라 그냥 뭉뚱그려서
아, 아트는 아름다운 거지 이런 식으로 개념이 갈 수가 있는 거거든요
그렇게 단계별로 쪼개서 구체적인 내용을 주지 못한채, 그냥 약을 팔고 있는 거죠. 망상을.
아, 이렇게 하면, 이렇게 된데. 다 될거야.
이제 사람들이 질문을 하기 시작해요. 이런 이런 거에서는 문제가 있는데 어떻게 할까요? 답이 없어요.
그게 그 순간에 약파는게 나오는 거예요. 단점들이 나왔을 때 그 단점을 어떻게 개선해야 될 건지
아니면 그 단점을 어떻게 줄이기 위해 노력할 건지에 대해 고민이 전혀 없는 진영들이 있어요
그건 말 그대로 컴퓨터도 이해를 못하는 거고, 실생활에서 프로세스도 못 따라하는 거고
자기가 프로세스에서 좋은 걸 만들기도 되게 어려운 사람 중에 하나예요
그 사람들이 말도 안되게, 이런 걸 다 무시하고 '이 약만 먹으면 최고의 프로그래머가 된데' 라는 개념으로 파는게 문제가 있는 거죠
그래서 그냥, 그 비디오를 보고 최근에 또 제가 멘토링하는 이런 애들을 보면서
분명히 나보다 빨리 배우고 일찍 시작하지만 뭔가 나보다 발전이 느리다고 느끼는 부분들이 있어요
그러면 그런 걸 보면
제가 아까 말씀드렸던 프로세스를 따르는 것일수도 있고 알고리즘을 따르는 것일수도 있는데
그거를 정말 빨리 습득해서 제대로 따라가는 능력
그리고 뭔가 문제가 있을 때 그 프로세스나 알고리즘에서
여기서 이거 하나를 고치면 내가 보던 문제가 사라지고 다른 다른 부작용도 없을 것 같다는
그런 프로세스 개선과정, 마인드를 가진 사람들 그런 부분이 좀 없는 것 같아요
그것도 있고 다른 것도 있지만 그걸 하나 느꼈고
그래서 비디오도 보고 강연 하기전에 질문 받았던 거도 그런 고민들이 많기에
그 강연을 하며 다 합쳐서 이 비디오를 만들었어요.
오늘 비디오의 제목은 컴퓨터는 추상적으로 돌지 않는다.
부제 : 인생은 알고리즘으로 돈다.
괜찮은 제목 같죠? 포프였습니다.
