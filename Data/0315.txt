안녕하세요 포프입니다 요즘에 말도 안되게 보안 얘기를 되게 많이 하고 있죠
일단은 제가 학교에서 웹쪽을 가르키기도 하고 서버쪽으로 보안을 되게 중시하고
제가 최근에 실리콘밸리 쪽에서 시작했던 일 그쪽 일도 웹쪽에 관련이 있기 때문에
보안이 되게 중요한 부분이기 때문에 보안을 되게 신경을 많이 쓰고 있어요
예전에 보안강좌 하면서 제가 그런 얘기 했었죠
뭐 해쉬와 인크립션 이런 얘기를 했어요
보코와 암호화 그런거하고 아니면 해쉬랑
그래서 이제 제가 그때 잠깐 흘러가듯이 얘기를 한 것 같은데
사실 암호화란 부분은 데이터베이스에 암호화하는 거에요
지금은 우리가 손으로 하고 있지만 가면 갈수록 데이터베이스 플랫폼에서
예를 들어서 MS SQL 같은 오라클도 있고 그런 플랫폼에서 자동으로 지원을 해줘야 되는 기능이다라고 얘기를 했어요
그리고
실제 그런게 나타나고 있다고도 얘기를 했고
최근에 저도 이제 또 인크립션을 해야 될 일이 있어 DB 쪽에서
그 기능을 제대로 봤죠
저는 이제 MS SQL을 주로 쓰는 걸 좋아하니까
MS SQL에 예전에 다른 무슨 암호화 기법이 들어온 게 있었는데
요번에는 컬럼마다 다르게 암호화를 할 수 있는
예를 들어서 우리가 테이블에 컬럼이 10개 있는데
그 중에 한 컬럼만 내가 암호화를 하고 싶다
예를 들어서 여기 뭐 유저 이메일이 들어가 있는데
이거를 암호화하고 싶다 그러면 그 컬럼만 암호화할 수 있게 하는 기법이 나왔어요
그게 이제 예전에 손으로 할 때는 누구나 알죠
손으로 할 때가 아니라 자동으로 DB에 가서 이 컬럼 암호화해줘
그러면 그걸 암호화해주는 기법이 나왔고
그게 이제 Always Encrypt라는 그 테크놀로지로 나왔어요 MS SQL에서
그래서 Always Encrypt 테크놀로지를 써보고 싶었죠
그래서 결론부터 얘기하면은 굉장히 좋은 방법이고 세팅하는 것도 생각보다 어렵지 않지만
한 가지 문제 때문에 저희는 결과적으로 안 쓰기로 했어요
그래서 제 생각에는 좀 기다려야만 제가 제대로 쓸 수 있을 정도로 기능이 편해질 것 같고
일단 이게 어떻게 작동하는지부터 알려드릴게요
일단 테이블에서 컬럼을 하나 Encryption하잖아요
그러면 이 컬럼을 Encryption하는 키가 있어야겠죠
그 키를 저장하는 컬럼을 따로 만들어줘요
다시 돌아가자 처음부터 얘기를 하면은
MS SQL에는 MS SQL Management Studio라는 툴이 딸려와요
마이크로소프트에서 공짜로 주는 툴이에요
그 툴로 SQL 서버에 접속을 한 다음에 테이블을 보고
야 이 컬럼을 Encrypt해줘 라고 하면은 이제 그 컬럼을 Encrypt해줄게
그리고 이 컬럼을 Deterministic하게 Encrypt할래? 아니면 Deterministic하지 않게 Encrypt할래? 라고 물어봐요
이 의미가 뭐냐면 만약에 제가 제 이메일 주소를 넣었다
예를 들어서 pop@kim.com이다
제 이메일 아니에요
그걸 넣었다 하면은 언제나 aabb라는 암호화된 문자열이 나온다
언제나 그럼 그건 Deterministic이고
넣을 때마다 이거 이제 뭐 솔트를 해서 다른 암호화가 나온다
그러나 Decrypt하면은 내 원래의 이메일 주소 pop@kim.com을 볼 수 있다
라고 하는 게 이제 Deterministic이 아닌 거죠
그래서 이거를 골라야 되는 경우는 뭐 명백해요
예를 들어서 이메일을 이제 설치를 할 때 DB에서
where 이메일 = pop@kim.com이라고 했을 때
이걸 한 번에 SQL 설치로 할 수 있게 할 거냐
그거를 지원하려면 Deterministic이 필요하고
그렇게 설치하진 않을 건데 가져온 다음에 Decrypt해서 쓸 거라면은 Deterministic이 필요하지 않죠
보완적인 측면에서는 Deterministic이 아닌 게 좋지만
뭐 SQL Query를 빠르게 하려면 Deterministic이 될 때가 있거든요
그래서 그거를 해준다는 거고
그리고 그거를 딱 하는 순간 어떤 식으로 되냐면
이 컬럼을 이제 인크립트할 인크립션 키를 자동으로 제가 만들어서
그거를 다른 컬럼에 저장을 해요
그러니까 이제 다른 컬럼에 인크립션 키가 있는 거죠 한마디로
그래서 거기다 저장을 해 놓고
그리고 이제 음 근데 인크립션 키를 그냥 DB에 저장해 놓으면 아무 의미가 없잖아
그쵸? 왜냐면 DB가 털리면 인크립션 키 보고 털면 되는 거니까
그래서 인크립션 키 자체를 만들고
마스터 키로 한 번 더 인크립트를 해 버려요
근데 이 마스터 키는 어디서 오냐
뭐 프로그램을 설정해 갖고 뭐 애플리케이션 랩에서 지원할 수도 있고
아니면 Azure를 쓰는 사람의 Azure Vault라고 키를 저장하는 따로 이제 저장소가 있어요
거기에 연동을 해서 거기 마스터 키를 가져와서 인크립션 하라고 할 수가 있죠
그러면 컬럼 키는 인크립트 돼 있고
이걸 Decrypt한 다음에 이제 인크립트를 하면은 이제 그 다른 컬럼
아까 이메일로 했던 컬럼
그래서 이 두 개는 DB에 저장이 돼 있지만 마스터 키는 다른 서비스에 저장이 돼 있기 때문에
이걸 모두 털지 않는 한 Decrypt가 불가능하다 뭐 어렵다 이런 얘기가 나오는 거죠 사실은
그래서 그런 식으로 해서 음 인크립트를 지원을 해요
그니까 Always Encrypted가 그런 개념이에요
이게 재밌는 게 뭐냐면 그 애플리케이션에서 이걸 쓸 때는
사실은 DB가 인크립트 되든 말든 애플리케이션에다 신경을 쓰면 솔직히 말이 안 되는 거예요
나는 DB에서 이걸 가져와
저장할 때 Encrypt하고 나한테 줄 때는 내가 쓸 때만 최종적으로 그때만 Decrypt해주면 돼
이게 솔직히 제가 원하는 거거든요 애플리케이션 입장에서는
그래서 그 Encryption을 손수하던 거를 DB 쪽으로 가져갔다는 게 굉장히 올바른 생각이에요
저장소 Encryption이잖아요
똑같은 예를 들면 뭐냐면 우리 폰 같은 거 Encrypt하잖아요
뭐 Android Encrypt 킬 수 있잖아요
그럼 폰에 저장돼 있으면 Encrypt 돼 있지만 쓸 때는 Decrypt해서 보이는 거
그리고 거기에 있는 애플리케이션은 아무 신경을 안 쓰죠
우리 앱이라고 하는 거
컴퓨터에서도 빈 락커 윈도우스에서 이런 거 쓰면 하드 스크롤을 다 Encrypt할 수가 있어요
그러나 쓰는 유저의 입장에서는 그리고 거기에 도는 프로그램은 하드가 어떻게 Encrypt되는지 알 이유가 없죠
그냥 Decrypt된 자료를 읽어볼 뿐이지
그래서 그 개념 자체가 드디어 제대로 잡히고 있다고 생각을 하고 올바른 방법이라고 생각을 하는데
한 가지 문제가 뭐였냐면 다 좋았어요
아 이거 괜찮다 쓰자 라고 생각을 했는데
문제가 뭐였냐면은 Entity Framework
그 전에 제가 ORM을 쓰자 라고 얘기를 했잖아요
ORM 개념이 뭔지 모르시는 분들은 그 비디오를 찾아보시면 되고
DB의 Object를 쓰자 ORM 뭐 이런 제목이었어요
ORM을 쓸 경우에 제가 이제 클래스에서 만들어 놓은 멤버 변수
Property죠 C#에서는
그게 자동으로 DB 컬럼으로 생겨서 클래스 자체가 테이블이 되고
그 각자 멤버 변수가 컬럼으로 들어가게 자동으로 만들어 주는 그런 서비스라고 할까요?
라이브러리라고 하죠 라이브러리가 있어요
그래서 그거를 써갖고 이제 저는 DB를 만드는 거를 점점 하자는 주의고
왜냐하면은 뭐 당연히 최적화를 하기 위해서 뭐 직접 SQL 쿼리를 짜야 될 이유도 있지만
역시 애플리케이션의 입장에서 보면은 저장이 어떻게 되는지는 신경을 크게 안 쓰는 게 좋다는 생각이 들었어요
이건 내 데이터고 데이터를 저장해줘
그게 NoSQL에 들어가든 저장이 어떻게 되는지는 신경을 크게 안 쓰는 게 좋다는 생각이 들었어요
그게 SQL에 들어가든 데이터는 저장만 되고 나는 불러올 수만 있으면 돼 이런 개념이니까
그래서 역시 저장소와 서비스의 분리인데
그게 때문에 ORM을 쓰자고 했어요
근데 재밌는 거는 ORM을 만들었어요 C#에서
그리고 만약에 그 ORM을 만들 때 attribute 태그에
아 이거를 encrypt 해줘 라는 그 encrypt attribute가 위에 딱 있다면
그걸 ORM이 알아서 보고 DB 테크놀로지에서 always encrypt 켜주고 하면 되는데
문제는 ORM이 나온 게 좀 돼요
이제 엔티티 프레임워크 지금 버전이 뭔지 까먹었는데
그 나온 게 좀 되는 상황인데 그 다음에 always encrypt가 생긴 거예요
그래서 엔티티 프레임워크를 설계할 때는 이런 always encrypt라는 게 있을 거란 생각을 못 한 거예요
그래서 지원이 잘 안 돼요
그리고 아까 말씀드렸듯이 always encrypt를 쓰면은 컬럼 하나가 새로 생기잖아요
그 뭐랄까 encrypt 키를 저장하는 그런 컬럼들이
그게 그게 음...
뭐라고 말해야 되나
새로 컬럼이 하나 생기는 거니까
그거를 이제 그러면 ORM에 또 매핑해주기 위해서 저한테 필드를 만들어야 된다는 그런 얘기가 나오거든요
그 현재 있는 상황에선
그래서 ORM에 두 가지가 있어요
DB first가 있고 전 비디오에서 말했어요
코드 퍼스트가 있는데 원래 있는 DB에다가 이 클래스를 매핑하려고 그러면
그게 이제 DB first죠
그러면 여기에 있는 컬럼을 갖다가 여기 적어주기만 하면 돼요
아 여기 이런 컬럼 이름이 들어가 있으니까
이 컬럼을 뭐 string 타입으로 만들어서 매핑해주면
안 쓰면 되니까
그러면 매핑이 되기 때문에 문제 없이 돌아요
근데 이렇게 했을 경우 당연히 always encrypt를 켜도 돌아요
DB first로 하면은
근데 저는 코드 퍼스트 주의거든요
코드를 먼저 만들고 이거를 그냥 deploy하면은 거기서 DB라도 생성이 되고
거기서부터 써야 된다
근데 코드 퍼스트를 DB로 만들었어
DB를 만들었는데 always encrypt가 안 켜져 있어
그러면 아까 말했던 SQL 매니지먼트 스튜디오를 들어가서
이 encrypt 다 켜주고 뭐 하면은
이걸 이제 개 Baker temporary주의라 패입을 해 that 말 HUAWEI CODE
narach.d certa



give me your screaming
버전이�idente
TIMEM��게

성벽
너무

tell me
hand
문장
ajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajjajdajjajjajjajjaj invoice
큰 차이는 뒤에 들어가는 저장소의 종류가 SQL로 제한되지 않고 아무거나 저장을 할 수 있게 하려고 해요
근데 아직 모든 기능이 완성이 안 됐죠
그래서 아직 완성이 안 된 기능이 있기 때문에 아직 프로덕션에 쓸 정도는 아닌 것 같은데
거기서는 혹시 제대로 지원되지 않을까 라는 생각이 있어요
왜냐면 최근에 나온 기술이고 그거 시작될 쯤에는 분명히 MS SQL팀에서도 Always Encrypted 기능을 만들기 시작했을 거고
제가 그건 좀 더 봐야 돼요 실제 그게 지원을 하는지
근데 그게 지원을 한다면 엔티티 프레임워크 7이 준비가 돼서 누구나 쓸 수 있을 때쯤 그때 쓰면 되지 않을까 하는 생각을 해요
그래서 앞으로 이제 계속 진행이 될 기술인 것 같고
마이크로소프트에서 이걸 만들었으니까 분명히 오라클에도 비슷한 게 이미 있거나 아니면 따라만들 것 같고
마이 SQL 같은 거는 잘 모르겠어요
오픈소프트에서 만들었으니까 분명히 오라클에도 비슷한 게 이미 있거나 아니면 따라만들 것 같고


오픈소프트에서 만들었으니까 분명히 오라클에도 비슷한 게 이미 있거나 아니면 따라만들 것 같고
당연히 만들 수도 있지만 아무래도 좀 더 느리게 만들지 않을까라는 생각은 있고
어쨌든 제가 볼 때는 이게 DB에서 인크립션 하는 거에 미래는 저는 이쪽이라고 봐요
그래서 점점 그렇게 갈 거고
아직 제한점은 ORM을 쓸 경우에 컬럼 맵핑 이런 문제들 때문에 아직 반드시 확실하지는 않다
아직은 약간 시기상조일 수 있다
그 정도로 생각을 하시면 될 것 같아요
그래도 뭐 뭐라 그럴까
프로그래머는 원래 게으른 인간들이 아니라
프로그래머는 원래 되게 단순한 걸
말을 바꾸자
훌륭한 프로그래머라면 되게 단순한 접근법을 되게 좋아하거든요
그래서 코드 이렇게 필요 없는 거 이제 떡칠하는 것도 싫어하고
그래서 그런 개념에서 확실히 저장소에 들어가야 할 인크립션을 애플리케이션에서 하는 것 자체가 좀
기능이 없으니까 하는 거죠 그냥
그건 좀 별로였는데 그런 게 좀 더 깔끔해지고 코딩하기가 더 편해진다 정도로 생각하시면 될 것 같아요
그게 이제 오고 있고 그게 지금 등장하기까지 SQL이 한 20년 30년 존재했나요?
지금에 나오는 건 조금 아쉽긴 하지만 결과적으로는 그렇게 되고 있다
그래서 그 정도로 생각을 하시고 한번 눈여겨보시는 건 좋을 것 같아요
계속 이제 진행이 될 일일 것 같으니까
음 그럼 그 정도로 하고 예
포프였습니다
