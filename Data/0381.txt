안녕하세요.
포프입니다.
아시는 분들은 아시겠지만 제가 C++ 강의를 하고 있어요.
물론 캐나다에서 하고 있기 때문에 와서 들으실 순 없겠지만 강의를
하는 동안 가끔 도강을 하러 오신 분들이 있어요.
bcit를 졸업하신 분들이니까 어디로 와야 될지 알아서 도강을 오시는
것 같은데 그러면서 와서 인사 하신 분들도 있고 카페테리아에
있다가 운 좋게 제가 운 좋은 거죠 그분이 저를 알아보셔서 갑자기
공짜로 차를 사주신다거나 해서 얻어먹기도 하고 이런 경우도 있었어요.
근데 하려고 하는 얘기는 그건 아니었고 최근에 C++ 하다가 다뤘던
주제가 알고리즘이에요 알고리즘 제가 알고리즘을 짰다는 게 아니라
스탠다드 라이브러리에 보면 알고리즘 들이 있잖아요.
솔트라든가 카피라든가 이런 것들 많이 있잖아요.
그래서 그거를 보다가
애들에게 가르치면서 이런 게 굳이 왜 있는지 모르겠지만 다 니네가
손으로 짤 수 있는 건데 그래도 이런 게 있어라고 목록을 쭉 보여줬어요
되게 많죠 C++, C++라고 17 막 이런 데 추가되면 더 많아졌고 그러
다가 이제 솔트라는 거는 다시 보고 정렬하는 거 거기에 스테이블 솔트
라는 거를 또 봤어요 그래서 본 김에 예전에 몇 년 전인지 모르는데
꽤 오래 전인데 제가 그 스테이블 솔트를 짤 일이 있었거든요 그래서
그냥 그 생각이 나서 아 이걸 언젠가는 비디오를 만들어야지라고 생각을
하다가 까먹고 안 만들었었기 때문에 그래서 만드는 거예요 정렬이라고
하는 거는 되게 간단하잖아요 정렬 이 종류가 되게 많죠 뭐 그거야
이제 속도가 어느 정도 빠르냐 이런 개념인데 가장 간단한 버블 정렬부터
뭐 흔히들 많이 쓰는 퀵 정렬도 있고 뭐 머지 솔트 그것도 있지만
언제나 볼 때마다 헷갈려져요 머지 솔트를 보고 아 그렇구나 이해하고 쓸 일이 별로 없으니까 나중에 보면 또 새로워
머지 솔트가 있고 특히 제가 많이 썼던 레딕스 솔트도 있고 뭐 여러 가지가 있어요
결과적으로 개념은 그거잖아요 어떤 값이 두 개가 있어요 이게 정수 값일 수도 있고
뭐 스트링일 수도 있고 어떤 물체일 수도 있어요
그러면 이 두 물체를 정렬을 할 때 얘가 얘보다 앞에 와야 되냐 얘가 얘보다 앞에 와야 되냐
그게 전부거든요 그럼 그거를 이제 판단하려면 보통 이게 앞에 온다는 게 크다 작다라는
개념이잖아요 그럼 크다 작다라는 계산을 하기 위해서 보통 여기에 이제 솔트키라는 게 있어요
그거를 해시키로도 만들기도 하고 결과적으로는 뭐 숫자를 예를 들면 숫자 1하고 2가 있으면 정렬할 때 기준이 되는 값을 1과 2로 그냥
쓰자 똑같이 그럼 1이 2보다 앞에 와야 되니까 그게 전부예요
뭐 리버스 정렬을 하면 2가 1보다 앞에 오지만 어쨌든 간에 그러고
뭐 물체 A와 물체 B가 있어 그러면 물체 A는 어떤 그냥 계산을 했을 때 이게
3이라는 값이 나오고 물체 B의 어떤 계산을 했을 때 4라는 값이 나와 그러면은 이 물체 A가 B보다 앞에 와야 되겠구나 이런 개념이에요
뭐 아니면 db를 많이 하셨던 분들은 order by 이런 거 있잖아요 일단은 이름순으로 오더하고 날짜순으로 오더한다 그것도 똑같은 개념입니다.
그런 개념이죠
그런 개념인데
재밌는 거는
일반적인 sort를 썼을 때
이 sort 키 값이 동일한 경우 있잖아요
예를 들어서
숫자가 5개가 있어
숫자보다는 물체라고 하죠
물체가 5개가 있어요 1부터 5까지
근데 그 물체
class니까 object죠
그 object에 있는 모든 값이 똑같아요
아니면 이렇게 얘기하자
object에 있는 field가 3개가 있어요
세 개 중에 두 개만 sort에 쓰고
하나는 안 써요
근데 이 두 개가 똑같아
근데 이 세 번째 값은 다른 거야
근데 일반적인 sort 알고리즘을 돌리면
이미 물체가 두 개가 이렇게 있어요
아까 말했던 것처럼
두 개의 field 값이 똑같고 세 번째 거가 다른데
이 sort 키가
같다는 이유만으로
이게 뒤바뀌는 경우가 있어요
왜냐면은 어차피 얘는 정렬이 어떻게 해도 상관이 없으니까
이렇게 되든 이렇게 되든 상관이 없잖아
라고 할 수 있잖아요
그래서 일반적인 sort 알고리즘은
sort 키가 동일할 때
순서를 보장하지 않아요
원래 있던 순서가 흐트러질 수도 있어요
그래서
예전에 당연히 저도 이제
일반적으로
그래도 문제가 없는 게 일반적이었고 사실은
대부분의 알고리즘이나 데이터 구조에서
저도 한참 쓰다가
나중에 무슨 이유인지 모르겠지만
그게 그 order를
유지해야 될 경우가
한 번 있었어요
제 경력에서 딱 한 번 있었던 거니까
굉장히 없었던 거긴 해요
그래서 그때 이제
열심히 stack overflow 찾아보고
그러다가 봤던 게
이제 stable sort였어요
stable sort라고 하면은
안정적인 sort란 얘기잖아요
그럼 그냥 이 문제를 해결하는 거예요
앞에 sort 키가 똑같은 애들이 있을 때
sort 키가
그럼 나머지 애들
이 세 번째 값이 다 달라지더라도
이 sort 알고리즘을 돌려도
이 순서가 바뀌지 않는다
이런 거죠
그래서
그게 stable sort의 개념이고
혹시 그런 게 필요하셨던 분들이
있었다면
요즘 알고리즘 다 있어요
c++에도 들어가 있는데 그냥
sd 알고리즘에서 그냥 쓰면 돼요
그땐 저는 왜 만들었는지 기억이 안 나죠
만들어야 마였었고
지금 생각하면은
지금 다시 만들라고 해도 못 만들 것 같아
그런 것들이 되게 많죠 알고리즘이라는 게
그 순간에
닥치면
뭐 차에서 다 만들어
까먹죠
그러나 기본적인 알고리즘은 까먹지 않게 되죠
학교 수준에서 배우는 것들
예를 들어 버블 sort 같은 거
퀵 sort 처음부터 만들려고 하면
다시 또 헤맬 테지만 약간은
개념은 알고 있죠
디바이드에 컨커 대충 개념 보고
피복 값을 어떻게 뽑고 이런 건 헷갈릴 수도 있는데
그런 정도의
기본적인 개념은
평생 머리에 남는 것 같아요
근데 그 외의 것들
아주 가끔 한두 번 쓸
쓸 법한 것들
그런 것들은
짜고 나서도 나중에 까먹고
내 코드를 다시 봐야 돼
그런 게 알고리즘이 아닌가 생각을 해요
이 얘기를 왜 하냐면은
얼마 전에
포프TV 비디오에서
슬랙방이었던 것 같다
알고리즘 책이 이게 좋냐 저게 좋냐
물어보시는 분들이 있었어요
이걸 공부해야 되냐 말아야 되냐
제가 줄 수 있는 말은 뭐였냐면은
학교 수준에서 가르치는
알고리즘 정도는 한 번쯤 보는 건 좋다고 생각해요
이런 게 있어야 된다고
알고는 있어야 되니까
아니면은 좀 기초가 되는 것들 있잖아요
예를 들어서
BFS
breadth-first search라는 거
먼저 넓게 설치하고 하나씩 내려가는 거
트리하고 노드 구조 있을 때
아니면 depth-first search 같은 경우
깊이로 다 내려가고 하나씩 올라가는 경우
그런 정도의
기본 개념의 알고리즘이 되게 중요하다고 생각을 해요
왜냐면 거기서 시작을 해서
굉장히 많은 알고리즘을 더 생각할 수 있으니까
어찌 보면은 구구단을 외우는 거랑
마찬가지라고 생각을 하는데
근데 이제
전에도 제가 얘기했듯이
그래서 여기서 좀 더 나갔고
이제 뭐
트리 알고리즘 같은 경우 있잖아요
트리가 아니라 그래프 알고리즘 같은 경우
책 보고 공부하고
다시 하면은 문제 다 풀어요 사실은
근데 이제
실무에서 쓸 일이
예전에도 말했지만 그렇게 생각보다
많지가 않아요 당연히 특정 직종에선
많이 쓸 수밖에 없죠
뭐 네트워크 이제 분산하는 거라던가
뭐 그런 것들은
당연히 쓰겠지만
일반적으로 저희가 생각하는
이제
애플리케이션 웹서비스
게임 쪽으로 보면 생각보다 많지가 않거든요
그런 부분을 가면은
이제 과연 이 알고리즘을
이제 그
몸속에 박혀있을 정도로
알아야 되냐라는 생각이 드는 거죠
뭐
그래서 프로그래밍 하는
사람들 보면은 저도 당연히
그 과정을 겪었지만
굉장히 많은
이제 배울 것들이 많아요
그 수는 점점 늘어나고 있는 것 같지만
제가 이것저것
다 배워보고 이렇게
오래 개발생활 했을 때
생각보다
아예
언제 물어봐도 알 수 있을 정도로
기억해야 되는 것들은
그렇게 많지는 않았어요
그냥 아 이런 게 있구나 정도로 알고
나중에 돌아가서 언제든 볼 수 있는 것들은
되게 좋은 거고
그런 가치에서 굉장히
많은 거를 배웠다는 게 좋지만
학교에서도 그렇고 책으로도 그렇고
그 배우는 내용 자체에
중요한 게 있고 덜 중요한 게 있는 것 같아요
확실히
지금 제가 말했던 알고리즘 부분은
기초적인 거 정도만
이해하면은 상관이 없다고 생각을 하고
나머지는 그런 게 있었구나
그렇게 되면 되는 거고
그리고
그렇게 많이 배운 알고리즘을 다 쓸 일도 별로 없고
디자인 패턴도 되게 마찬가지고
그래서 계속 쓰는 것들
아니면
계속 생각해야 되는 것들을
확실히 아는 게 더 중요하다고 생각을 해요
그게
뭐 이렇게 말하면
구석다리 얘기 듣겠지만
하드웨어를 아는 것들
하드웨어에 가까운 것들
컴퓨터가 어떻게 도는지를 이해할 수 있는 것들
이런 기능들은
쓰면 쓸수록 컴퓨터가 도는 방식을
점점 잘 이해하게 되고
나중에 가면은 그게 그냥 당연한 것처럼 느껴져요
컴퓨터가 어떻게 도는 건지에 대한 게
어찌 보면은
저희가 처음 언어를 배울 때
저희 모국어
그게 뭐 구조가 어떻다 이렇다 모르잖아요
사실은 오래 쓰다 보면은
문법도 틀리긴 하지만
결과적으로는 언어 자체가
의사소통이 충분히 되잖아요
그런 정도의 당연히
자연스럽게 느껴지는 단계까지 가면은
거기서부터 시작할 수 있는 게 되게 많다고 보거든요
컴퓨터가 도는 게 이질적이지 않고
그냥 컴퓨터 이렇게 도는 거지 하고
제품만 봐도 대충
속으로 어셈블리를 어떻게 돌지
감이 오는 그런 경우가 되면은
그 위에 다른 걸 올리는 건
되게 쉬운 것 같아요
그 위에 다른 걸 올리는 거는 말 그대로
마켓 리서치 같은 느낌?
남들이 이런 걸 하고 있구나
아 이런 거를
아 나도 이거 하면 되겠구나 이런 느낌이거든요
그러니까
잡기를 배워서
다시 쓸 수 있는 그런 느낌들
그러나 이런 기본이 되는 것들은
몸에 익지 않으면
그 위에 잡기를 올리기도 되게 힘들어지는 것 같아요
그래서
제가 이제
학교에서 또 가르치다 보니까
그런 생각이 드는 거예요
근데 요즘 학교들은 너무 잡기를 가르치려고 하지 않나
너무 잡기에 눈을 팔고 있지 않나
그거에 대해 이제
업체들이 우려를 표출하면서
야 학교는 좀 더 기초를 튼실히 가르쳐야 된다고
얘기를 함에도 불구하고
이제 뭐 학교에서 가르치는 사람들이
그거에 대한 중요성을 알 정도로
이제 뭐 그 정도 위치에
못 간 사람도 꽤 있으니까
결국에는 그냥
뭐 마케팅의 논리인지 아니면은
그냥 뭐
새로운 기술을 만드는 회사들이 열심히
자기네 광고하려고 마케팅을 하니까 거기에
홀려서 그런 건지는 모르겠지만
어 기초를
이렇게 좀 등한시하는 것들이
보이는 게 좀 안타까운 거예요
그래서
그러면서 이제 또 학교
들의 이제 등급이 나뉘기 시작하더라고요
특히 이쪽에서도
꽤
좋다고 하는 학교들 그리고 실제
뭐 빡세게 가르치는 학교도 있겠지만
그런 학교들을 보면은
순수 이론도
이제 가르치긴 하고
하드웨어 쪽도 굉장히
많이 가르치지만
그에 비해
이제 응용하는
부분 있잖아요 그냥 갖다
껴맞췄고 조립하는 이런 부분이
조금
비율적으로 적죠
그에 비해
좀 이렇게
후딱후딱
그 취업률 올리기에 급급한 학교들이
있어요
그것도
싸구려 임금 프로그램은 취업률을 높이기에
급급한 학교들
그런 학교들을 보면은 이제 그런 걸
하나 둘씩 점점 빼더라고요
제 기억에는 이 똑같은
일이
닷컴버블 때 있었다고 저는 알고 있거든요
닷컴버블 때 워낙
직장을 잡기 쉬워지면서
학교에서 기본기를 빼고
자바만 열심히 가르쳤다가
닷컴버블 붕괴된 이후에
그
취업자리가
없어지면서 졸업생들도
이제
그런 기반기 확실한 기반기가 없이는
취업을 못하고
왜냐하면은
회사에서도 어 그래? 프로그램 해? 그냥 와
이런 분위기가 아니었다고 알고 있어요 그 뒤로
그래서 그 뒤에 다시 학교들이 열심히
그 로우 레벨
하드웨어라던가
그런 약간 중요한
이론적인 것들을 추가
다시를 추가하기 시작했다고
전 얘기를 들었었어요
또 재밌는 거는
어찌보면은 그때 이후에
뭐 훌륭한 선생을 가진
학교들은
계속 좀 더 발전을 시켜나갔던 것 같아요
그렇지 못한 학교들은
그 옛날 방식으로 가르치는 거에
아직도 머물러 있는 걸 수도 있고
옛날 방식이란 게 아까 말했던 하드웨어가 아니라
옛날에는 컴퓨터가
내 귀한 자원이었어요
그래서 막
개인용 PC가 있지도 않았고
실제 코딩 실습 같은 거 하려면은
그 IBM 메인 프레임
같은 중앙에 서버가 있고
단말기 따라 뽑아서 시간 돌려가면서
집어넣는
내 시간이 할당되어 있는
그런 식으로 하는 수밖에 없었고
그보다 더 옛날에는 직접 코딩하면서
뭐 결과를 볼 수 있는 상황이 아니었기 때문에
뭐 펀치카드에 놓고 집어넣는다거나
이런 일도 있었어요
그래서 오히려
컴퓨터를 가르치는 게 그래서
이론적인 거와
이론적인 걸로 원래 시작을 했었고
그렇게 이론적인 것만 가르쳐야 한다는 식으로
머물렀던 과목들이 꽤 있었던 것 같아요
그래서 제가
지금 있는 학교를 봐도
그 운영체제를 가르칠 때
그런 식으로 밖에 안 돼 있어요 사실은
그러면서 하는 얘기가 아 이건 너무 이론적인 것만 있어서
학생들이 재미를 없애야 한다
근데 재미있었던 건 제가
조지아테크에서
최근에 이제 석사를 받았잖아요
물론 OS 과목은
되게 지루한 과목인데
거기선 그래도 숙제가
종이 하는 숙제가 아니라
실제 C로 해갖고 유닉스 시스템에서
OS에 있는 기능들을
하나씩 만들어 보는
것들이 있었어요
그 쓰레딩 쪽을 하면서 이제 타임쉐어링 쪽을
직접 코드로 만들어 봤었고
컨텍스트 캡쳐하고 스위치 하는 것까지
그리고 이제
OS를 보통 하다보면은
아 그 절대
자료를 잃지 않는
데이터 작성하기 이런 거 있잖아요
뭐 크래쉬나도 데이터가
사라지지 않게 언제나 보존하는
이런 것들 그런 것도 실제 코딩을
했어요 그거 외에
네트워크 분산 이렇게 뭐
파일 시스템 이런 것도 코딩을 했었거든요
물론 이제 이 정도의
단계가 당연히
학사급의 단계는 아니라고 생각을 하지만
충분히 OS의
개념들을 코딩 실습을 통해서
좀 더 프레티컬하게
가르칠 수 있다고 생각을 해요
뭐 그와 비슷한 과목으로
얼마 전까지 있던 디자인 패턴
OOAD 이런 과목도 있는데
이 두 과목 다 솔직한 얘기로
더 이상
굳이 학교 과목으로 가르쳐야 되나
생각이 들 정도의 과목들이긴 한데
뭐 그런 것도
굳이 하려면 실습으로 가르칠 수가 있죠
실제 그거를 적용해야 되는 문제를 주고
적용을 시켜라 그게 아니라
보통 이제
그런 과목들은
이론적으로만 가르치니까 또 재미를
잃게 되고
얘기가 그냥
많이 샜는데
그냥
이제
여러 학교를 제가 다녔고
그리고
업계 경력이 많고
십 몇 년 전에 다녔던 학교에
다시 돌아와서 가르치면서
발전하지 않은
모습을 되게 많이 봤고
발전을 한 부분도 봤고
발전을 하려고 했지만
오히려 삽질하고 있는 부분도 보고
그러니까 이제
아 뭔가 교육 제도가
좀 많이 이상해지고 있구나
어느 나라든
정말 우리가 업계에서 필요로 하는
애들을
생각보다 덜 만들어주고 있구나
라는 생각이 점점 드는 거예요
그게 뭐 단지 학교의 문제일 수도
있고 아니면은
프로그래밍 쪽이 인기가 높아지면서
학생 수들이 그냥 많아지면서
평균적인 학생 퀄리티는 떨어지는
그런 이유일 수 있기 때문
때문일 수도 있지만
어쨌든 그런 다양한
생각들이 섞이고 있는 거죠
그래도 어쨌든 오늘 하려고 했던
얘기는
굉장히 동떨어지지만
스테이블 솔트라는 게 있어요
갑자기 이렇게 결론을 내리면 되게 이상할 것 같은데
그냥
예전에 했던 솔트고
아 그냥 이런 게 있구나
그리고
뭐 요즘 다들 잘하잖아요 그거는
뭔가 하고 싶은 거 있으면 스테이크 오프로 찾아가면서
아 이런 게 있다고 쓰는 것들
그냥 그런 개념으로 만들었어요
근데 갑자기 교육에 대한
성찰이 되고 말았지
끊어야겠다 예 포프였습니다
