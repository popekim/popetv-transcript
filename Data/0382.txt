예 안녕하세요 포프입니다 오늘 할 얘기는 개발 쪽 얘기를 좀
하려고 그러는데 예전에 이제 제가 웹 쪽으로 옮기고 시스템을 막 빌드
하면서 이제 퍼블릭 api를 만들기 시작하면서 이제 과연 퍼블릭 api
를 만들 때는 어떤 url 규약을 따라 야 할까 dto 그러니까 뭐 request
바디나 리스폰스 바디에 전달해 주는 그런 오브젝트 보통 제이슨
을 많이 쓰죠 이제는 그런 제이슨 을 전달해 줄 때 과연 어떤 이렇게
규약을 좀 따라야 이제 내 서비스 를 쓰는 사람들이 좀 더 편할까
라는 고민을 한 적이 있어요 지금도 매일매일 하는 고민이고 그래서
요즘은 트렌드가 이제 기본적으로 rest 같아요 rest restful한 url이라던가
이런 걸 많이 만드는데
뭐 이거가 뭐 나쁘다 좋다 라는 얘기는 굳이 하고 싶지는 않고
제가 볼 때는 어 그래 규약 중에 괜찮아 보이는 규약 그리고 얘네가
하려는 게 뭔지는 되게 뚜렷한 그런 방식 물론 이제 rest라는 게
단계가 있죠 뭐 구글도 rest api를 제공하고 뭐 트위터도 제공하고
그러지만 뭐 1단계 2단계 해갖고 마지막 단계까지 가면은 restful한
url 썼을 때
돌아온 제이슨 파일 하나 보고 다른 리소스를 찾으려면 어디까지
갈 수 있는지 나와야 된다 그래서 뭐 이게 무슨 영어로 막 해갖고
줄이면은 hate os에요 hate os 저는 그냥 os를 싫어한다는 의미에서
hate os라고 말도 안 돼 기억하고 있는데
그것까지는 안 가더라도 그냥 rest free 하려는 거 모든 이제 모든 url
을
하고 그리고 그 리소스에 행하는 이제 operation이라고 하죠 그런
연산 연산이 아니구나 뭐 함수를 호출한다고 하죠 그냥 그때는 이제
http 규약에 있는 그런 operation 되있잖아요 뭐 저희는 동사라고 하는데
뭐 get 그럼 읽어오는 거 post 새로 만드는 거 put 전체를 바꾸는 거
업데이트 하는 거 뭐 패치 일부 부분만 업데이트 하는 거 delete 리소스 를
지워버리는 거 이런 규약을 정해두고 그냥 따르면은 뭐라 그럴까 많은
사람들이 비슷한 규약을 따르면 대충 url을 보는 것만으로도 아 이게
뭐를 하는 거구나 라고 추측이 가능해서 가독성도 높여지고 인테그레이션
할 때 좀 더 편하다 뭐 이런 개념 으로는 되게 좋게 봤어요 그리고
이제 여기서 또 하나 열심히 쓰는 게 그게 오늘의 주제긴 해요 사실은
그 반환코드 http를 호출할 때 보통 이제 반환코드가 들어오잖아요
return 코드라고 하죠 뭐 ok이면은 200번이 돌아오고 뭐 새로운 걸 만들었다
뭐 리소스를 새로 크리에이트 했다 그러면 202를 반환해서 크리에이티드
를 반환해주는 거고 아 일단 니가 보내준 요청은 받았는데 아직 처리
중이야 라고 말할 때는 202 accepted 거든요 수락했다 이런 게 나오고
그래서 200대에 나오는 모든 에라
코드는 ok고 그 다음에 이제 500대로 나오는 에라 코드들이 있어요
그 500대로 나오는 에라 코드들은 보통 인터널 서버 에러 서버 내부
에러 500번 뭐 서비스 unav��일러블 서비스가 지금 뭐 서버가 죽었다던가
그게 아마 503인가 뭐 그랬던 거 같고 아닐 수도 있어요 이건 좀
헷갈려요 500번 대라고만 알지 정확히 뭔진 몰라요 그중에서 이제 게이트
아웃 타임 아웃 이런 것도 있고 그거는 이제 내 서버가 다른 서버로
호출하거나 뭐 이런 것들도 있고 그중에서 이제 게이트 아웃 타임아웃 이런 것도 있고 그거는 이제 내 서버가 다른 서버로 호출하거나
뭐 이러는데 그 저쪽 서버의 문제를 지금 뭔가 안 되고 있다 어쨌든 서버 쪽 문제를 하는 거죠
여기까지는 좋아 문제는 400번 대거든요 사실은 400번 대 에라들이 뭐냐면 서버의 문제는 아니고 제가 그 APL을 호출하잖아요
그럼 제가 뭔가 잘못 호출했다는 결과를 보내주는 거예요 그래서 반항 코드 보면은 400번이 굉장히 흔하고 bad request
아 니가 보내준 요청이 뭔가 잘못됐어 이제 제가 고쳐갖고 다시 보내야 되는 거죠
그리고 뭐 401 그거는 이제 아 너는 이 리소스를 접근할 권한이 없다?
이제 뭐 unauthorized 로그인 안 했거나 이럴 때 그럼 이제 아 그 로그인 안 했다가 맞는 얘기겠네 오히려
그리고 비슷한 걸로 forbidden이 있어요 forbidden 이게 403이었던 걸로 기억하는데
이거는 제가 저는 로그인을 했지만 그 리소스가 니 소유가 아니야 니가 남의 은행 정보를 읽을 순 없잖아
안돼 이렇게 하는 거고 409 conflict 이미 니가 전에 보낸 그 리소스를 만들어 놨는데
지금 새로 만들어드리는 리소스가 얘하고 충돌이 나 아 그러면 이건 뭔가 충돌되는 거기 때문에 지금 준 거는 안돼 이러고 버리는 거
여기까진 좋거든요
제가 요즘 최근에 좀수업을 하고 있어요

봤던 문제는 404 였어요 사실. 이게 왜 예전에 RESTful을 고민할 때부터 아 이게 문제가 되겠구나 라고 생각을 했는데
최근에 이제 실제 문제가 된 일이 있었죠 서버에서. 그래서 그게 뭐였냐면은
404가 이제 그 RESTful에서 볼 때는 어떤 리소스를 가져오려고 그래요. HTTP GET을 쏘는 거죠. 그래서 예를 들어서
무슨 내가 은행 어카운트를 읽어오고 싶다 그러면 뭐 서비스 API가 있고 /bankaccounts/account번호를 딱 놓아요.
그러면 그 account bank 계정? 계좌. 계좌인 것 같아. 그 bank 계좌 그 번호로 들어간 그 계좌에 대한 정보를 저한테 보내줘야 되는 거죠
근데 만약에 이 계좌를 찾지 못했어. 그 계좌가 없는 계좌야. 그러면은 이제 RESTful에선 보통 그랬어요.
404를 반환해라. 404가 not found거든요. 찾지 못했음을 반환하면은 아 너는 이 GET을 하려고 했는데 그 계좌가 없는 거니까
뭐 그 계좌를 새로 만들든 뭐 하든 그건 네 마음이고. 그래서 이게 굉장히 valid한 그런 리턴 값 중에 하나예요
이게 문제가 뭐였냐면은 근데 어느 웹서버를 호출하던 간에 URL이 아예 없는 URL 있잖아요. 그러니까 뭐 예를 들어서
어쩌고 닷컴 슬래시 뭐 abcdefg 붙이면 페이지가 없으면 에러 코드로 404가 들어오거든요
이제 restful 서비스를 만들고 RESTful API 클라이언트를 만들 때 이거 우리가 잘못해서. 설정 하나 잘못해갖고
뭐 오타 하나 넣거나 이렇게 URL. 이제 우리 서버가 있는 URL이 이거야. 내부 서비스가. 그럼 슬래시를 빼먹었거나 아니면 실수로 뭐 bankaccount을 치는데 c가 2개 들어가니까

그 C를 하나만 더 따거나 이래서 호출하면 그 서버를 갈 때 무조건 not found 에러가 돌아오게 돼 있는 거예요
그래서 정말 올바른 RESTful API를 호출한 다음에 not found를 받는 거와
잘못된 호출을 했는데 그냥 웹서버에서 그 페이지가 없어 그 URL이 없어 하고 not found를 반환해 주는 게 둘 다 사공사가 들어온다는 거죠
그래서 처음에 이거 디자인 할 때는 솔직히 사공사를 빼고 싶었어요 저희 쪽에서 왜냐하면은 이렇게 실수할 일이 많겠구나
우리 내부 쪽에서는 언젠가 실수하겠구나 이게 테스트를 완벽하게 거치지 못하고 예를 들어서
테스트를 한다고 했는데 아 뭐 우리가 지금 쓰고 있는 URL만 제대로 돌고 그 URL에서는 사공사를 반환해 줬어 그러면 그래 뭐 이 리소스는 없는 거겠지
서버 환경이 테스트 환경이니까
그리고 넘어오면
넘어올 여지도 있다고 생각을 했어요 그래서 아예 사공사를 빼버리고 400번을 반환한 다음에 그 밑에 이제 저희 API는 자체 에러 코드를 주거든요
왜냐면 사공공이라고 말하면 뭐가 틀린지 모르잖아 그러면 그 밑에 무슨 이 필드가 미싱이라던가 뭐 이런 정해진 이넘을 반환해요 그래서
에러 코드를 확인하고 그 이넘을 확인한 다음에 결정을 하라고 보통 그러는데
뭐 이것도 비디오 나중에 언제나 만나요

근데 사공사를 어 그게 이제 되게 애매했던 거였어요 아 이거를 사공공을 만든 다음에 차라리 나 파운드 에러를 반환하면 똑같지 않냐 그 스트링으로 이넘으로 그러면 어차피 클라이언트 쪽에서 볼 때는 아 배드리퀘스트 아 그래 이 URL 이 리소스가 없다고 이런 식으로 생각하면 좋겠다고 생각을 했는데 결국 못 그랬어요 못 그런 이유가 이제 REST 규약 자체가 사공사를 굉장히 널리 이제 쓰고 있고 그래서 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 렉이 그 �
많은 사람들이 기대를 하고 있어서 이거를 우리만의 방식으로 이게 더 낫다는 방식으로 이 규약을 안 지킨다는 것 자체가 오히려 득보단 실이 많겠구나
그럼 이제 최소한 퍼블릭에 나가는 그러니까 공개되어 있는 APM 안에서는 REST를 뭐 아까 말했던 5단계 뭐 이렇게 헤이트 OS까지는 아니어도 정말 리소스를 대표하는 GET, PUT 이런 동사와 이제 올바른 리소스 이름들 이런 것만이라도 제대로 해보자
라는 생각으로 해서 실제 나갔고 무리 없이 쓰고 있었는데 최근에 이제 내부 서버를 릴리스 하다가 이제 그런 문제가 하나 생겼던 거에요
그냥 URL을 고쳐야 되는 부분이 있었는데 뭐 새로 업데이트 하면서 이제 그거를 업데이트 안하고 한 서버가 나갔어
이 서버는 굉장히 간헐적으로 호출되는 서버고 실제로는 HTTP GET만 해갖고 정보를 불러오는 거에요 그래서 이거를 불러와서 이 정보가 있어? 자 그러면 이게 유효한 거니까
계속 진행을 해 이 정보가 없어? 아 그럼 이거는 우리는 잘못 들어온 URL이야 그냥 이건 아직 존재 안 하는 거니까 뭐 니가 새로 리소스를 만들던 해 이런 식의 로직이
였는데 그 URL을 안 바꿔서 실제 웹서버의 URL이 없음에도 불구하고
404가 돌아왔던 거예요 그래서 저희는 그냥 그거는 흔 원래 404가 예측되는 값 중에 하나니까 그 404가 돌아왔다고 해서 뭐 서버의 장애가 있다고 로고를 찍지도 않았고 서버의 장애가 있음 저흰 로고도 찍히겠다고 하는 거에요
이메일도 날라오고 그게 심하면 막 사이렌도 울리고 별짓이 다 되게 되어있거든요
그게 안 된 거예요 그래서 저희는 굉장히 간헐적으로 호출되는 API에서 장애가 있었음에도 불구하고
그 장애가 있다고 그거를 곧바로 보고하는 사람들이 100% 아니잖아요 그걸 모르고 조금 넘어간 거예요
그래서 일단은 문제를 찾아서 고치는 건 어렵지 않았는데 다시 예전 생각이 났던 거죠 아 내가 처음에 이거 보면서 아 이거 문제 언제
생길 수 있겠다라는 게 이제 생긴 거예요 그래서 고민을 했어요 어떻게 이걸 고쳐야 될까
그래서 지금 아직 그러니까 실수를 막자는 의도죠
전에 생각했던 것처럼 404를 쓰지 말고 400으로 쓰자라는 생각을 했지만 역시 그거는 워낙 많은 사람들이 쓰고 있는
RESTful의 스펙에 어긋나는 거라서 안 될 것 같고 내부적으로는 되겠죠 외부적으로는 안 될 것 같고
좀 더 생각을 해보다 보니까
이렇게 고쳐야 될 것 같고
이런 걸 고치기로 했어요 제가 조금 전에 말했던 내용이 있잖아요 저희 자체가 이제 저희의 API는 뭐든지 에러코드를 반환하니까
HTTP 코드를 반환하고 숫자로 그 외에 별도로 우리만의 그 인원 밸류를 반환하게 돼있다 그리고 그것도 언제나 똑같은 스트럭처가 나와요
그러니까 만약에 2000때가 아니라 에러가 났다면 400때라면 특히 그럼 언제나 똑같이 에러코드가 있을 거고 그 에러코드를 보면 거기에
스트링이 들어가 있어요 인웜으로 아 그러면 우리는 앞으로 내부적으로 쓸 때는 404를 반환을 할 때 에러코드도 같이 반드시 반환하게 돼있거든요
그 내부적으로 쓸 때는 404를ặt을 때 에러코드도 같이 반드시 반환하게 돼 있거든요 실제로 그럼 그 에러코드를 읽어야겠구나
그리고 뭐 404를 반환할 때는 뭐 그리고 이제 위 클라이언트 쪽에서 호출할 때 호출할 때 404를 반환하였으면 반드시 에러코드가 있는지 보고 우리 자체 에러코드 그게 없으면 cannot huh...



서버 장애로 로그를 찍으면 되겠구나라는 생각을 했어요
왜냐면 세팅이 잘못된 서버 장애니까
그래서 아 그런 식으로 고쳐야겠다고 생각을 했고
저희가 이게 또 되는 이유가 뭐냐면
이게
저희가 흔히 말하는 마이크로 서비스는 아니고
뭐 마이크로 서비스로 간 적도 있었지만 약간 조금 돌아왔고
그래서 마이크로 서비스하고 모노리틱 서비스 서버하고
약간의 중간 단계로 저희가 쓰고 있어요
마이크로하고
마이크로보다 약간 덜한게 밀리미터인가?
밀리 서버라고 해야 될 것 같은데 내 맘대로 만든 언어
밀리 서버 방식으로 하는데
내부적으로 이렇게 호출하는 경우가 그래도 있거든요 아직
그러면
저희는 무조건
내부 규약이 뭐냐면
서버 간에 호출이 들어갈 때는
Http를 그냥 따 갖고 호출하는게 아니라
그거를 담당하는 API 클라이언트라는 클래스를 만들게 되어있어요
원래 시작했던거는 이제
API 클라이언트라는게 여러가지 다른 서버를 쓸 뿐이지
오퍼레이션은 굉장히 비슷하고
뭐 put, post, get, delete 이런거 한 다음에
결과받아온 다음에 에러 만들고 이게 전부니까
그리고 다른 서버 보내기 전에 클라이언트 사이드에서
밸리데이션 들어갈 것들 required field 이런 것들
그리고 response 받았을 때 또 밸리데이션 해야 될 것들이
굉장히 간단하게
이제 애트리뷰트만 박는 걸로 자동화를 시킬 수 있겠다고 생각을 해서
시작을 한거에요
그 모든게 아직 들어가진 않았지만
이제 다음 단계로 가고 있는거죠
그리고 거기다가 이제 무조건 API 클라이언트에
공통되는
이제 뭐 캐싱 로직이라던가 쉽게 컨피규레이션 할 수 있는
그런걸 놓쳐놓은 생각도 있었고
그래서 결과적으론 API 클라이언트에
공통된 로직을 담고 있는 부모 클래스가 있고
각 API 클라이언트가 거기다 상속을 받아서
이제 세팅만 해갖고 쓸 수 있게 이런식으로 갈려고 했던거죠
그래서 그게 있으니까 되게 간단해지는거에요
그러면 이제 어차피 우리가 그 다음 단계로 가서
통합화 작업을 좀 더 할건데
현재 모든건 API 클라이언트로 써있고
이제 그 위에 부모 클래스만 만들면 돼요 사실은
그럼 그거를 하는 동안에 이제
리스폰스를 들어올 때 무조건 404 체크를 한 다음에
404가 왔을 때 에라코드가 바디에 없으면
이거는 무조건 우리는 장애로 로깅을 할 수 있구나 라고 해서
404가 왔을 때 에라코드가 바디에 없으면 이거는 무조건 우리는 장애로 로깅을 할 수 있구나 라고 해서
그 방향으로 나가는게 맞다고 결정을 내렸어요
그 방향으로 나가는게 맞다고 결정을 내렸어요
그래서 이게 시스템을 디자인하다 보면은
그리고 어떤 규약을 보다보면은 언제나 그런 생각을 할 수 밖에 없거든요
그리고 어떤 규약을 보다보면은 언제나 그런 생각을 할 수 밖에 없거든요
아 이게 어디서 터지겠구나 이걸 어떻게 막을까
근데 이제 가끔 이제 터지겠구나 알고 있고
대책을 이제 확실하게 어떻게 세워야 될지 모르거나
아니면 바빠서 제대로 안 세워놨다가
뒤늦게 약간 깨달은거죠 아 이런 문제가 있었으니까
여태까지 써왔을 때 가장 쉽게 쓸 수 있는 건 이거구나
그리고 어떤 의미에서는
우리가 자칭 밀리 서비스를 하겠다고
꼬장꼬장하게 그 API 클라이언트 무조건 만들라고 강요해왔던게
이제 굉장히 간단하게 실수를 막을 수 있는
추가 기능을 더할 수 있구나 라는걸 느꼈어요
물론 이 모든게
모든거에 테스트가 완벽하게 되있으면
이 모든게 당연히 필요가 없어요
근데 이제 모든거에 테스트가 완벽하게 되어있는 회사를
제가 가본 적도 없고 일한 적도 없고
결과적으로는 코딩 프랙티스에서 실수를 덜 할 수 있는
프랙티스를 많이 만들어 놓으면 될수록
아 이거는 확실히
이런 경우가 생기는게 좀 줄어드는 것 같아요
어쨌든 뭐 여태까지 서버를 하면서 서버 장애가 굉장히 없었는데
이제 오랜만에 또 한번 보고나서 아 뭐 예측했던 실수 뭐
막을 수 있었던 실수 그러나 어쨌든 일어났고
그러면 좀 더 덜 일어나게 하기 위해서 어떤 대책을 세우냐
이런 고민을 하다가 그냥 비슷한 고민을 해보시거나
해보셨거나 아니면 비슷한 문제를 가끔 보시는 분이 있을 것 같아요 사실은
Http URL 잘못 쌓고 사공사 받는 경우 되게 많거든요 사실
사람은 다 손가락이 삐꾸여서 실수를 하게 되어있더라구요
그런거 보면서 이제 고민하셨던 분이 있다면
모든 API 단계에서
공통된 에라 바디 스트럭처를 하나 만들어 두시고
그리고 그 에라 스트럭처가 나와 그걸 만들어 놓으면은
이제 다음 단계로 이렇게 쉽게 모든 거를
엣지 케이스라고 하죠 되게 애매한 케이스
이럴 수도 있고 저럴 수도 있는 그런 케이스들
그런 케이스들을 잡기가 좀 더 편한 것 같아요 그래서
뭐 그냥 주저리주저리 말을 했지만
결과적으로는 RESTful API에서 사공사가 조금 애매하다
그리고 그게 첫 번째 하고 싶었던 얘기고 두 번째가
어떤 RESTful API를 만들더라도 이제 에라가 있으면 에러 바디를 반환할 수 있는
그런 API를 만드는 게 좋을 것 같다는 생각이고 그 에러 바디는 언제나
공통돼야 되고 그래야 어떤 에러가 오든 간에 해석이 가능하니까 쉽게
그리고 세 번째는 그 에러 바디까지 들어왔으면 아까 말했던
사공사에서 약간 애매한 부분을 대응을 해서 뭐 방지는 아니죠
발견되자마자 곧바로 대응할 수 있는 체외가 된다는 거죠
그래서 음 그 정도 네 포프였습니다
