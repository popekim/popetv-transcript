음.. 오늘도 C++ 얘기를 좀 더 할게요
C++ 11 그 이유
전에도 말했지만 이게 요즘 다시 나오는 이유는
아 제 포큐아카데미 동영상 강의를 촬영하면서 쭉 정리하다 보니까
아 내가 쓰는 건데 그리고 업계에서도 필요한 건데 얘기를 안 한 것들이 좀 있구나
라는 생각이 들어서 그런 얘기를 하는 거예요
그래서 오늘 할 것들은
아 뭐 그 전에 제가 포큐아카데미 얘기를 자꾸만 제가 하는 것 같아서
그 강좌 링크를 비디오 밑에 걸어둘게요 설명에
그러니까 와서 돈 내고 들으시면 돼요 광고입니다
농담이고 진담이고
어쨌든 간에 오늘 얘기할 거는
컨스턴트 베리어블 아니야 컨스턴트 베리어블 아니야
컨디셔널 베리어블
아 굳이 한국말로 번역을 하려면 조건변수라는 거죠
이게 생각보다
생각보다 많은 분들이 아직 보시지는 않았을 건데
멀티스레딩 하면서
이 Threading Library에 있는 것 중에 일부인데
멀티스레딩 하면서 특히
베리어씽크 같은 경우 만들어야 될 때
즉 제가 예전에 한번 슬라이드 보여드리면서
멀티스레딩 올바른 방법이라고 보여드린 그 비디오가 있어요
포프TV에
그 비디오에서 말했던 요즘 CPU가 굉장히 많아질 때는
워커스레드 방식
뭐 잡시스템 이런 걸로 해야 되는데
그럴려면은 동일한 태스크들을 여러 개 한꺼번에 돌리고
모든 Thread가 끝날 때까지 베리어씽크를 걸어야 된다
그럼 이런 시스템을 구현할 때
기본적으로 이제 한 Thread가 실행이 되고
일단 다시 잠들고 나서 어떤 특정한 조건이 충족이 되면
다시 깨어나서 실행을 해야 되잖아요
그럼 이제 어떤 조건이 충족될 때라는 걸 이벤트라고 많이 해요
그래서 이제 이벤트가 올 때 깨어나서 일을 해야 되니까
그 이벤트가 올 때까지 기다리는 거
그렇게 이제 슬립하는 거죠
그 Thread를 잠들게 하는데 어떤 이벤트가 올 때까지
몇 초 이런 게 아니라
그거를 탐지하는 그런 변수를 아니면 그런 Threading의 방식을
이제 Conditional Variable을 써서 해요
C++에서 Conditional Variable이라는 이름을 쓰기 시작을 했고
아 뭐
굳이 왜 이름이 왜 들어왔는지는 정확히 알아보지는 않았지만
업계에서 그동안 흔히 쓰던 이름은 아니었기 때문에
제 생각에는 처음 이런 개념이 소개된
무슨 학술지나 거기서 이름을 따온 게 아닐까라는 생각을 해요
윈도우스 쪽에서 이런 거 비슷하게 해 보셨던 분들은 보통
이거를 이제 Event Object 이런 식으로 생각을 하죠
어떤 Event Object 만들어두고
이 Event Object를 이제 여기에 Signal
신호가 올 때까지 기다리는 애들이 있죠
그럼 이제 걔네들이 있고
Wait for Signal 뭐 이런 식으로 기다리고
그리고 이제 다른 Thread에서 어떤 조건이 만족됐어 그러면 Notify 하면은
그 Signal을 기다리고 있던 한 Object 한 Thread만 깨어나게 할 수도 있고
아니면은 그 모든 Thread를 동시에 깨어나게 할 수도 있고
그래서 이제 Event Object라고 많이 아실 거예요
이게 들어온 게 C++의 Conditional Variable로 들어왔고
이게 왜 들어왔냐 그러면 좀 더 잘 알 수 있을 거예요
조금 전에 잠깐 얘기할 때만 힌트를 보셨겠지만
윈도우스에는 이런 거였다
그럼 당연히 리눅스 개념 포직스 계열에서는 다른 거였겠죠
그래서 플랫폼마다 공일한 방식이 없었기 때문에
동일하게 만들려고 이제 소개를 한 거예요
저도 이제 예전에 게임 엔진을 만들 때
이제 저희 회사 말고 따로 이제 사이드 프로젝트로
뭔가 좀 재밌는 게임 프로젝트를 만들다가 접은 게 있어요
거기서 이제 기본적으로 우리도 모든
이제 업데이트 루프를 이런 워커 시스템으로 돌려야겠다는 생각이 들어서
C++ 11 기반의 Conditional Variable를 써갖고 워커 시스템을 구현했었어요
그러면서 굉장히 많은 삽질을 솔직히 했죠
그리고 그 삽질한 거에 일부분 내용을
왜 이걸 어떻게 써야 올바른지 등에 대한 내용을
이제 4Q 아카데미 강조에도 사실 넣었고요
뭐 그 다음에 이거를 제대로 쓰는 게임 엔진에서 아직은 제가 보지를 못했는데
왜냐하면 제가 뭐 이런 최근에 쉬핑했던 게임들
이미 기존에 있던 워커 시스템이 있었기 때문에
그거를 굳이 갈아엎을 이유가 없었죠
자체 개발을 했던 게 있었고 그걸 쓰고 있었고
근데 이제 어쨌든 간에 앞으로 만들어질 게임 엔진이라면
Conditional Variable를 쓰지 않을 이유는 없다라고 생각을 해요
나중에 게임이 잘 돼서 어디로 포팅이 될 때
포터빌리티가 이제 보장이 되는 그런 라이브를 쓰는 게 조금 더 좋기 때문에
근데 제가 아까 좀 삽질을 많이 했다 그랬잖아요
되게 재밌는 얘기를 들려드릴게요
제가 강의 자료를 준비하면서 이런 이런 이런 이제 단점들이 있다
이런 이런 이런 거에서 좀 조심해라
그런 개념으로 제가 이제 설명을 했겠죠 당연히 누군가한테
그 강의를 이제 이제 리뷰를 봐주신 이제 괴물 프로그래머 분이 한 분 계세요
꽤 괴물로 인기 이제 명성이 있고 사실은 저희 업계에서는
그 분이 이제 딱 그걸 보고 나서 하신 말이 있어요
그 분은 게임 프로그래머셨기 때문에 대부분 이제 윈도우스만 쓰시던 분이거든요
보고 나서 Conditional Variable =인데 왜 이거를 써야 되는지 모르겠다라고 말씀을 하셨어요
내가 게임을 그냥 윈도우스에서 출시할 거면 윈도우스 이벤트 오브젝트 쓰고 말고
그리고 이걸 나중에 딴 데로 포팅을 하면은 이제 그거를 이제 뭐 Reverse OOP 패턴이라던가
다른 Threading Library 그 OS에서 도는 Threading Library를 따로 만들어서 쓰면 되는 건데
그렇게 하고 말지 자기는 이걸 안 쓸 것 같다고 얘기를 하시는 거예요
그래서 저는 그게 솔직히 굉장히 어느 정도 동의를 해요 왜
지금부터 말씀을 드릴 건데 일단 전에도 몇 번이나 얘기했지만
C++ 언어의 문제점이 워낙 다양한 사람들이 끌고 가고 있다고 얘기를 했어요
그러면 어느 한쪽에서 이거를 추가하려고 하면 다른 한쪽에서는 아 이거는
우리 플랫폼에서 하기 너무 어려우니까 이렇게 하면 안 돼 요렇게 해줘 저렇게 해줘 라고 해서
모두를 만족시키는 방법으로 라이브러리 디자인을 좀 가는 방향이 있어요
그 대표적인 예가 이 Conditional Variable에서 나오지 않나 싶어요
그 얘기는 조금 뒤에 하고 Conditional Variable 쓸 때 주의하셔야 될 게 한 두 가지 정도가 있어요
하나 Conditional Variable이라는 게 결과적으로는 나는 이 개체를 기다리겠어
그리고 나는 이 개체에 시그널을 주겠어 이 mutex라고 하죠 그냥
이 Lock 그러니까 Thread 두 개가 접근하려면 뭐 여기서 Lock을 걸고 기다리고 Lock을 다시 풀어주고
다른 Thread에선 양쪽 Lock을 걸고 야 이제 해도 돼 그리고 또 풀어주고 이런 과정이 필요하잖아요
Gro severity 락킹을 하는 mechanism 이 있는데
그 Locking mechanism 에서 쓸 수 있는 Understandable and tongued Lock 이 Ce graphics Joined Lock
launch out Lux Twenty Lock 이 C++에서 유니크 락이라는 게 있어요 그것밖에 못 써요 흔히들 이제 저희가 쓴다면 스코� Joan Lock it out
유니크 락을 써서만 할 수 있고 어찌보면은 유니크 락을 C++에서 쓸만한 곳이 유일하게
컨디셔널 베리오블밖에 없지 않느라고 생각을 해요. 일반적인 사용 용도에서는.
그래서 컨디셔널 베리오블이 유니크 락을 강요하기 때문에
어쩔 수 없이 유니크 락을 써야 돼서 유니크 락을 좀 공부해야 되는 단점이 있어요.
그리고 그것 때문에 이제 이 여러 가지 문제가 생기는 것 같은데
이걸 어떻게 설명을 해야 될까?
제가 좀 전에 처음에 말했던 그런 문제점을 이제 얘기를 할게요.
모든 이제 언어들을 모든 플랫폼을 충족시키려고 되게 이상한 표준을 좀 만들어 놓은 게 있는데
일단 컨디셔널 베리오브를 하려면요. 컨디셔널 베리오블 그리고 나는 이 조건이 만족될 때까지 잠들겠어.
그 아마 함수 이름이 wait일 거예요. 그 함수를 호출할 때 거기다 유니크 락을 하나를 놓아줘야 돼요.
그게 무슨 의미냐? 일단 내가 락을 걸고 wait할 때 이러면
이 락을 같이 놓아줘요. 그러면 이 wait는 딱 wait하면서 wait 위에 들어가면서 잠들면서 이 락을 풀어줘요.
그러다가 다른 스레드가 막 돌면서 또 자기가 어떤 뭐 락을 걸고 여기에 시그널을 쏴주겠죠.
딱 쏴주는 순간 얘는 깨어나면서 아까 그 매개변수로 들어왔던 락을 다시 딱 락을 걸고
그 다음에 일을 진행하는 거예요.
이렇게 돼야지만 이거를 이제 언어적인 거에서 지원을 해줘야지만
이 락을 이제 요 뭐라 그러지 뮤텍스라던가
그런 거에 접근 못하게 하는 것도 있고 시그널을 쏠 때 쏘기 전에 잠들고 막 이게 레이스 컨디션이 되면 안 되니까
그런 거를 보장하는 매우 좋은 방법인데
여기서 굉장히 쪼그만 이제 문제점은 유니크 락을 걸고 wait를 했는데
wait에 들어가는 순간 이 락이 풀린다는 생각을 처음에는 못해요. 왜?
이 락이 스코프들 락처럼 딱 있고 이미 딱 범위가 벗어나면은 지워지는 락처럼 돼 있는데
wait라는 순간에 락이 풀린다는 생각을 이제 함수 명세를 안 읽으면 모르는 단점이 좀 있는 거예요.
그래서 정확히 말하면 그 함수가 wait and unlock 아니면 뭐
그러고 이제 다시 깨어날 때 락을 다시 잡아온다라는 게 함수 이름에 좋았으면 다 있으면 명확하겠지만
그런 함수 이름이 너무 길어지기 때문에 wait 하면은 고런 뒤에서
이제 뭐 깨고 풀어주고 이런 이제 과정이 일어난다 고 정도는 그냥 알아주셔야 되고
거기까지는 괜찮은데 가장 큰 문제는 뭐냐면요
딱 wait를 걸었어요. 그죠?
그러면 이
오브젝트 conditional variable의 누군가
'아 나 너 일어나도 돼' 라고 notify를 해주기 전까지
시그널을 해주기 전까지는 잠들어 있는 게 맞잖아요?
윈도우스에서는 그래요.
근데 다른 어떤 플랫폼에서는 얘가 그 조건이 들어오지 않는데도 깨어날 수가 있어요.
그걸 뭐 영어로 하면은 무슨 뭐 이렇게 써있는데
그니까 뭐 약간 좀 개념이 아직 조건이 없는데 좀 이르게 깨어났다.
뭐 그때 그걸 뭐라 그러지?
이를 일찍 출산하는 걸 조산이라고 하나요?
그런 식으로 약간 좀 프리머추어하게 영어로는 이제 완벽히 준비가 되지 않았는데
이제 깨어날 수 있다라는 개념의 그런 그 단어가 있어요.
저도 지금 단어를 까먹었는데 sp어 쪽으로 시작하는데
그러면 저는 당연히 wait 해놓고 당연히 이 조건이 왔을 때 깨어났다고 생각하고 코드를 작성하고 싶은데
그게 안 되는 거예요.
사실은 이거를 뭐 더 나은 해결책은 다음에 말씀드리고
while loop에 적어서
그래서 딱 깨어났는데 정말 내가 노티피케이션이 들어온 건지를 확인하는 다른 변수를 확인하고
그 변수를 이제 세팅이 안 돼 있으면 다시 잠드는 이런 과정을 이제 for loop로 놓아야지만 정상적으로 해결이 돼요.
그렇지 않으면 깨어날 때가 아닌데 깨어나니까.
그래서 또 wait 함수를 따른 이제 오버로딩 된 걸 보면은 아까 말씀드린 락을 받는 거 외에도 옆에 이제 람다처럼 함수 포인터라고 할게요.
함수 개체.
를 받는 그런 또 두 번째 매개 변수가 있어요.
그게 뭐 하는 거냐?
아까 말했던 이 while loop에 있는 조건을 거기에 넣어주면은
지가 알아서 깨어났다가도 그 조건이 충족이 되면 안 되면 둘 중에 하나예요.
뭐 조건이 충족이 안 되면 다시 잠들고 다시 잠들고 그러다가 정말 제대로 노티피케이션이 들어왔을 때 딱 깨어나서 이 조건을 봤어.
그러니까 이 조건에 어떤 불리형 값이 세팅이 된 거죠.
그러면 아 이게 실제 노티피케이션 한 게 맞구나.
그러면 그제서야 제대로 깨어나서 처리를 해요.
이제 이제 아까 그분이 제가 왜 이걸 써야 되는지 모르겠어요.
라고 했던 부분이 바로 이건 거 같아요.
이벤트 오브젝트 걸고 이벤트 시그널 줄 때까지 기다리라고 했으면 당연히 언어에서 기다려 주는 게 맞지.
그게 무슨 이 언어가 지원하는 어떤 플랫폼에서는 이게 조건이 충족이 안 돼도 깨어날 수가 있기 때문에 그거를 허용해 주기 위해서 언어 디자인을 이렇게 했다.
그 자체가 잘못된 거죠.
그래서 뭐 표준화 시키는 거는 되게 좋은데 그 순간에 언어 표준.
그 위원회든 누구는 좀 정신 제대로 차리고 그렇게 말했어야 하는 거 같아요.
아니 이건 너네 os의 문제지.
이 언어에서 이 조건 자체가 시그널 들어오면 깨어나는 건데 그거를 니네가 충족을 못 시키면 니네가 내부에서 뭐 여기서 뭐 코드를 어쨌든 만들어야 되잖아요.
컴파일할 때 컴파일하는 과정에서 그 코드에서 니네가 알아서 컴파일하던 니네 컴파일러가 그건 컴파일러가 해야 될 일이지 뭐 디자인 언어 스펙 자체가 해야 될 일은 아니라고 딱 구분시켜 줘야 되는데 말도 안 되게.
이런 요건이 들어온 거죠.
뭐 제가 그 처음 스펙을 이제 누가 검토를 했고 누가 제시를 했는지 모르겠는데 제대로 안 봤는데 아니면 제시한 사람이 그냥 윈도우에서는 이렇게 제대로 돈다는 걸 모른 채 다른 os에서 좀 제대로 안 도는 거에 익숙해서 그게 당연히 그런 거겠지 라는 생각으로 뭐 제안서를 낼 수도 있고.
그래서 어쨌든 간에 컨디셔널 배리어 오브을 쓸 때 이제 주의하셔야 될 거는 그거예요.
조건이 만족 안 되는데 깨어날 수 있는데.
그 조건이 만족됐다.
라는 가정을 하고 코드를 짜면은 그게 버그가 날 수 있다는 거 윈도우에서 돌리면 버그가 안 날 거예요.
아마 그 상황이 없다고 저는 알고 있는데 뭐 또 모르죠.
뭐 날지도 근데 제가 알기로는 윈도우스 내부 구현으로는 분명히 당연히 그런 이렇게 os에서 지원하는 그런 함수로 대체하고 있을 테니까 내부적으로는 문제가 없을 거라고 생각을 하고 다 이제 그게 다른 플랫폼 되면은 이제 버그가 보이기 시작하겠죠.
잘못된 코드 짜놓으면 그것도 좀 말이 안 되는 거예요.
포티 포터블리티를 보장하기 위해서 이렇게 만들어 놨는데 언어 스펙 자체 잘못 만들어 놔서 한 플랫폼에서 제대로 돌던 게 다른 플랫폼에서 안 도는 상황 자체가 나온다는 거.
그리고 그 스펙 자체가 정말 뒤집어 보고 까보고 문서 다 읽어보지 않으면 함수명만 보고는 도무지 감이 안 오게 짜놨다는 거.
그래서 그런 부분에서 약간은 좀 아쉬움이 있는 부분이 컨디셔널 배리어블이고 그 뒤에 이거를 뭐 고치겠다는 시도가 없는 거 봐서는 뭐 한동안 고칠 일은 없지 않을까.
그래서 그런 부분에서 약간은 좀 아쉬움이 있는 부분이 컨디셔널 배리어블이고 그 뒤에 이거를 뭐 고치겠다는 시도가 없는 거 봐서는 뭐 한동안 고칠 일은 없지 않을까.
라는 생각을 해요.
그래서 어쨌든 간에 오늘 얘기를 대충 정리하고 넘어갈 수 있을 것 같은데 이벤트 오브젝트 이런 게 이제 들어온 거고요. 컨디셔널 배리어블로.
그리고 잡 시스템 이런 거 만들 때 배리어 싱크 제대로 걸기 위해서는 배리어 락 제대로 걸기 위해서는 포터블리티를 보장하는 그런 코드를 작성하려면 컨디셔널 배리어브를 쓰는 게 맞다.
그런데 지금 말씀드렸던 제일 마지막에 말씀드렸던 그 굉장히 기괴하고 굉장히 이상한 부분은

또 코드를 작성을 잘 해줘야 된다.
잘 모르는 사람은 코드 읽어도 이해 안 될 거야.
이거 왜 이런 짓 하지? 라고 생각될 정도로.
그래서 그런 단점은 있지만 어차피 Threading Library라고 하는 거 특히 이렇게 잡 시스템이라고 하는 거는 한 번 만들고 테스트를 충분히 해 놓으면 그 뒤로부터는 뭐 락킹 언락킹 메카니즘은 별로 고칠 일이 많지 않으니까 그래도 나쁜 건 아니다.
그런데 뭐 기존에 이미 있는 코드가 있으면 굳이 바꾸라고 하고 싶진 않아요.
새로운 코드는 그래도 좀 작성하는 게 좋지 않을까.
그 정도로 하면 될 것 같아요.
그리고 아까 짜투리로 잠깐 얘기했듯이 컨디셔널 배리어브를 쓸 때는 유니크락을 써야만 한다.
그래서 또 유니크락을 억지로 한 번 배워야 되는 단점이라고 할 수도 있고 장점이라고 할 수도 있고 그것도 있다.
그래서 제가 이거는 4Q 아카데미 하기 전부터 알던 건데 제가 공유를 제대로 안 한 것 같아서 비디오를 한 번 더 만들었어요.
이러고 나서 있는 비디오 찾아봤는데 또 있으면 되게 황당할 것 같긴 한데.
뭐 어쨌든 뭐 저도 망각의 동물이니 그렇게 하고 넘어가야죠.
예 포프였습니다.
