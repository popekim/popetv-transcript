안녕하세요. 포프입니다.
오늘은 방어적 프로그래밍에 대해 얘기를 해볼게요.
사실 이거는 여태까지 제가 만들어 온 비디오들이
하나하나 이건 이래라 저래라 하는 방어적 프로그래밍에 관한 기법들이 많았어요.
그거를 따로따로 떨어뜨려 놓고 보니까 모든 비디오를 본 사람들은 왜 그러는지 아실 것도 같은데
그걸 다 안 보신 분들이 있다면 그걸 한 번에 묶어서
아 방어적 프로그래밍이란 이런 거다?
그래서 나는 이런 이런 이런 구체적인 뭘 해라 하지 말아라는 가이드를 말하고 있다.
라고 하기 위해서 비디오를 만드는 거예요.
그래서 어찌 보면 여태까지 비디오를 봐오셨던 분들한테는 정리하는 개념이고
비디오를 안 보셨던 분들한테는 이게 시작해서 자세한 내용들은 다른 비디오 가서 볼 수 있게
그렇게 하는 게 일단 목적이에요.
그래서 일단 뭐
뭐뭐를
검색해볼 건지 일단 얘기를 할께요.
일단 오늘 얘기를 할 구체적인 주제들은
예외 처리 exception 그 두 번째가
Dependence Injection
세 번째가 이제 스트링 vi
Eenum
널 처리
Magic Number
상수 쓰는 것들
그리고~
첫번째가 이프문 구조 잡는 법
그리고 일곱번째가 TDD
Test Driven Design
Test Driven Development
그거에 대해 얘기를 할거에요
여기서 일단 자세하게 살펴보기 전에
한 두가지 정도는 확실히 잡고 넘어가야 될 것 같아요
일단 방어적 프로그래밍하고
자기 방어적 프로그래밍은 다르다라는 얘기를 하고 싶어요
무슨 의미냐면은
운전할 때 아무리 안전하게 운전을 해도 사고가 맨날 나는 사람이 있고
운전할 때 안전하게 운전을 해도 사고가 안나는 사람들이 있어요
그게 뭐냐면 나는 안전하게 운전을 하지만
남이 이상한 사고를 칠 때 내가 더 안전할 수 있냐
그게 방어적인 운전이거든요
그런 개념에서 방어적 프로그래밍을 오늘 얘기할거고
그에 비해 자기 방어적이라는 의미도 있잖아요
예를 들어서 다른 사람한테 야 너 이런거 어떻게 됐어
그러면 괜히 혼자
자격지신 먹어왔고
자기 방어적으로 나오면서 좀
자기의 감정때문에 다른 일을 그르치는 경우들
그래서 그런걸 자기 방어적이라고 해요
그래서 제가 오늘 말할 부분은
방어적인 프로그래밍이지
내 이제 쪽팔린거를 구해보겠다는
자기 방어적인 프로그래밍은 아니에요
그리고 이 이야기를 드리는 이유는
생각보다 업계에서 방어적 프로그래밍을 하면서
자기 방어적 프로그래밍을 하는 사람들이 있기 때문이에요
그 자세한 이유는 뒤에서 제가 말씀드릴거고
그리고 또 한가지 말하고 넘어가야 될 것은
제 이런 방어적 프로그래밍에 대한 기준
저는 기준이고 그 기준에 따라서 코딩을 많이 짜요
그 기준때문에 나오는 다양한 가이드들이 있고
그 가이드들이 저한테는 코딩 규칙 코딩 스탠다드가 되어가고 있는거에요
그래서 제 코딩 스탠다드는 이미 c++하고 c#용으로 공개가 되어 있죠
그리고 조만간 4Q 아카데미를 열기 때문에
c++ 코딩 표준이 한글화로도 나올거에요
그래서 거기에 들어간거다 라고 생각을 해주시면 돼요
그래서 거기에서 본 것들 그리고 제 비디오에서 본 것들을 합친게 이거에요
와.. 서문이 길었죠
이쯤되서 관심이 없으신 분들은 끊고 나가시면 될 것 같고
관심이 있으신 분들은 앞으로 좀 긴 비디오가 될 것 같으니까
차근차근 보면 될 것 같아요
말을 많이 할 것 같으니 물 한잔 마시고
첫번째 예외 처리 exception에 대해서 얘기를 해볼게요
아 이거 얘기하기 전에 한가지 원칙을 더 말하고 가야겠다
죄송해요
좀 전에 제가 코딩 스탠다드에 저만의 원칙이 이제 들어가 있다고 얘기를 했어요
그럼 저만의 원칙은 뭐냐
프로그래머를 짤 때 코드를 짤 때 다섯가지 기본 원칙을 보통 저는 봐요
첫번째가 프로그래머가 실수하지 않게끔 예방할 수 있는 코딩 규칙이에요
코딩 스타일
두번째가 설사 실수가 났더라도 최대한 빨리 잡을 수 있다
최대한 빨리 문제를 찾을 수 있다
세번째가 일단 시간을 낭비하지 않기 이 의미는 뭐냐면
개발에 들어가야 하는 시간이 있고 제품 만드는데 시간이 있고
뭐 좀 제품의 완전성을 높이기 위해 여러가지 일을 하면서 시간을 들이는게 있어요
근데 어쨌든 간에 이제 뭐 어느 업계에 가느냐에 따라 이제 좀 더 안정성이 중요한게 있고
아니면 제품이 빨리 나오는게 중요한게 있지만
이제 웬만한 회사에서는 제품 만드는 시간보다 뭐 다른거 좀 더 안정성을 높이기 위해서 집어넣는 시간
안정성 10% 올리려고 시간을 4배로 넣을 수는 없거든요
그래서 그런거 개념에서 시간을 너무 낭비하지 않는 쪽 그런 쪽에 이제 쉽게 쉽게
그리고 어찌보면 프로그래머 시간을 낭비하지 않고도 할 수 있는 그런 안정성을 방어적인 프로그래머를 하는걸 좋아하기 때문에 그런거를 좀 얘기할거고
네번째가 이제 굉장히 중요한건데
인간의 지적능력 우리가 일반적으로 보는 프로그래머의 지적능력에서 할 수 있는 것들
왜냐하면 아무리 개념이 좋고 아무리 뛰어난 방법이라고 해도 인간의 성향에 맞지 않아서
인간의 본성에 맞지 않아서 인간이 이제 뭐 흔히 배우는 자라오는 환경이라던가 유전적인 문제 때문에 하지 못하는 것들을 강요할 수는 없거든요
그래서 그런 것들이 이제 중요한거에요
중요한거 그러니까 지적 수준에서 인간이 쓸 수 있냐 그리고 마지막거는 문제는 발생할 때 곧바로 보호해야 한다
이 다섯가지 원칙이에요
다시 말하면 프로그래머 실수 예방 실수 나올때 빨리 찾기 시간 낭비하지 않기 프로그래머의 시간을 너무 많이 낭비하지 않기 적당한 지적 수준에서 할 수 있는 것들 인간이
그리고 문제는 발생하는 것이 곧바로 보호해야 된다 이 다섯가지 원칙
자 그러면 이제 아까 말했던 한 몇개였지?
대여섯가지 것들을 이제 살펴볼게요
첫번째가 이제 예외처리에요 예외처리 음 예외처리가 뭔지는 아실거고 제가 예전에 예외처리 관련 비디오를 한 여섯 일곱 개를 만들어놨 아니 여섯개 아니다 한 세네 개를 만들어놨어요
그래서 그거는 제가 링크를 걸도록 할거고 그걸 봐주시면 되고 오늘 할 얘기는 그거에요
그럼 예외처리는 아까 제가 말했던 다섯가지 원칙중에 과연 어떤거에 잘 맞느냐라는 얘기거든요
프로그래머의 실수를 예방할 수 있다? 그거는 아니에요 오히려 실수를 촉진하기도 한다고 저는 생각을 해요
그 익셉션 핸들링 잘못하는 경우 되게 많거든요 그럴 경우에는 오히려 익셉션이 터지는거를 곧바로 잡지 못하고 익셉션이 터지는데도 프로그래머가 계속 돌리고 있고
그럼 프로그래머가 실수를 못잡아요 그리고 또 하나가 제가 익셉션에 대해서 굉장히 크게 문제 삼는게 익셉션을 함수 안에서 이제 익셉션이 나기 시작을 하면은
함수가 10줄짜리라면은 10줄 각각 익셉션이 날 수가 있거든요 그럼 그 순간에 그 10가지나는 익셉션을 다 고려하면서 프로그래머가 잡을 수 있냐 되게 애매한 부분들이 있어요
그리고 똑같은 얘기로 이제 두번째 요건은 실수를 이제 빨리 잡을 수 있냐 뭐 역시 딱 프로그램이 터졌을 때 그냥 멈추지 않고 익셉션 처리하면서 돌아가는 순간이 있으니까 그럴 수 없고
어 뭐 시간을 낭비하지 않는다 이것은 뭐...


그것도 좀 애매한게 익셉션을 처리할려면 어쨌든 간에 익셉션 처리 하는 코드 봐야 되고 어디서 익셉션이 나는지 살펴봐야 되고 익셉션 세이프티 보장 해야되고 굉장히 어려운 부분들이 많아요
그리고 가장 큰 문제는 저는 이제 인간의 지적수준에서 사람은 기본적으로 코드를 위에서 아래로 읽는 게 일반적이에요 어떤 문서를 주던 뭐하던 간에 사람은 순서대로 읽지 이 하나 읽다가 이 쪽으로 점프하고 다음줄 읽다가 다른 줄로 점프하고 다음줄 읽다가 다른 줄로 점프하고
다른걸로 점프하면은 이미 생각해야되는 조건이 4가지잖아요
그 순간에 굉장히 많은 사람들이 로직을 못따라해요
그래서 어쨌든간에 인간은 한단계 잡고 쭉 읽는게
훨씬 익숙하고 잘하기 때문에
멀티태스킹이 안되는거죠 어떻게 보면은
그래서 그런거에서는 인간의 지적수준에서 진짜
익셉션 세이프하게 익셉션이 나도 문제가 없게
코딩을 돌릴려는 원칙이 있어요
그럴정도의 코드를 쓰는게 굉장히 일반적인 프로그래머한테는 어렵다
대부분은 어렵다는걸 제가 느꼈어요
그리고 또 하나 이제 다섯번째 원칙
문제 발생한 곳에서 익셉션 나온 곳에서 딱 멈추고
뭐든지 디버깅 해야되는데 굉장히 많은 경우에는
핸들링을 해버리기 때문에 이제
실수가 생길 수 있죠 딱 문제가 생기는 곳에서 못보는게 있죠
그래서 저는 익셉션은
다른 익셉션 비디오를 보시면 알겠지만
결국에는 이렇게 판단해야되요 익셉션은 정말
내가 컨트롤하지 못하는 상황에서
뭔가 굉장히 예외적인 상황이 발생했을 때에요
그럼 그걸 어떻게 처리할거냐는 얘기에요 근데 그 얘기가 뭐냐면
내 코드 안에서 내가 짜고 있는
코드에서 함수고출하는 거에서는
익셉션이 안나는게 정상이에요 기본적으로
왜? 아니 어차피 모든 코드를 내가 컨트롤하고 있고
모든 데이터를 내가 컨트롤하고 있으면
익셉션이 없게 코드를 짜면 돼요 그 익셉션이
날 수 있는 데이터를 안 넣어주면 돼요 근데 문제는 언제냐면은
익셉션에 날 수 있는 데이터가
외부로부터 들어올 때가 있죠
웹 리퀘스트라던가 이런거에서 외부에서 내가 컨트롤하는 데이터가 날아왔어
아니면 내가 이제
또 다른 예는 이제 파일 시스템에서 파일을 읽으려고 하는데
파일이 있었는데 읽는 순간 파일이 지워졌어
왜? 프로그램이 도는 순간
다른 프로그램이 그 파일을 지워버릴 수도 있으니까
사람이 지울 수도 있으니까 이런거는
내 코드의 범위가 아닌 이제 다른 범위
내가 컨트롤할 수 없는 거에서 데이터가 들어오거나 데이터를 액세스하는
문제거든요 그래서 이런 경우에는 익셉션을 쓰는 게 맞아요
근데 익셉션을 쓰되
딱 그 경계가 바뀌는 순간 파일 읽는 순간
딱 파일 읽고 어 파일이 안 읽혔어 익셉션 처리하고
내부 코드에서는 이제 파일이 안 읽혔으니까
너를 반환하든 뭐 불리한 값을 반환하든 해서
파일을 못 읽었을 때는 처리를 하는 게 정상이고
외부 데이터가 들어왔을 때도 외부 데이터 들어왔을 때
이 값이 올바른 값인가를 일단은 다
검증을 해요 밸리데이션을 하고 문제가 있으면
곧바로 리젝트 해버리고 끝내버리면 내고 리퀘스트를
문제가 없으면 내 시스템으로 들어오는 거죠
그리고 시스템으로 들어오는 순간 그 데이터는 이미 유효한 거기 때문에
익셉션이 날 수 있는 여지는 없다 라고 판단하고
이제 코드를 짜다보면은 제가 좀 전에 말했던
이제 인간은 일직선으로 읽는다는 거
그 모든 걸 일직선으로 읽을 수가 있어요 그리고 문제가 없어요
그래서 그런 부분이 이제 좋고 자세한 건
익셉션 코드를 살펴보시 익셉션 비디오를 보시면 돼요
그래서 익셉션을 그러면
지금 안 쓰면 다른 거에서 또 실수하는 걸 어떻게 막냐
그러면 제가 예전에 몇 번이나 얘기했던
이제 Assault를 박는 법이 있고요 Assault를 박아서
디버그 중에 모든 문제 잡아야 되고 그리고 컴파일러나
컴파일러가 아니지 개발도구가
공짜로 주는 정적 분석 도구들이 있어요
그거를 쓰면은 개발자의 시간을 하나도 들이지 않고
버튼 하나 누르는 것만으로도 모든 거가
이제 모든 건 아니죠 많은 것들의
문제를 찾아주기 때문에 그 문제를 해결할 수가 있죠
그래서 익셉션은 경계가 바뀌는 데서 쓰자
그 안에서는 모든 코드는 익셉션 없이 돈다고 가정을 하고
만약에 무슨 문제가 생긴다면은
그건 Assault나 정적 이제 분석 등을 통해서
미리미리 QA 때 잡자 실시간 서버에서
괜히 익셉션 난다고 핸들링한다고 어설프게
돌게 하지 말자 이 얘기에요
두 번째 와 오늘 비디오 정말 길어지겠다
DI dependency injection
이거는
어찌보면은 되게 좀
이제 사람들이 실수를 많이 잘못 이해하는 부분들이 있어요
사실은 이 부분이 OOP의 원칙에서 보면은
inverse of control인가
뭐 그래서 이제 dependency를 줄이는 방식이 있어요
그래서 그거에 한 방법으로 DI를 하는 것 뿐인데
IOC inverse of control이요
IOC를 하는 것 자체가 DI라고 생각하는 사람들이 있어요
그거하고는 전혀 상관이 없어요 DI 안 쓰고도
IOC는 원래 가능한 게 정상이에요 근데 DI라는 건
DI라는 게 결국은 뭐냐면 제가 예를 들어서 어떤
인터페이스가 클래스 인터페이스 할 때
인터페이스가 제 프로그램 안에 있어요
그럼 이 인터페이스의 구현체는 뭐가 되냐 라고 할 때
이거를 하는 방법이 두 가지 정도가 있다고 보는 거예요 하나는
내가 직접 클래스를 구현체를 만들어 놓고
그거를 코드에서 뉴 그런 클래스에서
그걸 만든 다음에 대입하는 법이 있고
아니면은 DI 개념으로 가면은 이제 DI에서는
그 뉴 클래스를 하는 게 아니라
어느 셋업 파일을 만드는 거예요 이 인터페이스용은
이 클래스를 만든다 스코프는 무슨 뭐 글로벌일 수도 있고
싱글턴이요 아니면 뭐
리퀘스트 안에 있는 스코프일 수도 있고
아니면은 만들 때마다 새로운 인스턴트를 만들 수도 있고
그런 식으로 어떤 셋업 파일에
이 인터페이스용 구현체는 이거라고 설정을 해주면
프로그램 실행 중에 이제 자동으로
그 인터페이스를 쓸 때마다 그 클래스가 나오는 거예요
저는 이거를
이제 뭐 아이디어는 알겠는데
솔직히 이게 가장 이제 유명하게 된 계기가
사실은 TDD 쪽 하는 사람들이
유니테스트 하겠다고 근데 유니테스트 할 때
테스트하는 클래스랑 실제 클래스랑 달라야 되는 경우가 있으니까
그거를 DI로 처리하겠다 그러면
코드 하나도 안 바꾸는데 아 테스트 돌릴 때는 테스트 클래스로 돌리고
마크업 클래스도 있고요
실시간 서버 돌릴 때는 실제 이제 구현체가 나오도록
제대로 된 구현체가 나오도록
세팅하겠다 그래서 많이 좀 퍼진 게 있어요
이거는 전에 비디오에서 말했지만
그런 용도로 쓸 거라면은 이거는 인터페이스의 남용이고요
아 이런 거를 좀 더 자동으로 처리해주는 제품들이 나오고 있죠
예전에 설명했던 타임머기라던가
그것도 링크를 걸 수 있으면 걸게요
그런 것들에서 해결이 되는 거예요 그래서 유니테스트는 일단 집어치우고
그럼 DI만을 갖고 얘기를 할게요
DI의 가장 큰 문제점은 뭐냐면
아니 장점은 뭐냐면
내가 클래스를 바꿀 때가 있어요
나중에 가다가 이 클래스 말고 다른 클래스를 쓰자
그 바꿀 때 뉴 그 클래스라는 걸 다 찾아갖고 손수 안 바꿔도 된다
이런 장점이죠 근데 그에 비해 단점은
실제 프로그래머가 그 파일 하나
실제 그 클래스 인터페이스를 쓰는 파일에서
볼 때 아니면 그 코드를 볼 때
아니면 로그 찍힌 거를 본다던가
이 클래스가 뭔지 알 방법이 없어요
그 세트업 파일을 따로 열어봐서 봐야만 되는 거예요
그래서 그런 부분에서는 오히려 한눈에 어떤 구현체를 만드는지 안 보이기 때문에
나중에 디버깅하거나 이럴 때 좀 에러사항이 있어요 사실은
그래서 아까 말했던 원칙으로 얘기를 하면은
프로그래머 실수 예방하는 효과는 솔직히 없고요
왜냐하면은 뭐 내가 코딩을 짜다가
실수하는 그 문제가 아니라 이거는
내가 이 인터페이스가 당연히 어떤 구현체라고 가정하고서는
그 구현체가 아닌 경우가 있을 수가 있거든요
그리고 나는 분명히 이 코드를 고쳐놓는데
다른 애가 세트 파일 바꿔가지고 빠개지는 경우도 있고
물론 엄밀한 OOP 개념에서 말하면
인터페이스와 같으면 모든 구현은 제대로 돌아야 정상이지만
실생활에서는 그러지 않는 경우가 되게 많아요
아무리 열심히 노력을 해도 구현체마다 따로 하는 것들
그런 가정들이 오브젝트 밖으로 퍼지는 경우들이 충분히 있어요
그래서 프로그래머 실수가 오히려 더 잘 발생하고요
써본 결과
실수 시 최대한 빨리 문제를 잡을 수 있다도 솔직히 아니에요
그만큼 딱 한 눈에 무슨 클래스가 들어오는지
만들어지는지 보이지가 않기 때문에
그러면 또 이제 인터페이스 만든다고 모든 클래스 만들 때마다
인터페이스 만들고 클래스 하나 만들고
실제로는 현재 구현체가 하나일지라도
인터페이스 클래스를 만드는 경우가 있죠
제가 전에 말했던 인터페이스의 남용
그리고 인터페이스 클래스 만드는 하고 시간 낭비
그리고 이거를 그러면 DI를 안 쓰고
실제 클래스를 쓰면 오히려 코드 바꾸는데 시간 낭비가 많지 않냐
바꿀 때마다 라는 얘기를 할 수도 있는데
첫째 코드 바꾸는 일이 그렇게 많지 않고
요즘은 ID가 매우 매우 좋아져서 그거 한 번에 바꾸죠
그냥 뭐 이름 변경하기로 바꾼다던가
아니면 전체 차에서 한 번에 뒤집기로 바꾼다던가
실제 그거 바꾸는데 걸리는 시간은 한 기껏해야 30초?
그 정도밖에 안 걸려요
그래서 시간 낭비적인 측면에서는 차라리 DI를 안 쓰는 게 나은 거고
시간 절약 측면에서는
그리고 적당한 인간의 지적 수준에서 쓸 수 있냐 이거는
사실 쓸 수는 있는데
이제 문제는 뭐냐면
아까 말했듯이 인터페이스를 보면은
그 순간에 내가 클래스가 구현체가 뭔지 몰라요
그럼 그 구현체가 뭔지를 찾아가는 과정을 얼마나 인간이 열심히 할 거냐
사람들은 생각보다 게으르기 때문에 대충 눈에 보이는 것만 보고 넘어가요
하나하나 한눈에 보이지 않으면 가서 찾아보지는 않아요
그런 의미에서는
구현체가 직접 코드에 나와 있는 게
훨씬 일반 사람들이 실수 없이 편하게 그 지적 수준에서 쓸 수 있는 방법이기도 해요
그럼 뭐
뭐 문제 발생한 거에서 잡는다 이거는 뭐
인터페이스 클래스 똑같은 얘기죠
구현체가 실제 있으면 어떤 구현체인지 알고
그 구현체 안에 가서 브레이크 포인트 걸고 볼 수 있겠지만
그게 아니라면은 인터페이스에서 브레이크 포인트 걸고
실행될 때 어떤 구현체를 하는지 한 단계 한 단계 봐야 되고
약간 좀 더 에라 사항은 있어요
그래서 그런 부분이 있고
음
또 하나는 이런 부분도 있어요
이건 어찌보면 되게 되게 핵심적인 문제일 수도 있는데
컴파일 도중에 오류가 잡히는 게
실행 도중에 오류가 잡히는 게 좋아요
예를 들어서 DI를 하고 있는데
셋업 파일들이 있잖아요
어떤 클래스를 만들 건지
그 셋업이 제대로 됐는지 안 됐는지는
코드를 실행해 봐야 확인할 수가 있거든요
근데
인터페이스에서 인젝션 안 쓰고
곧바로 클래스에서 구현체를 만들어서 코드를 짜버렸다면은
나중에 뭐 생성자가 바뀌었다거나
나중에 어떤 게 바뀌었을 때
뭐 신텍스 에라 같은 걸로
컴파일이 안 되는 경우가 바로 떠요
그래서 실제 DI를 하면은
실행하고 나서 고쳐야 될 문제들을
DI를 하지 않으면 컴파일 도중에 잡을 수 있기 때문에
뭐 디버깅 속도에 훨씬 유리한 점이 있어요
그래서 시간 낭비하지 않는 거
문제 빨리 잡는 거 이런 부분에서는
DI를 안 쓰는 게 훨씬 유리한 점이 있어요
훨씬 유용해요
두 번째 끝났고
와 한 시간짜리 비디오 가봐
세 번째는
이거는 자바 쪽에서 특히 문제인 거 같은데
자바 프로그래밍 많이 하신 분들 보면은
굉장히 많은 것들을 스트링으로 비교를 해요
스트링을 쓰냐 이뉴머레이션을 쓰냐 차이거든요
이넘 타입
왜냐면 자바 쪽에는 한동안 이넘이 없었다고 들었어요
지금 나왔다는 얘기도 들었는데
제가 확인은 제대로 안 해봤고
그 예를 들어서
음
그 무슨 데이터가 들어올 때
이 데이터에 들어올 수 있는 유효한 값이
예를 들어서 동서남북 네 개밖에 없어요
근데 이제 자바 프로그래머들은 이거를
뭐 동은 0 선은 1 이런 식으로 숫자로 비교하거나
가독성이 좀 떨어지죠
아니면은 이거를 그냥 스트링으로 비교를 해요
North South 막 이런 식으로
근데 문제는 뭐냐면
스트링은 어떤 데이터도 넣을 수 있는 거잖아요
그래서 스트링에서 만약에
동서남북이 아니라 여기다가 바보 이렇게 넣어도
일단은 코드 안에 들어가고
그럼 함수 안에서 이제 이게 바보
동서남북 중에 하나인지를 판단하는 로직을
다 둘 수 밖에 없어요
근데 그렇지 않고
이뉴머레이터 타입을 쓰면은
이넘 타입이죠
이넘 타입을 쓰면은
딱 그
받을 수 있는 값을 4개로 지정을 해 놓고
그 타입을 이제 매개변수로 받으면 되니까
그 타입이 아닌 게 들어오는 순간 이제 에라가 나게 되어있죠
그래서 그런 유효성 검사는
아까 말했듯이
exception 할 때 말했듯이
처음 바운더리 바뀔 때
경계가 바뀔 때
딱 처리를 해서 거기서 리젝을 해볼 수가 있어요
그리고 또 하나 장점이 이런 거 스트링으로 잘못 넣고 이러는 것들은
실수로 함수가 원래는 동서남북을 받는 함수인데
뭐 아침 저녁을 받는 이제 그 데이터 스트링을
실수로 그런 함수를 호출할 수도 있어요
아침 저녁을 판단하고 싶은데
실수로 동서남북 함수를 호출할 수도 있어
이게 이넘이었다면은
컴파일러가 잡아주거든요 컴파일 중에
근데 스트링이라면은 실행하지 않는 한 잡을 방법이 없어요
그래서 이것도 이제 아까 말했던 다섯 가지 원칙 중에
전부 다 어긋나는 거예요
스트링을 쓴다는 것 자체가 1 2 3 4 5 다 어긋나는 거고
사실은 이제 이뉴머레이터 타입을 써야만 이넘 타입을 써야만
제가 이뉴머레이터라고 말 잘못하는데
이뉴머레이터라고 이넘하고는 달라요 사실은
그 이넘을 써야만 이제 아까 말했던 그 다섯 가지 원칙을 다 지킬 수가 있죠
이게 그래서 세 번째 건 얘기했고
네 번째 건은 널처리
널이라고 있잖아요
전에 비디오 만들었는데
이 널처리의 문제가 뭐냐면
아마 언어 만드시는 분들마다 그런 얘기를 하는 사람들이 많아요
이제 아 이 언어에서 널을 넣은 게 내 큰 실수였다
이런 식의 얘기를 많이 해요
널이 좋긴 좋은데 그만큼 프로그램에서 실수를 많이 할 수 있는 부분이기도 해요
왜냐
예를 들어서 제가
스트링을 받는 함수가 있어요
이 함수는 스트링을 뒤지는 함수에요
근데 스트링이
실제 스트링이 들어올 수도 있고
널이 들어올 수도 있잖아요
그럼 널이 들어오면은
곧바로 반환을 하거나 에러 코드를 리턴하거나
이런 코드를 위해 짜야 돼요
안 그러고 널로 돼 있는 스트링을 뒤집으려고 하면
널 익셉션이 나버리거나 크래쉬가 나버리니까
그래서 이런 경우에 코드 이제 잘 못 짜시는 분 보면은
함수마다 널일 경우는 이렇게
널일 경우는 저렇게
이거를 다 넣어요
막 널이면 널 익셉션 쏜다 이런 식으로
근데 이거는 정말 말이 안 되는 방법 중에 하나인 게 뭐냐면
아니 내가 아까 전에도 말했지만
일단 내 코드에 들어온 데이터는 다 유효하다고 가정하자 그랬잖아요
그리고 실제는 내가 컨트롤할 수 없는 데이터가 읽어 들어오는 부분
거기서만 유효성을 검증하자
그거를 잘하면은 제 함수들은 뭐든지
매개변수는 절대 널이 아니고 반환값은 절대 널이 아니다라고 짤 수가 있어요
기본적으로
그쵸?
그러면은 그 모든 코드마다 만약에 널이면 널 익셉션 던지고 이런 게 필요가 없는 거예요 그냥
그게 가능해요
왜냐하면은 아까 말했듯이 데이터를 이미 검증해서 리젝을 해버렸으니까
내 시스템에 들어온 건 다 유효하다
그래서 모든 함수에서 그 검사를 안 하고
모든 함수의 반환값에서 너를 반환 안 한다고 가정을 하면 되는 거예요
근데 가끔 널 처리를 해야 될 때가 있어요
왜냐하면은 내가 지금 만약에
네 유저 아이디가 아니 이메일 어드레스가 뭔지 불러오려고 했는데
뭐 이메일 주소가 아직 안 넣었어
그러면 걔가 이메일 주소를 안 넣었다는 거를 표현하기 위해서 너를 반환할 수도 있거든요
그런 경우에는 함수 이름에 get user name or null
이런 식으로 해서 너를 반환하는 거를 확실하게 보여주게 하자
그리고 매개변수도 이럴 때 제가 매개변수를 이름을 봤는데
이 이름이 정말 이름이 없는 사람이 있어
그래서 이 사람은 무명씨야
그런 경우에 null이 들어올 수도 있다면
매개변수 이름 지을 때 string 하고 null 아니다 name or null
이런 식으로 해서 매개변수나 함수 이름에서 분명히 얘는 null을 들어올 수 있는 애라는 거를 확실하게 해주면 돼요
그런 식으로 처리하면 된다
이 이야기가 되게 제가 처음 말할 때 다들 벙쩌 보인다고 얘기했었을 것 같은데 옛날 비디오에서
실제 C# 버전 8에서 이런 일을 하려고 하고 있어요
C# 8에서 모든 데이터 타입을 null이 될 수 있는지 null이 안 될 수 있는지를 프로그램상에서 넣게 해서
null을 못 받는 걸로 표현되어 있는 데이터형이 있는데
코드 어디선가 null 포인터를 집어넣으려면 컴파일 시간에 warning을 주던가 error를 주던가로 그런 스펙을 만들려고 하고 있어요
그래서 이거는 모든 개발자가
똑같이 겪는 문제고 제가 생각했던 해결법과 C# 쪽에서 해결하는 생각법이 비슷하니까 뭐 되겠구나
C# 쪽에서는 이게 들어올 거니까 C#에서 쓰면 되고
그게 아닌 언어들은 제가 말한 것처럼 기본적으로 모든 프로그램에서는 null을 반환 안 한다
null을 반환할 때는 이름에서 명백하게 나오게 한다 라고 하면 돼요
그래서 이것도 아까 말했던 원칙에 딱 말하면 null 처리 같은 것도
똑같은 거예요 이것도 사실은 이제 null 처리를 안 하고 null exception 안 던지고 뭐 그냥 null일 때 리턴하는 경우는 없으니까
null이 잘못 들어오면 문제가 생기면 바로 보여요
그리고 프로그램을 실수 예방할 수도 있고 실수 나오면 빨리 잡을 수도 있어요
거기다 딱 멈춰버리니까
그래서 한마디로 시간 낭비하지 않는 거 되게 중요하고 가장 큰 거는 인간이 인간이 지적 수준에서 쓸 수 있어요
데이터가 들어왔는데 모든 데이터가 예외 상황에 있다라고 가르쳐야 돼요
가정을 하고 null 체크해야 되는 거 모든 함수마다 그래야 되는 거 굉장히 피곤하고 놓치기 쉬운 부분들이거든요
근데 기본적으로 그런 일이 없다라고 가정해 놓으면 그 처리는 저 윗단 어디서 했다라고 가정하면 사람들은 되게 쉽게 코드를 짤 수가 있어요
로직에 좀 더 집중을 할 수가 있고
다섯 번째 와 세 개밖에 안 남았어
매직 넘버 매직 넘버라는 게 뭐냐면 코드에서 예를 들어서 숫자를 넣을 때
변수에 이름 붙여서 상수에 이름 붙여서 뭐 컨스트 인트 한 다음에 이거는 넘버 오브 스튜던츠 뭐 맥스 스튜던츠 학생 총수 이렇게 해서 500 이렇게 정할 수가 있는데
그게 아니라 숫자로 500을 쳐는 사람들이 있어요
그러면 나중에 코드 보다 보면은 이 500이 뭘 의미하는 건지 모르겠는 거야
그래서 그런 것 때문에 이렇게 숫자를 곧바로 쓸 때는 차라리 이거를 상수화 시켜서 이름 달린 상수화를 시켜서 변수명을 주는 거죠
그 변수명을 쓰라고 해요
이거는 되게 당연한 건데 안 하시는 분들이 아직도 좀 있긴 있어요
그래서 뭐 이거는 그냥 아까 말했던 원칙 이제 12345 중에 네 가지는 확실하게 완성을 하고요
이제 시간 낭비는 당연히 숫자 쓰는 것보다는 변수 만드는 게 좀 더 시간은 걸리는데 한 번 쓰는 게 별로 오래 걸리지 않고
그리고 나중에 디버깅 잡을 때 디버깅 할 때 더 쉽게 코드가 뭔지를 알 수 있기 때문에 전체적으로 시간을 알 수 있기 때문에

저력하는 효과가 있어요
그래서 이런 것들은 매직 넘버는 쓰지 말고 변수화해서 쓰자
이건 중요하고
여섯 번째는 이거는 저도 최근 들어서 이제 모르겠어요 이게 왜 이런 사람들을 최근에 많이 봤는지 모르겠는데
if문 얘기할 거예요
if문을 하면은 함수 같은 데서 보통 뭐 값이 들어왔는데 if문으로 뭐 체크하고 이 조건 만족하고 저 조건 만족하고 저 조건 만족하면은 이런 행동을 해라
라고 할 때 사람들이 if문을 세 개를 이렇게 넣어요 하나 둘 셋
그러면 if문 때문에 들여쓰기 하는 거 인덴테이션 하는 게 세 단계로 가거든요
그럼 코드를 읽다 보면 어느 순간 if가 여기 나왔고 요 밑에 else가 나왔는데 이게 어떤 else인지 모르겠는 거야
그래서 이거를 일단은 옛날에 모든 걸 함수화하라고 했던 그 이상한 진영 내에서는 그 if문 안에 들어가 있는 코드가 뭐 세네 줄이 넣으면 그걸 함수로 만들어서 함수를 호출하는 식으로 얘기를 했었어요
근데 이거는 별개 얘기지만
그것도 함수를 유지 보수하는데 굉장히 복잡해지고 잘못된 조언이었고 이런 경우에 되게 간단한 해결 방법이 그 아닌 조건들을 찾은 다음에 그 조건이 안 되면 곧바로 함수에서 반환해 버리면 돼요
그래서 예를 들어서 이 함수에 들어왔을 때 조건이 이거 이거 이거일 때 이거를 해라였으면 함수를 짤 때 조건이 첫 번째 게 아니면 return 그럼 return 했으니까 첫 번째 조건은 없어졌잖아요
그럼 저는 두 가지 조건만 신경쓰면 되죠
그럼 두 번째에서 두 번째 조건이 아니면 다시 return
그러면 이제 한 가지 조건만 신경쓰면 돼요
세 번째 조건이 아니면 return
그러면 그 다음에 코드는 무조건 세 가지 조건이 아니기 때문에 이제 논리적으로 그냥 무조건 잘 작동하는 그런 조건인 거예요
이게 되게 중요한 게 뭐냐면 아까 말했던 사람들의 사고방식 사람들은 기본적으로 한 단계를 쭉 읽어오는 걸 좋아해요
근데 이 조건 맞고 저 조건 맞고 저 조건 맞고 세 가지가 맞다는 걸 판단하고 있는 순간
이미 헷갈려요
이 조건 아니고 저 조건이 되면 어떻게 되지? 이런 것들
조건이 세 개고 참 거짓이 있으면 2에 3승하고 같으니까 여덟 가지 조건이거든요 사실은
총 너무 복잡해져요
그거에 비해 아까 말했던 것처럼 일찍일찍 조건이 틀렸을 때 반환해 버리면 이거를 early exit이라고 하거든요
그 반환을 해 버리면 이런 문제들이 없어져요
프로그램을 실수 예방하는 데도 좋고 실수 시에도 빨리 잡을 수 있는 게 로직을 읽을 때 되게 빨라요
아 이거 아니고 저거 허용하는 데요?
저거 허용 안 하고 저거 허용 안 하고 그러면 이제 얘를 하는구나 이렇게 볼 수 있고
뭐 시간 낭비는 비슷한 거 같으니까 뭐 early exit이든 아니든 똑같은 거고
적당한 인간 수준에서 훨씬 잘 쓸 수 있는 거고요
그리고 뭐 문제 발생한 곳에서 잡는다? 아닌다?
이거는 디버깅이 조금 더 수월한 거 외에는 별게 없는 거 같아요
마지막 tdd
이것 때문에 이제 얼마 전에 되게 제 tdd 비디오도 안 본 사람들이 이제 tdd 한다면서
되게 약 팔고 다녔을 때 이제 제가 말하는 걸 잘 이해를 못했는데
아 tdd는 일단은 뭐가 장점이고 뭐가 단점인지는 얘기할게요
장점이 없는 건 아니에요
첫 번째 프로그래머의 실수를 예방할 수 있다
이거는 절반은 맞는 얘기예요
아 왜 절반이 맞냐
일단은 내가 테스트 코드를 쓰고 구현을 했기 때문에 그 테스트 코드가 돌지 않으면 구현에 뭔가 문제가 있다고 볼 순 있어요
근데 왜 절반이라고 얘기하냐면
tdd는 기본적으로 이제 구현자가 테스트부터 먼저 만드는 게 기본적이잖아요
그러면은 내가 이미 구현을 잘못할 정도로 비즈니스 로직을 잘못 이해하고 있는데
테스트 코드가 제대로 나왔을 리는 없어요
그러니까 비즈니스 로직에 대한 오해는 이미 내가 잘못하면 테스트에도 안 잡혀요
그게 아니라 내가 이해한 스펙대로 코드가 안 나왔을 때만 잡을 수도 있는 거지
근데 그거는 다른 방식으로도 쉽게 잡을 수 있는 거기 때문에
그 부분에서 정말 테스트 내가 이해한 로직대로 코드를 아주 못 짜는 사람들은 별로 없거든요
문제 생기고 뒤벙이하고 고쳐나가는 과정은 당연히 있지만
과연 그 데이터 머킹까지 하고 유닛 테스트 작성하는 만큼이 의미가 있을까라 할 정도로 가성비에서 안 맞아요
그럼 이거는 얘기는 뭐냐면 시간 낭비가 엄청 많아요
세 번째 문제인데
내가 테스트 코드를 작성하는데 드는 시간에 비해 내가 얻는 제품의 퀄리티 제품의 완성도는 솔직히 그렇게 높지가 않아요
TDD 유닛 테스트 기반으로는
그리고 그게 높여준다는 통계도 없고 TDD 기반으로 한 제품들이 훨씬 더 튼실한 것도 아니에요
현재까지 나온 것 중에는 TDD를 안 한 제품들이 더 튼실한 게 더 많아요 사실은
둘 다 하면 더 당연히 튼실하고 그건 어쩔 수 없지만
그래서 일단은 실수를 막을 수 있다 절반
그리고 세 번째 시간 낭비하지 않기는 최악이다 사실은
실수 시 최대한 빨리 잡는다 이 장점은 있어요
제가 아까 말했듯이 테스트 코드에서 잡을 수 있는 실수를 했을 때는 빨리 잡을 수 있어요
근데 그 문제가 실제 발생하는 문제의 절반도 안 될 거예요 기본적으로
그럼 세 번째는 아까 안 되고 얘기했고
적당한 인간의 지적 수준에 쓸 수 있냐 이것도 되게 재밌는 건데
내가 이해하는 수준에 쓸 수가 있어요
근데 이 문제가 뭐냐면 내가 아무리 이해하는 수준에서 테스트를 써봐야
그게 정말 비즈니스 로직에서 이해하는 테스트 수준은 아니에요
그래서 정말 제대로 된 프로그램이라면
문제는 유닛 코드를 프로그래머가 짜는 게 아니라
누군가가 제3자가 테스트 플랜을 잘 만들고 그 테스트할 수 있는 계획이 있고
그걸 자동화할 수 있다면 더 좋고
그리고 이제 TDD의 장점이라고 하는 것 중에 또 하나가
스펙이 일찍 나온다
왜냐하면 테스트 플랜을 만들기 때문에 테스트 코드를 만들기 때문에
그만큼 어떤 스펙을 만들지에 대한 고민을 많이 할 수밖에 없어요
그러면 그런 스펙 나오는 건 의미가 있는데
이거는 솔직한 얘기로 TDD가 아니어도 이걸 제대로 하면 되는 거예요
스펙 제대로 뽑고 테스트 플랜 제대로 나오면 되는 거예요
그 테스트 플랜이 굳이 유닛 테스트로 돌릴 이유는 없어요
그러면 그게 말했던 인간의 지적 수준에 쓸 수 있냐라는 건
자가 당착적으로 쓸 수 있다라는 생각은 해요
근데 정말 이게 제품에 굉장히 큰 도움이 되냐라고 보면
다른 테스트가 더 큰 도움이 된다라고 얘기할 수밖에 없어요 저는
그래서 그런 의미에서 좀 그게 있고
그리고 또 하나가 문제가 뭐냐면
유닛 테스트는 기본적으로 내가 짠 테스트를 내가 짠 코드가 패스하는 개념이에요
그렇다면 나중에 만약에 코드에 문제가 나왔을 때
다른 기능이 들어왔을 때 이 코드가 망가졌을 때
어떤 일들이 일어나냐면
원래 유닛 테스트를 만들어 놓고 그 코드를 패스한 사람 있죠
그 사람들이 약간 자기방어적이 돼요
나는 내가 쓴 코드 다 테스트했고 다 패스했기 때문에 내 코드는 괜찮다
네가 지금 뭔가를 바꿔서 고장이 나는 거니까 네가 가서 고쳐라
이런 식의 솔직히 약간의 자기방어적이 되는 개발자들이 이 시스템에서 조금 나와요
그래서 어찌 보면은 이제 좀
제가 이게 광역 어그로는 아닌데
좀 약간 실력이 좀 많이 모자란 분들이 TDD를 굉장히 좀 선호하는 경향들이 있어요 사실은
아닌 사람들보다
그 이유는 제가 볼 때는 그런 자기방어적인 수단도 있기 때문이 아닌가라는 생각은 해요
그래서 뭐 이건 광역 어그로는 아니고
그냥 제가 주변의 통계를 봤을 때 좀 그렇더라는 얘기 정도로 생각을 해주시고
뭐 문제를 발생한 곳에서 잡는다는 다섯 번째 원칙은 일단 뭐 어쨌든 간에 충족을 하죠
TDD를 다시 얘기를 하면은 실수 시 최대한 빨리 잡는 거
그리고 문제 발생하는 곳에 잡는 거는 굉장히 좋은 방법이긴 하고요
실수 예방을 하는 차원은 의문스럽고
적당한 인간 수준에서 쓸 수 있냐
뭐 TDD 수준에서는 되는데 실제 제품의 퀄리티를 높이는 데에서는 아닐 가능성이 높고
그리고 가장 큰 문제 아 그리고 아까 말했듯이 자기방어적인
자기를 방어하는 요소로 잘 쓸 수 있는 계기가 되는 것도 있어요
그리고 가장 큰 문제는 시간 낭비가 너무 크다
그럼 이것보다 나은 방법이 뭐냐
그러면 전에 비디오에서 엄청 많이 말했어요
자동화 테스트를 해라
스모크 테스트 해라
엔드 투 엔드 테스트 해라
인테리어션 테스트 해라
모든 기능이 도는지 제품단에서 확인을 하고
거기서 문제가 생기는 것만 고쳐도 일단은 충분하다
단 이 제품들이 사람의 생명에 영향을 미치거나
이제 이거 잘못해갖고 핵미사일 날아가거나 비행기 떨어지거나
뭐 의료쪽 군사쪽 이런 쪽에서는
당연히 오토메이팅 테스트하고 스모크 테스트하고 인테리어 테스트도 하지만
그 추가적으로 유닛 테스트까지 하면서
시간을 4배로 많이 처먹고 5배로 많이 써먹어도
인간을 죽일 수는 없기 때문에 그 정도의 노력은 들일만 하다
라는 건 맞아요
근데 많은 개발자들이 그렇게 중요한 소프트웨어를 만들지 않고 있거든요
그 상황에서 모든 거에 TDD가 들어가고
모든 거에 테스트 코드를 쓰겠다고 하는 순간
아마 본인의 효율성이 엄청나게 떨어질 거예요
제품 만드는 속도 자체가
그리고 그 순간에 그렇게 되면 될수록
본인의 입지가 좀 애매해지는 부분도 있을 거예요
그래서 TDD가 만능은 아니다
TDD가 장점은 있지만 이렇게 많은 장점이 있고
그래서 모든 거를 TDD로 가는 사람들
무조건 TDD로 해야 된다고 하는 사람들이 요즘 약 파는 사람이 되어갖고
그리고 이제 그런 거 한다고
막 하면 좀 생각 없는 개발자 얘기 많이 듣거든요
그 예의가 그거예요
TDD가 한 번 확 인기를 끌었을 때 우르르 갔다가
다들 이제 회사 돈 낭비하고 회사 시간 낭비하고
이런 꼴들이 좀 나서
그래서 뭐 그 정도
그래서 7가지 말했어요
거의 40분 동안 말했기 때문에 다음 비디오 없습니다
저는 40분 얘기하면 비디오 많이 만들기가 힘들어요
그래서 정리를 하면은
되게 빨리 정리할게요
코딩을 이제 방어적인 코딩을 어떻게 하냐 얘기를 한 거예요
그리고 저는 방어적인 코딩이라는 게
자기 방어가 아니라 이제 프로그램이 문제 없이
실수 나오면 빨리 잡고 버그 있으면 빨리 잡는 쪽
그런 걸 이제 방어적이라고 생각을 해요
그렇다면 저는 5가지 원칙을 고수할 수밖에 없는데
프로그램을 실수 예방할 수 있는 거
실수할 때 최대한 빨리 잡는 거
시간 낭비하지 않는 거
방어적 코딩을 하기 위해서 시간을 너무 쓰지 않는 거
그리고 인간의 지적 수준에서 누구나 쓸 수 있는 거
프로그래머 정도라면은
그리고 문제가 발생할 때 바로 잡을 수 있게 해주는 거
5가지 원칙이고
그 원칙에서 좀 요즘 잘못 쓰고 있는 것들
잘못 쓰고 있는 것들 아니면 좀 베스트 프랙티스
7가지를 말했어요
exception
최대한 쓰지 말고 경계에서만 써라
그 대신 정적 뭐 분석이라던가
뭐 뭐 그런 거를 더 해라
assert를 쓰던가
그리고 DI
dependency injection
가능하면 쓰지 말아라
써봐야 생각보다 도움이 안 된다
그 DI로 해서 얻을 수 있는 그 뭐 코딩 30초 추가로 안 할 이득 별로 없다
세 번째
스트링과 이념이 있으면 반드시 이념을 써라
스트링은 쓸 가치가 없다 그 상황에서
그리고 네 번째
널 처리하지 말아라
코드는 기본적으로 널이 반환 안 하고 널 매개변수를 받지 않는 그 가정으로 써야 되고
널을 정말 써야 될 때는
매개변수나 함수 이름에 오와 널 이걸 붙여서 널을 반환하거나 받을 수 있다는 거를 얘기를 해주자
다섯 번째
매직 넘버 절대 쓰지 말아라
쓸 이유 자체가 없다
여섯 번째
if문이 복잡하게 indentation 들어가면은 읽기 어려우니까
그냥 아닌 조건들 빨리 판단해서 얼리 엑싯 해버려라
일찍 일찍 반환해버리는 게 최고다
그리고 마지막 tdd
정말 사람을 상대하고 이제 뭐 목숨이 달린 이런 부분에서는
당연히 해야 되는 거 더 문제 하나 더 잡아야 되니까 좋지만
제품의 퀄리티 자체는 일단은 테스트 플랜이라던가 스펙이 훨씬 더 좌지우지하지
유닛 테스트가 좌지우지하지 않는다
그리고 이 테스트를 하기 전에
자동화 테스트 api 자동화 테스트 스모크 테스트 n20 테스트 인테리어 테스트
붙어 하는 게 훨씬 더 효율적이다
그거 다 하고 나서 정말 추가로 테스트를 눌 이제 그 여력이 있으면 유닛 테스트가 더 효율적이다

그거 아니면은 이거 한다고 시간 낭비하는 게 오히려 낭비일 수도 있다
전 그렇게 해서 일곱 가지를 정리를 할게요
40분 찍었으니까 아 이제 끊도록 하고요
즐겁게 보셨다면은 이제 구독을 눌러주시면 저한테 많은 도움이 됩니다
구독 75000명 찍으면은 무슨 트로피 준대요
그래서 찍어보고 싶어
예 포프였습니다
