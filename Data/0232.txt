C#을 주로 쓰는 ASP.NET을 주로 쓰는 웹회사를 전에 다녔었거든요
요 바로 지금 전에 회사에
거기서 제가 좀 맘에 안 들었던 게
누계 패키지였어요
그 누계 패키지가 뭐 패키지 시스템이 구려서 맘에 안 드는 게 아니라
이 웹 쪽에서 누계 패키지를 잘못 쓰는 거에 대한 좀 불만이 많았어요
그니까 누계 패키지란 개념이 솔직히 이제 C 쪽에서 보면은
외부 라이브러리거든요
그래서 외부 라이브러리 가져와서
뭐 링크 걸어서 한다 이건데
뭐 외부 라이브러리도 DLL로 링크 거는 법이 있고
라이브러리 링크 거는 법이 있잖아요
근데 이제 DLL로 거는 거랑 똑같다고 봐야죠
그러면 DLL이 바뀌었을 때
C샵은 장점이 이제
C에서는 좀 신경 써야 될 부분이 있는데
C샵에서는 DLL을 그냥 바꿔놓는 것만으로
이제 그 새로운 라이브러리 버전을 바꿀 수 있다 그런 장점이 있죠
뭐 그것도 약간의 제한이 있지만 C보다는 제한은 없어요
그래서
이러면 이제 누계 같은 거는 그래서
외부라이브러리에다가는
외부라이브러리를 받을 때 그렇게 간단하게 하면은 뭐
실제 컴파일할 때 그냥 새 버전 이렇게 업그레이드 한 다음에 받아갖고
그냥 컴파일하면 되니까
패키지 관리 시스템이 되게 좋은 거였죠
근데 제가 좀 짜증났던 부분이 뭐였냐면
그 회사에서 저희가 만드는 플랫폼이 있었어요
웹 머천다이징 플러스 커스터마이징
뭐 다 되는 플랫폼이었는데
그 플랫폼에 아무래도 작은 부분들이 있잖아요
내부에 뭐 플랫폼이라던가 뭐 프로젝트 카트 오더 막 이렇게
그거를 다
다 프로젝트를 분리해서 이걸 누겟으로 만든 거에요
그래서 그 누겟을 받..
메인 웹사이트 뭐 홈페이지 샵 가게 웹사이트나
저희 렌더링하는 서버 웹사이트
이런 거에서 그 누겟을 다 받아다가
이제 컴파일하는 거였는데
문제는 이게 굉장히 액티브하게 개발이 되는 도중이다 보니까
뭐 새로운 기능을 넣으려면
플랫폼에 넣고 여기에 넣고 렌더 서버도 같이 넣어야 돼요
그러면 저희가 개발을 할 때
플랫폼 코드 바꿔서
이거를 커밋을 한 다음에
빌드 서버에서 누겟 패키지를 구운 다음에
다시 새 버전을 받아 갖고 개발을 해야 되는 이런 상황이었고
이 상황에서 만약에 버그가 나서 어디가 고장이 난다
그럴 수도 있잖아요
뭐 데이터가 이상하다
그러면 디버그를 하기 위해서
이 누겟 자체에 pdb를 안 넣어줬기 때문에
그건 실수인 거 같은데
디버그는 곧바로 안 돼요
그러면 버그 났을 때 일단 그래 멈추고
뭐 소스 서버도 없었고
그건 뭐 인프라의 문제겠지만
소스 리포트..
리포가 아니라 그 서버 있잖아요
소스를 버전별로 모아 갖고
어떤 dll, pdb 파일 넣어 놓고
소스 버전 넣어 놓고
그래서 언제든 네트워크 드라이브로 이렇게 액세스 되게 가능하거든요
그것도 없었고
심볼 서버도 없었고
그래서 그때마다 막 그 프로젝트를 로컬에서 빌드해서
dll을 매뉴얼하게 카피를 해서
다시 리포로 한 다음에 테스트를 해야 됐거든요
그래서 저는 그게 너무 싫어서
그 팀을 제가 넘겨받았을 때
다음 프로젝트에서는 모든 걸 합쳐 갖고
한 솔루션을 합쳤어요
솔루션이 다 프로젝트로
근데..
이게 가능했던 게
저희가 아까 말했던 새로운 누겟 패키지도 있잖아요
이게 저희만 거의 쓰는 거예요
그러니까 저희만 쓰는 누겟 패키지고
저희 팀 이 솔루션 외 밖에는 전혀 안 쓰는 패키지였거든요
그래서 누겟이 솔직히 될 이유가 없었어요
그러니까 누겟의 패키지에 대한 개념 자체를 좀 잘못 잡은 사람들
아니면은 아직 필요하지 않은데
그냥 미래에 필요하겠지라고 생각해서
괜히 복잡하게 만들어 놔서 문제가 됐던 거 같은데
뭐 그냥 뭐 뭐랄까
도메인을 가르는 기분이라면
그냥 프로젝트를 가라는 것만으로 충분하거든요 사실은
그래서 그거를 넘어서 너무 오버 엔지니어링을 했다고 생각을 했어요
그래서 근데 문제는 이게 누겟으로 가든 CS 프로젝트로 가든
결과적으로는 그 제 웹솔루션 안에
DLL 파일이 각 프로젝트마다 하나씩 들어오잖아요
그럼 여기 성능상의 문제가 조금 있긴 하더라고요
그 저도 그래서 좀 찾아봤는데
그 뭐 마크 그래 이름 까먹었어
그 스택 익스체인지..
스택 오픈..
플로우 쪽에 유명하신 분이 있는데
그 회사 사장이 되시는 분
그분 말에 따르면 이제 DLL이 많아질수록 무슨 속도가 느려진다
그러면 이런 라이브러리 DLL을 하나로 합치는
또 무슨 스크립트가 있다나 무슨 프로그램이 있대요
제가 이름을 까먹었는데 엔젠이라 그랬던 거 같아요
그걸로 해서 합칠 수 있다
그럼 빌드를 한 다음에 포스트 빌드 스텝으로 합쳐서 할 수도 있다라고 하는데
저는 기본적으로 커스텀 빌드 스텝이 들어가는 걸 되게 싫어해요
왜냐하면 에러 메세지도 그렇고
모든 게 이렇게 잘 눈에 띄지가 않거든요
그래서 그거는 좀 별로였는데
그러다 갑자기 최근에 생각이 들었어요
그리고 실제 지금 제가 하고 있는 웹 프로젝트를 그리로 옮겼고
자마린을 최근에 제가 좀 했잖아요
자마린 하는 동안 자마린에서 안드로이드하고
iOS하고 서로 간에 이제 어떤 동일한 라이브러리를 공유하려면
포토볼 CL CL이 뭐지 클라이언트 라이브러리인가 보다
PCL로 만들거나 쉐어드 프로젝트 새로 나온 건데 이걸 만들어도 된다라고 나왔어요
그래서 쉐어드 프로젝트를 그때 읽은 게 있어서 그걸 좀 더 팠죠
그때 좀 자마린 쪽에서 쓴 것도 있고
쉐어드 프로젝트 개념이 뭐냐면
이거 일단 좋아요
그러니까 특정 상황에 좋아요
쉐어드 프로젝트가 뭐냐면
음 어떻게 말해랄까
C에서 보면 스태틱 링킹하는 거
DLL 없이 라이브러리 링킹하는 거와 똑같아요
그래서 쉐어드 프로젝트가 뭐냐면
프로젝트를 만들면 이 자체로는 컴파일도 안 되고 아무것도 안 돼요
그냥 그 쉐어드 프로젝트라고 프로젝트 안에 있는 CS 파일 목록이 있는 게 전부고
그리고 네임스페이스 기본 네임스페이스가 뭐냐
왜냐면 새로운 파일 추가할 때 네임스페이스 추가해줘야 되니까
그 정도가 끝이에요
그리고 모든 파일이 리스트가 돼 있는 거죠
그냥 자기 그래서 예를 들어서
어떤 예를 들까
뭐 웹 쪽이라면 이제 카트 프로젝트가 있다
그럼 카트 쉐어드 프로젝트를 만들어 놓고
이렇게 카트를 만들어 놓으면
카트에 필요한 코드가 다 있고요
그럼 코드가 컴파일이 안 되잖아요
그러면 이거를 나중에
ASP.NET 같은 경우에는 쉐어드 프로젝트 코드를 가져올 수는 없어요
그러면 일단 그 다음에 이제 클래스 라이브러리를 만드는 거예요
예를 들어서 제가 웹 사이트를 샵이라고 한다
그러면 shop.library 이렇게 하고
그걸 이제 CS 프로젝트 클래스 라이브러리를 만든 다음에
거기서는 이 쉐어드 프로젝트를 레퍼런스 할 수가 있어요
그럼 레퍼런스 하면은
이 shop.library를 컴파일 할 때
쉐어드 프로젝트 코드를 같이 컴파일 해 주는 거예요
그래서 같은 shop.library 파일 DLL을 같이 넣어줘요
한마디로 제일 간단하게 생각하면
파일 복사한 다음에 거기서 컴파일 한다던데
옛날에 CS 프로젝트 파일 클래스 라이브러리 파일에서는
그거를 이제 파일을 하나하나랑 오른쪽 버튼 눌러서
링크로 파일 추가하기 이 기능이 있었잖아요
그거를 그냥 프로젝트 단위로 바꿔 준 게 전부예요
그래서 그렇게 해서 한 다음에 DLL이 나왔는데
그러면 ASP.NET 샵 프로젝트 ASP.NET 프로젝트에서는
이 shop.library 하나만 포함하면은 도는 거죠
이게 장점이 뭐냐면
이렇게 되면은 제가 만약에 제 코드들을 도메인별로 나눠갖고
프로젝트를 100개를 쪼개 놨어도
최종적으로 컴파일되는 DLL 라이브러리는 하나고
shop.library 처음 시작하니까
샵 웹 프로젝트가 처음 런칭할 때
써야 되는 라이브러리는 DLL이 하나기 때문에
그만큼 로딩톱이 되니까요.
그리고 또 장점이 뭐냐면
이렇게 크게 크게 DLL을 하다 보면은
너무 DLL이 많아지니까 적당히 적당히 또 합치거든요
근데 샵이 있고 만약에 여기서 라이트 샵이 있어
근데 여기서는 여기서 쓰는 기능 중에 절반만 필요하거든요
예를 들어서
그러면은 그 절반만 쓰기 위해서는
좀 DLL 파일 작게 하기 위해서
프로젝트 두 개 나눠갖고 DLL 두 개 만들기도 되게 복잡하고
근데 여기서는 쉐어드 프로젝트를 몇백 개로 자르던 간에
컴파일되는 유닛은 하나니까 상관이 없는 거예요
그리고 굉장히 비주얼 스튜디오 런칭하는 것도 빠르고
실제 웹 런칭하는 것도 빠르더라고
파일 크기가 작으면 작을수록
그래서 예전에 한참 욕먹던 ASP 단대에서는 너무 느리다
런칭이 느리다
이런 거를 좀 해결할 수 있을 것 같고
제가 지금 말씀드린 이렇게 쓰는 방법
이게 유일한 건 아니죠
사실은 자마린 쪽에선 중간 라이브러리를 안 만들어요
그냥 안드로이드 프로젝트에서 쉐어드 프로젝트 링크 한 다음에
그걸 컴파일하죠.
이런 방법은 자바스크립트 진영에 쓰는 번들링 개념 있잖아요
자바스크립트 파일 여러 개 모아놓고 파일 하나를 합친 다음에
뭐 오피스케이터라고 그러나
그 코드 더럽게 만들어서 줄여버리는 거
그거 돌려서 JS 파일 하나 만들어서 로딩 빠르게 하듯이
그 개념하고 되게 비슷해요
그게 가능하더라고요
장점이 뭐냐면
제가 정말 좋아했던 게 뭐냐면
이게 일단 누계 패키지가 필요 없는 상황
그러니까
누계 패키지가 필요한 상황은 있어요
이 패키지를 만들었는데 여러 명이 쓴다
그럼 패키지 좋죠
쓸만해요
그리고 이게 만약에 웹으로도 줘야 된다
뭐 이런 거 좋아요
그러면 좋은데
저는 그런 상황도 아니고
대부분이 그런 상황이 아니어서
한 회사에서 적당한 규모의 회사에서 할 때는
제가 만든 라이브러리 제가 쓰는 경우가 많고
그리고 실제 중앙 라이브러리 팀이 있다면
걔네는 이미 패키지를 줘야 되고요
그래서 그거는 전혀 제가 말하는 방향으로는 안 돼요


그래서 그런 상황에서
시워드 프로젝트를 쓰면
도메인별로 가르기도 좋고
그리고 컴파일도 하나로 나서 좋고
그리고 또 하나가 제가 하면서 느낀 게
이게 도메인별로 가르라는 얘기를 좀 많이 하잖아요
이 프로젝트에서 저 프로젝트를 서로 참조하지 말고
데이터형이 비슷해도
여기 프로젝트에 쓰는 Rectangle 클래스랑
여기서 쓰는 Rectangle 클래스를 따로 만드는 이런 방식
그게...
자연스럽게 인폴스가 되더라고요
왜냐하면 옛날 같은 경우에 DLL 그냥 대충 박아놓고
이렇게 참조 참조 참조 하면 끝이거든요
근데 이거는 지금 어떻게 되냐면
제가 하다 보니까
예를 들어서 제가 라이브러리가 두 개가 있어요
클래스 라이브러리가
그리고 여기서 둘 다 똑같은
시워드 프로젝트 라이브러리를 쓴다고 해봐요
샵 아니 샵이 아니라 아까 카트
카트가 여기 둘 다 라이브러리에 들어갔잖아요
근데 어떤 웹사이트 프로젝트에서
얘네 둘 다를 쓰려고 그러면
컴플렉트가 나요
왜냐하면 아까 말했던 이거 복사하고
카피 앤 페이스트 한 다음에 컴팔 하는 개념이잖아요
그래서 어 여기 양쪽 둘 다 카트라는 애가 있어
그럼 컴플렉트하면서 못해 주겠어 이런 얘기를 해요
그래서 이런 cycle reference 관계를 좀
줄이게도 이렇게 좀
포스 인폴스를 해주는 것 같고 강요를 하고
그리고 이 share 프로젝트 끼리 있을 경우에
이 share 프로젝트가 A 가 있고 B가 있잖아요 예를 들어서
그러면 A가 B를 참조를 직접적으로 못해요
왜냐면은 아니 코드상으로는 돼요 컴파일이 안 되기 때문에
근데 만약에 요 라이브러리에서 이제 B를 쓴다
이 shared project B를 쓴다
그 상황에서 컴파일하면은 아 난 A가 누군지 몰라라고 나와요
그러면 이제 A를 다시 여기서 또 레퍼런스 할 거
둘 다 레퍼런스 해서 이제 써야 되는 거죠
그래서 그런 이런 이런 걸 따지면
약간 도메인 쪽을 많이 하시는 분들
도메인 드리븐 디자인 하시는 쪽은
shared project 하시면 되게 재밌어질 거 같아요
그래서 괜찮은 거 같아요
그래서 C에서 static linking
그거를 C#에서 하고 싶다
그러면은 shared project 굉장히 괜찮고요
그리고 개인적으로 쓰는 프로젝트 아니면 좀 작은 규모의 팀
내가 만든 라이브러리가 외부에 안 쓸 때 좋고요
그리고 제가 지금 또 생각이 든 거는
제가 이거는 어차피 Git이 발전하면서 바뀔 거라고 보는데
현재 Git을 리포 단위로 많이 쪼개잖아요
그러면 이제 뭐라 그럴까
그러면 나중에 솔루션 하나 할 때는 Git을 서브 모듈로 박아갖고
막 리포하고 이런 경우도 많잖아요
근데 shared project를 하면 좀 더 간단해지는 게
어차피 shared project는 그냥 파일 목록 리스트가 있을 뿐이니까
그 자체로 컴파일되는 유닛은 아니거든요
그러면 이걸 서브 모듈로 만들더라도 굉장히 괜찮아져요
이게 개념이 딱 맞아요
그냥 솔루션 파일은 언제나
프로젝트를 레퍼런스 하는 개념이잖아요
그 외엔 아무것도 없잖아요
그럼 메인 리포가 있고 거기에 솔루션 파일이 있어요
그리고 솔루션을 링크한 다음에
이제 서브 모듈일 필요도 없는 거 같아요 그 상황에서는
서브 모듈이 아니고 다른 폴더에 이 shared project가 다 클론을 한 다음에
어떤 배치 스크립트만 하나 만들어서
shared project 이렇게 링킹만 시켜주면
include로 그건 폴더 이름은 다 쉽게 바꿀 수 있으니까
그러면 그 순간 컴파일되는 유닛이 나오는 거예요
그래서 메인 리포가 배치 스크립트 하나 있어서
메인 리포 클론하고 서브 리포를 다 클론하고
그 다음에 링크로 연결해주기
아니면 서브 모듈로 해도 상관없고요
그러면 실제 shared project에 있는 리포 자체는
따로 바이너리가 나오는 것도 아니고 뭐 하는 것도 아니기 때문에
어차피 그 순간 컴파일을 하면은
이 모든 게 제 메인 DLL 하나 들어오는 거잖아요
shared project DLL이 아니라 다른 라이브러리 DLL
그래서 음 이 방법을 이용하면은
그냥 그렇게 잘게 잘게 쪼개고 합치는 것도 좀 되게 편할 거 같아요
저 개인적인 입장으로는 일반 클래스 라이브러리로 하는 것보다
맘에 굉장히 들어요 이게 라이트 웨이트고
아무리 DLL 파일이 새로 안 나오고
그거 고칠 때마다 그거 버전 업그레이드 해갖고
무슨 누게 패키지를 구해야 되나 이 고민 안 하는 것도 좋고
그래서 그런 거 같아요 물론
CS 프로지 파일로 해도 굳이 누게 패키지 안 구해도 되지만
뭐 결과적으로는 제가 좋아하는 게
아 그리고 그것도 있죠
그리고 이제 CS 프로지 파일로 하게 되면은
그 솔루션 그니까 제가 다른 라이브러리에서 이걸 쓰려고 할 때
그 .NET Framework 버전 바꿀 때마다
그 라이브러리 버전도 좀 생각을 해야 되고 뭐
프로젝트 뭐라 그럴까
타입도 있잖아요 포토볼인지 아닌지 그것 따라 또 되는 거 안 되는 거 있고 이런 것도 있고
그런 고민이 좀 적어진다는 거죠
그리고 되게 재밌는 거는
그 C에 보면은 if defined 이거면 코드 이렇게 하고
if 이거면 저거하라 이런 코드 있으잖아요 컴파일러 스위치
그게 돼요 shared 프로젝트에서
이거 어떻게 작동을 하는 거냐면 예를 들어서 A란 파일이 있고
여기에 if android 그리고 if ios 이렇게 들어가 있어 봐요
그럼 그 자체는 아무 의미가 없어요 얘는 컴파일된 애가 아니기 때문에
근데 그 이거를 포함하는 라이브러리 있잖아요
아까 말했던 클래스 라이브러리라던가 자마린 쪽에서 그냥 안드로이드 프로젝트라던가
그럼 안드로이드 프로젝트 빌드를 할 때
얘네는 기본적으로 define을 underscore underscore 안드로이드를 넣어주거든요
그러면 그거를 이제 이 shared 프로젝트에 있는 파일을 컴파일할 때
그 뭐야 디버그 컴파일을 하는 그 컴플레이션 플래그라고 하죠
그것 따라 코드를 둘 중에 하나 골라주는 거예요 그런 방법이 돼요
그래서 예전 같은 경우에는 무슨 뭐 그 뭐라 그럴까
추상화를 좀 잘못 이용해서 제가 되게 싫어하는 것 중에 하나인데
이게 폴리모피즘의 개념을 잘못 잡아서 이런 경우에는 인터페이스를 하나 만들고
각 플랫폼마다 implementation을 만든 거죠
뭐 뭐 이걸 device라고 한다면 i device 만든 다음에 device android device ios 쓰고
여기서 컴파일할 때는 device android 집어넣고
여기 쓸 때는 device ios에 쓸 때는 device ios를 넣는다
근데 실제 최종 컴파일된 유닛 컴파일된 그 유닛에서는
플랫폼 하나밖에 없거든요
인터페이스 하나 implementation 하나예요 이거는 잘못한 거예요
그래서 이거는 솔직한 얘기로 어떻게든 라이브러리를 share하겠다는 생각에
인터페이스만 넣고 뭐 이렇게 하자 뭐 이런 식으로 이렇게 됐던 것 같은데
shared 프로젝트라면 그 문제가 없어져요
그냥 인터페이스 implementation 하나로 거기서 합쳐버리고
그 컴파일러 따라 그러니까 어떤 프로젝트가 이거를 쓰는지에 따라
안드로이드하고 ios 컴파일러 스위치가 가능하기 때문에
저는 그러면은 그냥
인터페이스의 남용을 막고 오히려 깔끔하게 코드가 나올 수 있는 계기도 돼요
뭐 코드를 읽을 땐 좀 더러울 수도 있죠
아무래도 if def가 있으면 근데 뭐 그거는 이제 코드를 어떻게 잘 구현
뭐랄까 organization을 하냐의 문제인 것 같기도 해요
아니면 이제 C#에는 파셜 클래스도 있기 때문에
솔직한 얘기로 파셜 클래스 하나 파놓고 if def를 하나 해버리고 ios 거는
하나는 안드로이드 해도 되거든요
그러면은 그냥 파일 하나가 자체가 이게 안드로이드 파일?
이게 ios 파일이 되니까 그건 좀 더 깔끔하게 관리가 가능하죠
그래서 그런 여러 가지 방법들이 있어요
근데 저는 shared project 굉장히 괜찮다고 보고요 지금
번들링의 개념이고 그리고 그거 통해서 이제 저도
제가 하던 프로젝트를 막 할 때마다 그거예요 사실은
예전에 하던 게 프로젝트 또 추가해야 돼 아 이거 너무 많아지는데
이 고민을 했는데 지금은 그냥 로지컬하게 프로젝트로 그냥 추가해버려요
CS 프로 그러니까 shared 프로젝트로 그리고 필요한 거만 레퍼런스하고
그래서 좋은 것 같아요 모듈화해도 좋고 옛날에 C에서 라이브러리 나눠서


막 서클러 레퍼런스 못할 때 그렇게 좀 해놓으면 모든 그 참조가
이렇게 트리 식으로 내려오잖아요 이렇게 원형으로 가는 게 아니라
그래서 그런 방식으로 좀 인포리스는 굉장히 좋고
라이브러리 구조에 대해서 좀 더 생각을 하게 되고
그래서 개인적으로는 추천해드리고 싶고 모든 거에서 바꿀 수는 없어요 분명히
아까 말했던 몇 가지 문제가 있기 때문에 그래서 봐서 쓸 수 있을 법한 부분에
한 번씩 써보시길 바래요 재밌을 거예요
네 포프였습니다
