안녕하세요, 포프입니다.

제가 예전에 GUID7 얘기를 하다가 '제 입장에서는 이 랜덤한 알고리즘들이 끈적한 느낌을 준다'라는 말을 했어요. 그거에 대한 얘기를 조금 해볼 건데, 특히 제가 얘기할 것들은 아마 암호화폐, 블록체인 쪽의 방식들과 GUID 쪽 방식들이 될 것 같아요. 일단은 그 비디오에서 잠깐 얘기했지만 GUID을 우리가 기본적인 PK, Primary Key로 주로 많이 사용하게 된 이유들이 대규모 분산 시스템에서는 RDBMS, 관계형 데이터베이스 시스템, 걔가 Identity Column으로 자동으로 Int를 증가시켜 줄 때, ID를 하나씩 증가시켜 주면서 '이게 새로운 Int야'라고 해주기가 좀 어려운 분들이 있다, 하지만 연속되는 Int를 한 명이 책임져 주고, 한마디로 Lock 걸어 놓고 하는 거죠? 이게 크리티컬 섹션처럼. 그런 게 가장 좋아요. 중복 없이 책임져 주는 애가 한 명 있으니까. 그게 조금 애매할 때 랜덤한 숫자를 생성해야 하는 건데, 그 랜덤이 충돌하지 않게 만들려면 최대한 비트 수가 크면 클수록 좋은 거죠? 범위가. 32비트는 제가 개발환경 하면서도 여러 번 Hash 충돌을 봤고, 64비트는 웬만한 경우에는 Hash 충돌이 없지만 그 데이터에 바이트가 0이 많으면 Hash 충돌이 있을 수 있고, 그 이상으로 늘어난 128비트짜리 데이터에서는 그 충돌이 없을 거다, 그리고 그걸 아마 확률적으로 여러 가지 증명을 해놨을 거예요. '확률이 이거밖에 안 된다.', '거의 충돌을 하지 않는다'는 걸로 사용해서 랜덤 하게 만드는 건데, 이게 확률적인 거기 때문에 '절대 충돌이 안 난다'는 보장이 없죠? 그래서 충돌은 할 수가 있어요.

근데 대규모 분산 시스템이 필요 없다면 당연히 DB에서 싱글턴으로 INT 하나씩 증가시켜 주는 방식이 당연히 좋은 거고, 그게 아니라면 그래 확률적으로 믿고 쓰지만, '그럼 충돌이 생기면 어떡하지?'라고 하지만, 그런 경우에는 일반적으로 언젠가는 그 데이터를 DB에 저장하니까, DB에 저장하는 순간 중복되는 문제가 생기면서 '똑같은 PK를 저장할 수 없다'고 나오면서 오류가 나겠죠? 그러면 그때 한번 개발자가 봐서 고치면 되는데, 고쳐본 사람이 있는지 모르겠어요. 저는 없어요. 정말 희박한 가능성이긴 한데, 확률적으로 희박하지만 아무리 확률이 몇십억 조분의 1이어도 갑자기 한번 시도할 때 나올 수도 있는 거거든요? 그래도 '문제가 생기면 수동적으로 고칠 수 있으니까 큰 문제는 아니다.' 그렇게 볼 수 있죠? 또 비슷한 개념이 컴퓨터 공학에서 뭐가 있냐? 비밀번호 저장할 때 ID, 비밀번호 저장하잖아요? 비밀번호를 옛날에 평문으로 많이 저장했어요. 그리고 그게 문제가 됐을 때 암호화 해 갖고 다시 비암호화해서 
사용자가 넣는 비밀번호랑 같은지 확인도 했어요. 하지만 DB가 털리고 암호화를 깰 수 있으면 암호가 노출되는 거잖아요? 그래서 그걸 막기 위해 이제 Hash로 저장을 많이 하죠. 이제 내 DB에는 Hash가 저장돼 있고, 사용자가 들어와서 ID를 치고 어떤 비밀번호 넣었어요. 그 비밀번호를 Hash로 바꿨어요. 이 두 Hash가 같으면 '맞는 사람이겠거니'하고 통과시켜 주는 거예요. 비밀번호가 같은 건 의미가 없어요. Hash만 같으면 돼요. 근데 엄밀히 말하면 Hash도 충돌 가능성이 있잖아요? 그러면 다른 비밀번호는 없는데 이게 같아서 통과될 가능성도 있는 거예요. 그러면 이제 그것도 좀 약간 끈적한 느낌이 들죠? '확률적으로 맞을 확률이 이렇게 높다'는 거고, 당연히 다른 두 개의 값이 같은 Hash율을 만들 수도 있는 건데.

근데 이건 이렇게 생각하면 조금 편해요. 이게 GUID는 아까 실수하면 DB에서 저장이 안 되는 거잖아요? 얘는 다른 값을 넣어도 맞기만 하면 로그인되는 거예요. 그러나 최소한 얘가 집어넣는 정보는 비밀번호만이 아니라 실제 평문으로 비교하는 사용자 ID도 들어와 있잖아요? 그래서 정말 아무 생각이 없는, 남을 해칠 생각이 없는 해커가 아닌 일반적인 사용자가 ID를 넣고 그게 운 좋게 잘못 패스워드를 넣는데 맞는다고 해도 이거에 대한 그 사용자한테 손해는 없는 거예요. 이게 ID가 없고 패스워드만 넣어서 로그인되는 시스템인데, 패스워드를 로그인했는데 내가 아니라 다른 사람 로그인이 되어버리면 그건 문제가 되지만, 이건 해커가 아닌 이상은 문제는 없어요. '해커가 오면요? 이 사람 ID를 넣고 비밀번호 넣고 들어 올려고 그러면요?' 그러면 그게 한 방에 막기는 되게 어렵겠죠? 그러면 여러 번을 시도해서 Brute Force를 넣는 건데, Brute Force로 패스워드 평문을 만들어서 넣는 방식이나, Hash 코드를 매치해서 넣는 방식이나 결과적으로 굉장히 많은 시도를 해야 할 거예요. 그러면 그 시도를 하는 동안에 로그인하는 순간 시스템에 가서 네트워크 통신을 쏘는 방식이기 때문에 굉장히 많은 값을 여러 번 시도할 수도 없고, 몇 번 실패를 하면 '너무 많이 틀렸는데? 좀 쉬어. 10분 뒤에 해', '20분 뒤에 해.' 이런 식으로 Rate Limiting을 넣을 수 있기 때문에, Hash로 인한 불안함을 막을 수 있는 다른 부차적인 방식들이 들어온 거죠.

그럼 이제 그다음 문제는 사실은 이 암호화폐 쪽에 있어요. 암호화폐 중에 가장 유명한 Bitcoin, Bitcoin 얘기를 들면 Bitcoin은 지갑 주소가 Public Key이고요 그 Public 키는 보통 제가 가지고 있는 Private Key, 제가 정확히 몇 비트인지 기억이 안 나는데 이더리움은 256비트였던 것 같고, 그 256비트짜리 데이터에서 Public Key를 만들어요. 그래서 이 Private Key가 있으면 Public Key가 언제나 만들 수 있어요. 지갑 주소는 나와요. 그리고 이 지갑 주소에서 돈을 옮기거나 뭐 할 때 이 private 키를 내가 잘 써 갖고 암호화해서 보내면 되는 건데, 이 Private Key는 남한테 절대 공개를 하면 안 되는 거예요. 이것만 있으면 누구든 내 지갑에 접근할 수 있는 거예요. 그래서 이건 공개 안 하고, Public Key는 외부에 있기 때문에 여기에 누가 돈을 보내든 뭐하든 할 수 있는 거예요. 내가 돈을 받을 수 있어도 돈을 보낼 수는 없는 거예요, Private Key 없이는. 그렇게 되는 방식이거든요? 근데 이것도 결과적으로는 다른 Private Key 두 개가 하나의 Public Key를 만들 수 있는 가능성은 있어요. 그리고 이게 누가 중앙에서 책임져 주는 게 아니에요. '니가 정확히 이 사람이 맞으니까...'하는게 아니라 Private Key만 맞으면 다 할 수 있는 거예요. 그래서 이게 생각을 해보면 정말 재수가 없으면 다른 사람이 가지고 있는 Private Key로 내가 지금 Bitcoin. 첫날부터 파 갖고 모아놓은 3,000조를 가져갈 수도 있는 이상한 확률은 있어요. 그래서 그 여전히 끈적한 느낌이 있어요.

그리고 이 끈적한 느낌은 여기서 전부가 아니라, 요즘 양자 컴퓨터 막 펌핑질을 하니까 거기서 얘기 나오잖아요? '양자 컴퓨터가 나오면 블록체인이 깨질 거다.', 'Bitcoin이 깨진다.' 이런 얘기. 솔직히 어느 정도는 맞는 얘기긴 해요. 왜냐하면 생각해 봐요. 이 아까 말했던 Hash를 비교하는 남의 서비스로 뭔가를 로그인하는 방식이 아닌, 이미 공개된 Public Key를 나오게 하기 위해서 Private Key를 내가 랜덤으로 만들고 여기서 Public Key를 계속 만들어 볼 수 있어요. Brute Force 거든요? 그리고 그게 매칭이 됐다는 건 내가 딴 서비스를 통해서 볼 이유도 없어요. 그냥 Public Key가 있으니까 이 숫자 나올 수 있는 Private Key를 계속 시도를 해보는 거예요. 이 시도할 수 있는 컴퓨터 속도가 어마어마하게 빨라진다? 양자 컴퓨터가 여태까지 일반적인 CPU로는 너무 오래 걸렸던 그런 알고리즘들을 되게 빠르게 돌릴 수 있는 것들이 있거든요? 그게 정확히 Bitcoin 알고리즘이 거기에 속하는지 제가 확인을 안 해봤는데, 이런 Public Key, Private Key가 그쪽에 속한다는 얘기를 제가 들었던 것 같아요. 그래서 그게 되면 '누군가 그걸 가진 사람이 어마무시하게 이거 돌려서 깨버리고 Private Key로 손을 넣은 다음에 그걸로 Public Key에 있는 돈을 가져갈 수도 있다'는 무조건 나오죠. Rate Limiting이 안 돼요. 그게 문제인 거예요. 물론 양자 컴퓨터가 더럽게 비싸서 그 양자 컴퓨터를 사기 위해서 모으는 돈이 어마무시 들겠지만, 양자컴퓨터가 만약에 싸진다? 한참 걸릴 일이지만, 그러면 그 문제가 생길 수 있다는 거죠. 그럼 그때까지 당연히 Bitcoin 알고리즘도 바뀌고 뭐하고 해서 조금씩 나아지긴 할 거예요. 근데 그 Bitcoin 알고리즘이 바뀌고 뭐 한다고 해서 예전에 가지고 있던 원래 사용자들이 모두 다 새 방식으로 마이그레이션을 곧바로 하지 않겠죠? 마이그레이션 하기 위해선 자기가 가진 Private Key를 보여주고 해야겠죠? 그러면 예를 들어서 어떻게 됐는지 모르지만 우리 세상에 없을 거라고 많은 사람들이 믿고 있는 저 나카모토 아저씨의 그 어마무시한 돈이 들어있는 Bitcoin, 가장 먼저 깨는 사람이 '내가 Private Key 있으니까, 이거 내 거야.' 그리고 마이그레이션 한 다음에 거기서 가져가고 끝나는 거잖아요? 이런 여러 가지 Implication이 있어요. 근데 이 모든 게 중간에서 누가 믿고 책임져주는 서비스가 없어서 그런 거예요. '이걸 중앙화 되는 걸 탈피해야지', '이제 완벽히 분산화된 무언가를 만들어야지' 그래 놓고 '여기에 화폐를 만들어야지' 그러고 만들어 놨는데, 이게 수학 알고리즘으로 만들었는데, '지금은 못 깬다' 그러는데, 나중에 시간이 지나면 깨질 수 있거든요? 확률적인 거기 때문에. 그래서 괴로운 거죠. 그 시스템의 아마 가장 큰 취약점은 거기일 수 있는데, 그런 날이 오기까지가 한참이 걸릴 수 있다, 근데 한참이 걸리든 말든 그때까지 그거에 가치가 있다면, 그런 암호화폐 쪽의 가치가 어마무시하고 더 커진다면 잠자고 있는 지갑들은 어떻게 할 거냐? 그런 문제들이 생기는 거예요. 그래서 '양자 컴퓨터를 살 수 있는 사람만이 떼돈을 번다' 그런 이상한 결론이 나올 수도 있죠.

어쨌든 헛소리 많이 했으니까, 여기까지 하겠습니다.

포프였습니다.