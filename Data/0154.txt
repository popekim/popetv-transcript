예전에 한번 그 인터페이스에 대해서 좀 깠던 적이 있는 것 같아요 그래서
이제 그거를 저는 인터페이스를 어찌 보면 좀 잘 제대로 이용하지
못하는 걸 많이 깠던 것 같아요 implementation 하나고 interface가 하나다
그리고 이 모든 라이브러리가 내부 적으로만 쓰는 라이브러리고 외부
적으로 내주는 라이브러리가 없는데 굳이 인터페이스를 모든 implementation
마다 만들 이유가 뭐가 있냐 실제 나중에 implementation이 여러 개
고 실행 도중에 implementation을 여러 개를 동시에 실행해야 될 일이 있거나
아니면 바꿔줄 일이 있을 때 그때 에서만 필요한 거 아니냐 그때에서
야 무슨 뭐 dependency injection이라는 건 그때 필요한 게 아니냐는 얘기를
제가 했었어요 그러다가 최근에 또 직장 동료하고 그 얘기를 다시
하게 될 기회가 생겼는데 일단 뭐 이런 식으로 아키텍처를
짜는 회사에서 제가 그동안 일해 본 적이 없었고 그리고 그런 아키텍처
를 왜 나왔는지 이해하는 데까지도 제가 시간이 좀 오래 걸렸던 것 같아요
예전에는 그냥 단순히 왜 이러지 이건 말이 안 되는 거야 뭔가 더러운
데 뭔가 인터페이스를 잘못 쓰고 있는데 뭔가 이건 misuse인데 그런
생각만 하고 있다가 최근 들어 이유를 또 알게 된 거죠 그 이유가 뭐냐면
어찌 보면 그 엔터프라이즈 아키텍처 라고 이렇게 말하고 사는 사람들이
굉장히 많이 따라온 개인 그 사람들은 패턴이라고 부르는 게 아니라 패턴
이라고 믿고 있는 것 같은데 제가 볼 때 안티패턴이고요 그 이유가
되게 간단하더라고요 사실은 유닛 테스트를 위해서래요 어이가 없어
가 개념이 뭐냐면 일단 유닛 테스트 를 할 때 어떤 모듈 하나를 테스트
해야 되는데 이 모듈이 다른 클래스 라든가 다른 모듈에 이렇게 뭐라
그럴까 dependent 하는 경우가 있잖아요 그러면은 이 유닛만 테스트해야
되는데 이 다른 모듈에 이렇게 호출 해갖고 하면은 유닛 테스트를 해야


되고 유닛 테스트가 아니니까 이 모듈에 있는 원래 implementation 대신에
다른 implementation 테스트용 implementation 이라던가 뭐 흔히들 먹듯 먹힌
데이트라고 하죠 그 한마디로 가짜로 데이터를 이렇게 뭐 뭐라 그럴까
그 클래스를 가짜로 만들어서 실제 그 클래스가 하는 일은 저희가 원하는
데이터를 반환만 하게 다른 뭐 시스템을 호출하는 게 아니라 예를 들면은
이제 제 서비스가 있고 db를 호출 할 일이 있으면 db하고 직접 연결
해서 호출하면서 유닛 테스트를 하기는 그러니까 이 모듈에 있는
인테그레이션 테스트라고 하더라구요 자체 시스템만 돌게 이 db에서
내 있는 모든 그 함수들 있잖아요 뭐 add update 뭐 delete 이런 거를 저희가
이제 직접 코드에서 코드 수준에서 가짜로 짜갖고 필요한 거만 데이터
만 돌려줘서 이 데이터는 분명히 문제가 없다는 가정하에 제가 만든
서비스만 테스트하는 유닛 테스트를 하기 위해 그랬다고 하더라구요
그럼 이제 그러기 위해서는 당연히 뭐 dll 스왑을 할 게 아니라면 처음부터
인터페이스를 만들어서 그 인터페이스 를 인지하는 데이터를 만들어야
고 이 서비스에서는 실행 도중에는 제대로 된 임플리멘테이션을
넣어주고 테스트 중에서는 머킹한 임플리멘테이션을 넣어준다 이
얘긴데 제가 해주고 싶은 말은 솔직히 하나에요 할 수 있다고 해서 반드시
그거를 이용해서 뭔가를 해야 되는 건 아니에요 무슨 얘기냐면 테스트
는 테스트죠 뭐라 그럴까 런타임 은 런타임이에요 테스트는 말그대로
뭔가 문제를 테스트하기 위해 있을 뿐이지
테스트를 하기 위해서
런타임에 있는 아키텍처 자체를
개판을 쳐놓을 이유는 없다고 보거든요
그럼 그 생각 자체가 잘못된 거죠
뭐가 주구 뭐가 종이냐 생각 자체를 못 하는 거예요 사실은
예를 들어서
제가 요즘 주니어한테 많이 듣는 이야기가
온갖 인터페이스 보면서
뭔가를 함수를 하나 보려고 해도
인터페이스 안에
뭐 Implementation이 있는데
그 Implementation도
하나가 여기 있고 테스트용이 있고
뭐 다른 게 있고 좀 이상한 거예요
결국엔 지금 실행 중에서 도는 Implementation 하나인데
모든 걸 인터페이스로 앱스트랙션을 하다 보니까
이게 한 번에 코드가 안 읽히고
애들이 헤매기 시작을 하는 거예요
물론 실력이 좋은 사람들은
그것들을 열심히 찾아서 할 수가 있어요
하지만
제가 볼 때 소프트웨어의 퀄리티를 높이는
가장 중요한 거는 Readability라고 보거든요
예를 들어서
만약에 정말 잘하던 시니어가 한 명 나갔어요
그 시니어를 구할 수가 없어요
우리가 주니어 세 명으로 몸빵을 해야 돼요
근데 주니어들이
이 복잡한 인터페이스 자체를
이해를 못 해요
뭐 아키텍처라는 걸
아니면 시간이 더 걸려요
이해하는데 10% 더 걸리나 20% 더 걸리나던가
그럼 Maintenance 할 수 있는 그런
Maintenability라고 하죠
그 뭐라 그러지
관리를 얼마나 쉽게 할 수 있냐
그런 것도 떨어지는 거고
Readability도 떨어지고
그러면서 굉장히 코드 유지에
보수하기가 힘들어지는 거거든요 사실은
차라리 제가 여태까지 봤던
모든 엔진이라던가 코드베이스를 보면은
딱 읽었을 때
정말 내가 기본적으로
기본적인 OOP 개념
확실히 잡혀
있을 때
이해할 수 있는 코드가
최상의 코드였어요
뭐 거기서 뭐 디자인 패턴
이것저것 하더라도
솔직히 디자인 패턴
웬만한 거는
OOP 개념만 확실히 잡히면
이해하긴 어렵지 않거든요
근데 거기다가
알 수 없이 인터페이스 쳐박기 시작하고
뭐 인터페이스 한 두 개 정도를
Abstraction 하고 나서
속에 있는 Implementation 감춰버릴 때가
문제가 되는 거죠
전에 비디오에서 말했듯이
인터페이스는
두 가지 경우에만 굉장히
뭐
두 가지?
어쩌면 한 가지일 수도 있는데
두 가지 경우에만 굉장히 유용해요
첫 번째는
진짜 아키텍터가 처음부터 끝까지
모든 함수 다 분리해내고
다 디자인 끝낸 다음에
이 인터페이스는 이거 해야 되고
저 인터페이스는 이거 해야 되고
인터페이스 정의 다 해주고
다른 사람들이 Implementation 할 때
대부분의 그런 일은 많이 없죠 사실
저희가 일하는 소프트웨어
그 뭐야
분야에서는
드문 분야에서 있어요
굉장히 그 사람의 생명이 달리는 게 중요한 부분에서는
그렇게 모든 걸 아키텍터가 들어가는 경우가 있는데
특히 컨스.. 뭐라 하죠?
고객들을 직접 상대해야 되는 그런 소프트웨어에서는
requirement가 계속 바뀌기 때문에
그 인터페이스는 언제나 바뀌게 돼 있어요 만들면서
그래서 그렇게 아키텍터를 만들 수 있는 경우가 굉장히 드물고요
그리고 두 번째
저희가 라이브러리를 만들어요
그리고 라이브러리를 누군가한테 줬는데
그 사람들이
또 다른 기능을 추가해야 될 일이 있잖아요
그럼 인터페이스를 오픈을 해줘야만
저희 라이브러리에서 인터페이스를 받아 갖고 뭔가 돌리더라도
그 Implementation은
그 라이브러리 내부적인 소스의 컨트롤.. 뭐랄까?
접근성이 없는 사람들이 할 때만
접근성이 없는 사람들이 뭔가 Implementation을 만들 수가 있는 거죠
그래야 다 같이 도니까
그 정도예요 사실은
근데 여기다 이제 유니테스트를 하기 위해서
인터페이스를 모두 만들겠다
그리고 DI를 이용해서
테스트 모듈과 테스트 아닌 모듈을 바꾸겠다
진짜 저도 이렇게 생각하면서
이게 맞는 얘기가 굉장히 고민을 오래 했어요
그러면서 이제
저는 개인적으로 굉장히 더럽다고 생각을 했기 때문에
저는 언제나 뭔가 더럽다고 생각하면
더럽다고 계속 이렇게 불만을 하는데
확실한 입장이 생기기 전까지는
확실하게 이게 절대 틀린 거라고 말을 못 하거든요
근데 그게 굉장히 요즘 더러운 기분이 많이 들면서
이제 인터넷을 들이기 시작했어요
과연 누가 이따위 안티패턴을 만들어 냈나
과연 왜 이런 일이 생긴 건가
사실 Dependency Injection이라는 개념을 처음 만든 사람은
굉장히 훌륭한 아이디어를 얘기한 거예요
그리고 뭐
팩토리 패턴도 어찌보면은
Dependency Injection하고 약간 관련이 있어요
정확히 말하면
그러면 Dependency Inversion이라고 하는데
그러니까 종속된 상호관계를 뒤집었다는 얘기죠
그 사람의 아이디어는 굉장히 뛰어났는데
이 아이디어를 잘못 해석한 사람들이 만들면서
뭔가 개판을 많이 쳐놓은 거더라고요
그래서 결론적으로 얘기하면은
Dependency Injection 뭐 이런 개념은 다 좋아요 사실은
런타임 중에 Implementation을 바꿔야 될 일이 있다면
근데 제가 여태까지 발언 중에
그래야 될 소프트웨어는 거의 없었고요 사실은
그래서 그거는 말 그대로 한
20% 정도의 소프트웨어가 그런다고 보죠
그러면 20% 정도에 맞는 그 패러다임을
전체 소프트웨어에 맞는 것처럼
그 집어넣으려고 하는 그런 잘못된 풍습이 생겼고
그리고 유닛 테스트에 이걸 할 수 있다는 거 자체가
그래 이걸 이용하면 유닛 테스트를 이렇게 멋지게 할 수 있겠다
생각해서 시작한 거 같긴 해요
근데 개념을 잘못 잡은 거 같아요 이미 시작부터
예전에 C에서 보면은 템플릿 코드 나올 때
템플릿으로 엄청난 짓을 할 수 있었거든요
메타 프로그램이라고 나왔고
그 메타 프로그램 엄청나게 하는 사람들 많아요 사실
새로운 거니까 하고 싶으니까 뭔가 쿨하니까
제가 그런 게임 스튜디오를 몇 군데 봤어요
막 메타 프로그램 죽이게 하는 데들
지금 그런 데들 다 게임 망하고 사라졌어요 제가 알기로
왜냐면 코드가 보수 유지가 안 돼요 더 이상
메타 프로그램 막 이상한 템플릿 엄청 찍어 놓으면
보기도 어렵고 뭐 하는 거지 이게?
필요도 없고 웬만한 경우에
어떤 경우에 그냥 뭐라 그럴까
템플릿으로 안 하고 코드 짰을 때
그냥 코드 뭐 한두 번 더 짜는 거 그게 전부인데
이걸 엄청난 메타 프로그램 짜서 짠 사람은 이해를 해
근데 보는 사람은 시간 엄청 할애하면서
이거 왜 이렇게 되는 거지?
고민하면서 보수 유지가 안 되고
보수 유지를 하더라도 개판이 점점 나는 거예요
그래서 그냥 아 이거 할 수 있다 졸라 쿨하다
그래서 했는데 오히려 코드 가독성 망하고
메인터넌스 하기 정말 어렵게 만들고
그래서 망한 경우 많이 봤어요
뭐 진짜 말도 안 되게 무슨 게임에서 쓰는 행렬인데
행렬에...
행렬을 뭐로 만들지?
뭐 템플릿으로 만들었다던가?
행렬을 템플릿으로 만들었다는 얘기를 딱 들었을 때
아 이 사람이 더블로 하는 행렬도 필요하고
플로우스로 하는 행렬도 필요하고
인테리어로 하는 행렬도 필요해서 뭐 그걸 했나?
근데 왜 굳이 그랬지?
어차피 게임에서 쓸 거는 플로우치기 거의 전부일 텐데
물리 쪽 들어가지 않는 이상은
근데 나중에 얘기를 듣고 보니까
그 행렬을 만든 게
행렬의 열과 행수를 템플릿으로 바꿨다고 그러더라고요
그럼 128 곱하기 128
그걸 만들겠다는 얘긴가?
근데 게임에서 그럴 일이 뭐 있지?
4x4 아니면 3x3가 전부일 텐데
물리 쪽 들어가지 않는 이상은
그래서 그 생각을 하기 시작한 거예요
그리고 그거를 템플릿으로 만들기 시작하면은
그 SIMD라는 거 있잖아요
그 Vector Processing
Float 내기 한꺼번에 처리할 수 있는 거
그걸로 해서 속도 향상도 못 할 거고
도대체 이걸 제네릭하게 만들어서 뭐 하자는 걸까?
행렬을 만드는 이유 자체가
뭐 계산을 빠르게 하고 성능을 빠르게 하기 위해서인데
그럼 결과적으로 SIMD까지 들어가야만 도움이 되는 건데?
왜 또 그렇게 했을까? 라는 생각도 드는 거예요
그래서 정말 이상한 사람들 많이 봤었고
더 다행은 그런 실수를 많이 했기 때문에
이제 그거는 이제 사람들이 안 해요
그거를 오르러 몰려갔다가 새로운 거라 그래서
아 할 수 있으니까 해보자고 했다가
아 실수였구나 그래서 다 돌아왔어요
좀 깨끗한 코드를 짜려고
근데 문제는 제가 지금 이제 그 이 아키텍처
뭐 엔터프라이즈 아키텍처 이쪽에서 아직도 보는 거는
이런 뭐 유니텔스 디렉터가
디펜던트 인젝션 일어나는 걸 보면서
아직도 정신 못 차리고 있구나 생각을 많이 해요
유니텔스 얘기로 돌아와서
제가 이제 그래서 많은 걸 읽어봤다 그랬잖아요
그 뒤에 인터넷도 많이 뒤져보고
근데 결과적으론 저하고 똑같은 의견을 가진 사람이 있어요
그리고 이제 굉장히 존경받는 사람 중에도 있고
어떤 의미에서는 제가 이제 그 사람의 철학을
굉장히 좋아했던 사람이기도 해요
어찌 보면 그런 철학이 비슷하기 때문에
저희가 똑같은 거에 동의를 하는 걸 수도 있죠
뭐 당연히 성공한 사람이고
그 사람의 얘기를 보고
또 그 사람과 동의하는 다른 사람의 얘기를 보면서
유니테스트에도 여러 가지가 있다는 걸 알았고
그리고 제가 단순히 그냥
아 이거 유니테스트 하기 위해서
이렇게 인터페이스 개판치는 거 정말 문제 있다
차라리 안 하는 게 낫다라고 그냥
뭐라 그럴까
겉필링이죠 사실은
육감적으로 이렇게 막 이거 정말 이상한데
유니테스트를 차라리 완전히 포기하고서라도
실제 런타임에서 오는 코드를
깨끗하게 단순하게 유지하는 게 맞겠다라고 저는 어떻게 포기하든가 하는 걸 알았거든요

그래서 이제 그 얘기를 하죠
아 비디오 진짜 길어진다
일단 유니테스트에는 네 가지가 있대요
그 네 가지가 뭐냐면
첫 번째가 레벨 원 테스트
그게 이제 말 그대로 함수 하나에서 모든 게 끝나는 거
예를 들어서 가장 좋은 거는
행렬 곱하는 함수 같은 거 있잖아요
행렬 곱하면 함수는
이렇게 행렬 A, B 받으면
C는 언제나 같아야 되잖아요
그러면 유니테스트 쉽게 할 수 있죠
행렬 두 개 좋고

리턴하는 값 보고
C 값이 동일하냐
유니테스트 끝
그게 레벨 원이에요
그리고 어찌 보면은
제가 흔히 알고 있던 유니테스트 개념은 이거예요
게임 쪽에서 했던 것도 그렇고
여태까지 알고 있던 유니테스트도
C에서 주로 하던 유니테스트겠죠 어떻게 보면은
두 번째 유니테스트는 레벨 원인데
레벨 투죠
원, 투니까
레벨 투인데
이거는 자체 오브젝트 안에 한정된 유니테스트예요
그러니까 상태 변화가 있는 유니테스트
오브젝트 안에 보면 변수 같은 거 갖고 상태를 바꿔주잖아요
하지만 그래도 같은 뭐랄까
모듈 안에 있기 때문에
모듈이 아니라 오브젝트라고 해야겠죠
클래스 안에 있기 때문에
그 상태가 변하는 것도 유니테스트를 자기 안에서 할 수 있다
좋죠
여기까지가 제가 최대한으로 했던 유니테스트예요
그 이상이 넘어가면
저는 유니테스트를 솔직히 보지도 않았어요
레벨 3는 뭐냐면
모듈 간에 Dependency가 있다
그러니까 예를 들어서 아까 말씀드렸죠
뭐 서비스가 있고 DB가 있을 때
이 두 모듈이 두 개 있어야 되는 게 Dependency가 있을 때
이거를 말도 안 되게 유니테스트로 하려면
한 마디로 이 DB 거를 다 머킹을 하겠다는 거예요
그러면 이제 머킹한다는 게
DB 오퍼레이션 다 머킹하는 게 얼마나 시간이 낭비가 많은데요
그럼 이걸 낭비하는 거가 과연 유니테스트의 가치가 있느냐 없느냐
그거야 어느 업계냐에 따라 다르겠지만
그리고 네 번째는 이 모듈에 Dependency 하는 것도 있고
그리고 다른 모듈의 상태까지도
상태에도 의존하는 게 있어요
뭐 그런...
잠시만 잘 모르겠다
그러니까 한 가지가 더예요
의존을 하고 내 상태에 의존하나 상대방 상태에 의존하나
뭐 둘 중에 하나인데 그렇게 좀 더 복잡해지는 거예요
그러면 1, 2는 유니테스트로 무조건 돼요
3, 4는 있잖아
Integration 테스트라고 이미 있어요
다른 모듈 간에 Deploy를 한 다음에
테스트하는 테스트가 사실 있어요
뭐 어떤 의미에서 스모크 테스트라고도 하겠고
그 테스트를 안 하고 유니테스트를 만들려고
모든 데이터를 머킹하냐
아니면 그냥 Integration 테스트에 의존하겠냐
라는 두 가지 얘기가 있죠
Integration 테스트는 실제 Real Data라고 보면 되죠

그 테스트 하는 거예요
제 개념은 무조건 1, 2가지 유니테스트 3, 4 버리고
Integration 테스트에 무조건 유지하자
Integration 테스트 할 수 없다면
그걸 할 수 있는 어떤 뭐 뭐라 그랬죠
실제 라이브 머신이라 그러나요
데모 머신
그거를 만들어서 거기서 모든 걸 할 수 있게 만들자는 게
제가 하려던 의견이었어요
근데 최근에 봤던 블로그 중에
simpleprogramming.com이라고 있어요
이제 거기서 Back to Basics라는 시리즈가 있거든요
거기에 그 사람이 추천한 게 이거예요
두 가지
이런 다른 모듈에 의존하는 경우에
이거를 다 머킹을 하긴 하는 대신에
이 함수 자체가 그 모듈을 직접 받는 게 아니라
그 모듈에서 결과적으로 나오는 데이터를 받게
함수를 바꿀 수 있다면
그 데이터만 받아 갖고 똑같은 테스트 할 수 있다
그럼 데이터만 가짜 데이터만 제공하면 되는 거니까
그러면 모든 함수를 머킹할 필요가 없이
그냥 데이터만 주면 된다
그리고 실제 그렇게 디자인을 할 수 있으면은
함수나 각 클래스가 굉장히 간단해진다고 하고
저도 그건 동의를 해요
물론 모든 게 그럴 수 있는 건 아니지만
그런 데이터를 짤 수 있다면 문제는 없는 거 같아요
아니면 심지어는
그 다른 모듈에서
아니 이 모듈에서
함수가 두 개가 있어도 되죠
리포지토리를 아예 받아 갖고
거기서 함수를 호출해 갖고
데이터를 얻은 다음에
그 데이터를 다른 함수에 넣어 줘 갖고
호출하게 되는 경우
뭐 프라이빗 멤버라든가
그러면 결과적으로 첫 번째 함수는
단지 리포지토리에 호출해 갖고
데이터를 얻으면 되는 거죠
데이터를 받은 다음에
데이터를 다시 다른 함수에 집어넣는 거니까
그 두 번째 함수만 테스트를 한다면은
첫 번째 함수는 단순히
그 리포지토리가 옳다고 가정하는 거니까
상관이 없는 거고
두 번째 함수는 테스트가 되는 거죠
그래서 그걸 보면서
아 그럴 수 있겠구나
모든 게 그럴 수 없지만 그럴 수 있구나
그러면 굉장히 많은 부분에서
데이터를 머킹할 필요가 없어져요
그럼 쓸데없는 시간 낭비를 안 해도 되는 거죠
그럼 이게 그게 레벨 3에서 레벨 2로 바뀌는 거죠
어떤 의미에서는
데이터만 받는 거니까
그리고 마지막으로는 만약에 그런 일도 할 수 없을 때
어떻게 하냐
데이터를 머킹할 거냐
아니 그 함수를 다 머킹할 거냐
그 블로그 조자는 그러지 말라고 해요
사실 2, 3회 하는 얘기도 조금 이해가 되는 게
유닛 테스트는 소프트웨어의 품질을 향상시키는 게 아니라
프로그래머...
그러니까 실제 그 코드를 작성한 프로그래머의 만족도를 높인다는 거예요
나는 이 프로그래머를 짰고
재밌는 건 그거예요
이 프로그램은 이렇게 동작한다고 나는 가정을 하니까
그 가정을 확인하기 위해 유닛 테스트를 짜는 거예요
근데
어찌 보면은
내 틀 안에만 갇힌 거잖아요
제가 생각하는 맞는 비에이비어와 그 비에이비어에 맞게 유닛 테스트를 땄어요
근데 실제 다른 저희 소프트웨어에서 이 함수를 호출할 때는
그 가정이 맞지 않을 수도 있어요
그러면 내 가정이 옵냐 제 가정이 옵냐의 차이죠
리퀄먼트가 확실하게 나와 있으면 우길 수 있겠지만
그런 경우는 거의 없고요
결과적으로는 어차피 이 유닛 테스트를 얻을 수 있는 거는
내 가정이 맞다는 테스트밖에 없다는 거예요
소프트웨어의 가정이 맞다는 게 아니에요
소프트웨어의 가정이 맞을래요?
그러면 차라리 흔히 말하는 오토메이션 테스트라고 있거든요
특히 웹 쪽에서는 이제 웹 브라우저 띄워놓고
웹 브라우저 드라이버라고 있어요
실제 유저가 어떤 걸 클릭하는지를 대충 시뮬레이션 해갖고
그 결과가 어떻게 되는지 테스트는
한마디로 블랙박스 테스트인데 오토메이션 테스트죠
뭐 게임 쪽에서 스모크 테스트라고 하는 거랑 되게 비슷해요
어떤 의미에서는 또
인테리어 테스트하고 약간은 또 비슷하고요
근데 인테리어 테스트는 좀 더 뭐라 그럴까
그 모듈과 모듈만을 확인하는 거지
전체적인 테스트를 하는 게 아니라고
그래서 이 저자가 하는 얘기는 그거였어요
블로그 저자가
어차피 어떤 테스트를 짜든 간에 시간은 걸려요
근데 유닛 테스트에 걸려도 시간을 해야 하고
이 함수 하나 테스트하는 게
과연 소프트웨어 전체적인 가치에서 얼마나 의미가 있을까
이 함수가 되게 중요한 함수일 수도 있고
뭐 한 만 명 들어오면 한 번만 호출되는 함수일 수도 있잖아요
근데 그거를 하기 위해서 엄청난 데이터를 머킹하는 것과
그 똑같은 시간을 들여서
그런 오토메이션 테스트를 짜는 것과
그러면 오토메이션 테스트를 짜면
실제 유저가 가는 대부분의 것을 많이 테스트를 하는 거잖아요
그래서 이 테스트를 짜면

과연 어떤 게 가성비가 좋냐
그 얘기예요
물론 저희가 모든 테스트를 다 할 수 있으면
그것도 하고 이것도 하겠지만
그런 경우는 저 솔직히 못 바꿔요 소프트웨어 업계에서
결과적으로 있는 시간 쥐어짜서 테스트를 적당히 만들고
어느 정도에서는 만족하고 넘어가야 되는데
저희가 유닛 테스트에 시간을 백날 들여봐야
소프트웨어 품질 향상에는 굉장히 큰 효과가 없다는 거예요
차라리 저희 만족도가 높아지는 거지
소프트웨어를 위해서라면
그런 오토메이션 테스트를 잘 짜는 게
훨씬 중요한 테스트도 많이 잡고
중요한 버그도 많이 잡을 수 있다는 얘기죠
동의해요 솔직히 보고서
아 맞는 얘기구나
근데 저는 오토메이션 테스트를 잘 몰라요 아직 사실은
차라리 내가 유닛 테스트에 데이터 머킹하려고 시간을 낭비하는 바에는
오토메이션 테스트를 좀 더 해보는 게 낫겠구나 생각이 들었어요
예전에 그런 얘기 한 거 같아요
뭐 트위터였는지 비디오였는지 모르지만
흔히 말하는 퓨리스트가 있어요
뭐 오버 엔지니어링 많이 하시는 분들일 수도 있고
뭐 순수하게 완벽하게 만들려는 분들
그 사람들은
정작 회사나 소프트웨어에 도움을 주는 건 없어요
그 사람들은 자기 만족도
그거에 도움이 되는 게 전부예요 사실은
아 난 정말 대단하구나
난 이렇게 뛰어난 프로그램 만들 수 있어
근데 그런 사람 백날 회사에 만나봐야
소프트웨어 안 나는 경우가 되게 많아요 또
실제 뭐 굉장히 잘 나가는 소프트웨어들 다 보면은
그렇게 막 철저하게 뭔가가 잘 돼갖고 성공한 경우는 진짜 없거든요
어찌 보면은 유저들 성향 분석해서
그에 대해 빨리 발맞춰 나가서 움직이는 사람들이 많았지
그리고 결국 그거에 하는 얘기는 역시 똑같아요
오토메이션 테스트 잘해갖고 유저들이 하는 것도 대부분 테스트하고
실제 내부에 도는 거를 뭐 당연히 완벽히 개판을 짤 수는 없죠
밸런스가 필요한 건데
그걸 뭐 유닛 테스트 100% 해갖고 이거를 완벽하게 만들겠다
이 자다 자체는 말 그대로
한마디로 그냥 좀 이기적인 사람들 같아요
그냥 나만 잘하고 자기가 담가 있는 그 단체가 성공하는 걸 바라지 않는
뭐 그것도 나쁘진 않은데 뭐 혼자 일하시는 분들한테는 좋죠
그래서
얘기가 길었는데
결과적으로는 한마디로 마무리할 거 같아요
자기가 만드는 거에 최종적인 가치가 뭔지를 보는 게 제일 중요한 거 같아요
그 최종적인 가치에 따라 자기가 뭘 해야 되는지 바꿔야 되는 거 같고
아니면은 그 가치가 자격 안 맞는다면은 그 회사에 있으면 안 되는 것도 같고요
그래서 제가
저는 굉장히 실용적이고 빨리빨리 움직이는 걸 좋아하기 때문에
그런 업계는 제가 일부러 안 들어가는 거죠 어떤 의미에서는 뭐 이렇게 뭐 항공업계라던가
거기 들어가면은 제가 코드 하나 잘못되면 사람들 죽잖아요
그럼 그거 유닛 테스트 짜야지
근데 그럴 자신이 없어
그런 거고요
제가 볼 땐 비디오가 되게 길어진 거 같아요
그러니까 대충 끊을게요
포프였습니다
