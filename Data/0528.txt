예 안녕하세요. 보프입니다.
진짜 오랜만이죠?
그동안 좀 바쁜 일들이 있었어요.
이사도 좀 해야 됐고
그래서 이제 새로 꾸민 곳에서 제대로 방송을 하게 됐는데
자세한 얘기는 차차 나중에 하도록 하기로 하고
당장 이 비디오 보시는 분들 가장 처음 할 말들이 있을 것 같아요.
제 생각에는 머리가 왜 이 꼴이냐
제가 멋을 부리기 위해서 그런 건 아니고
그냥 코로나 터지고 사회적 거리 두기 하락을 해서
미용실을 안 가다 보니까 이 꼴이 됐죠.
그래서 이게 무슨 농구를 하고 싶어서 이런 것도 아니고
락을 하고 싶어서 이런 것도 아니에요.
코로나 끝나거나 아니면 그 전에 포큐 아카데미 강좌를 찍을 때가 되면
알아서 미용실 가서 다시 예쁘게 정상대로 가고
머리 스타일 바뀔 거니까 그때까지는 참아주시고요.
됐고 오늘 하려고 하는 얘기는
버전 관리? 데이터의 버전 관리?
아니면은 마이그레이션?
데이터 버전을 낮은 버전에서 높은 버전으로 다 옮겨버리는 거
그 둘 중에 뭐가 좋냐 뭐 이런 얘기를 좀 하고 싶어요.
이게 뭐 최근에 어떤 트위터 관련된 내용도 본 거기도 하고
그리고 실무에 있다 보면은 이 부분을 되게 안일하게 생각하는 프로그래머 때문에
나중에 더 큰 일이 생기기도 하거든요.
이거에서 저는 언제나 결론부터 말씀드리면
버전을 다르게 해서 저장하는 파일들이 있고
그리고 최종적으로는
아... 아니 뭐...
말해 잘못했다.
버전을 관리를 계속해야 되는 거와
아니면은 옛날 버전을 다 새 버전으로 데이터를 한 번에 옮겨버려서
그냥 새 버전만 쓰는 거
이 둘 중에 고르라 그러면 저는 데이터 옮기는 거
즉 데이터 마이그레이션을 하라고 하는 주의예요.
그게 훨씬 미래를 위해서도 좋고 실수를 막기에도 좋아요.
자 그럼 이제 결론은 말씀드렸으니까
하나하나 자세하게 말씀을 드릴게요.
자 버전이 왜 생기냐 데이터에
보통 프로그래머를 만들다 보면은
지금 현재 있는 스펙 아니면은 앞으로 뭐 6개월이나 6개월 정도는
1년 안에 나올 스펙들 그거에 맞춰서
자료를 구조를 잡게 되죠.
그게 데이터 구조가 되는 거예요.
뭐 좋은 예로 들면은 MS Word 97년도 포맷
뭐 2003년도 포맷 아니면 그 전 포맷
이런 식의 포맷이 있겠죠.
시작으로 했을 때는 처음 버전이 나왔다가
프로그램의 기능이 많아지거나
아니면 뭔가 고칠 일이 있거나
그러면서 새로운 데이터를 추가하게 돼요.
그 전 버전 스펙에는 맞지 않는 것들을
추가할 수밖에 없는 게 나오죠.
그 전 거가 변경되는 경우도 있고
아니면은 그 전 거에 추가된
경우도 있고
드물긴 하지만 그 전 거를 지우는 경우도 있어요.
자 그러면 생각을 해봐요.
처음 버전을 만들었어.
그리고 두 번째 버전이 추가가 됐어요.
그럼 옛날 버전에 있던 파일들이 있고
새로 저장되는 건 새로운 버전으로 저장을 하게 돼요.
그러면 이 순간에 어떻게 프로그램을 작성해야 될까?
뭐 흔히들 이제 되게 안일하게 생각하시는 분들은
그냥 예전 버전 파일로 예전 버전 파일로 읽고
최신 버전이면 최신 버전 파일로 읽는다.
그리고 이 두 개를 프로그램 안에서도
다르게 처리를 한다.
이런 방법이 있고 아니면 그보다 조금
나은 방식은 예전 버전을 읽어.
그 다음에 읽은 다음에 얘를
최신 버전 포맷으로 메모리에서 바꿔줘.
그리고 그걸 최신 버전 포맷으로 사용을 하다가
저장할 때 뭐 최신 버전으로 저장하든
옛날 버전으로 저장하든 둘 중에 하나를 해.
이런 상황이에요.
근데 요거는 워드 프로세스 같은 경우엔 말이 돼요.
근데 그게 아니라 언제나 읽기만 하는 데이터들도 있어요.
옛날에 저장해놓은 데이터.
그냥 읽는 거면 어떡하냐?
그럼 읽어갖고 옛날 방식으로 처리하는 로직 따로 있고
요즘 방식 처리하는 로직이 따로 있던가.
아니면 옛날 방식으로 처리하는 로직이 따로 있던가.
옛날 방식으로 로딩한 다음에
얘를 최신 방식으로 메모리에서 바꾸고
그 메모리에서 바꾼 거를 그냥
이제 뭐 읽고 사용하고
그리고 끝.
그러면 파일 저장돼 있는 건 안 바뀌죠.
옛날 버전은 계속 있는 거예요.
버전 1, 버전 2, 버전 3, 버전 4, 버전 11 막 올라가요.
그러면 코드가 어떻게 되겠어요?
버전 1 읽는 코드, 버전 2 읽는 코드, 버전 3 읽는 코드.
이게 다 1을 2로 바꾸고, 2를 3으로 바꾸고, 3을 4로 바꾸고
메모리에서 이걸 다 바꿔서
바꿔주는 방식이 되어 있으면
처리하는 코드는 최소한 하나겠죠.
근데 읽는 코드가 한 열몇 개 되는 거지, 버전 따라.
근데 그게 아니라 처리하는 코드 따로 있다면 난리가 나는 거죠.
1하고 2 보면 버전 2에서는 버전 1에 해당되는 로직이 이미 있을 거예요.
그게 또 여기 들어가 있는 거야.
버전 3에서는 버전 2, 버전 1을 보통 포함할 거야.
그럼 그게 또 코드가 중복이 되는 거야.
이게 쌓이고 쌓이다 보면요.
나중에 프로그래머들은 어쨌든 간에
새로 들어온 사람도 있고 아니면 최신 버전에 좀 오래 있었어.
버전을 지금 10년 동안 10개를 거쳐왔는데.
최신 버전에서는 한 3년을 버텼어.
그럼 모든 코드를 작성할 때
이 최신 버전만 돈다라고 가정하고 작성을 하게 돼요.
그러다가 옛날 파일이 어쩌다 읽혀요.
그게 당장 읽힐 수도 있고 아니면 코드 변경하고 6개월 뒤에 읽힐 수도 있어요.
읽히는 순간 이게 제대로 처리가 안 돼서 고장이 나는 경우들이 생겨요.
그러기보다는 제가 데이터 마이그레이션 하라는 얘기가 뭐냐면
버전 1 나왔어요.
이제 버전 2가 나왔어요.
그러면 당연히 처음 프로그램 나갈 때는 버전 1, 버전 2 다 돌아야 되니까.
특히 실시간으로 도는 서버에서는
둘 다 읽혀야 되니까.
아까 말했던 것처럼 버전 1을 읽어서 버전 2로 바꾼 다음에
실시간으로 처리하고 다시 버전 2로 저장하는 코드를 일단 만들어요.
그럼 라이브 나가고 모든 게 작동을 하죠.
그러면 그 외에 새로운 조그만 프로그램이 우리 서버가 아니라
다른 프로그램을 만들어서 데이터 마이그레이션을 천천히 하는 거예요.
매일 밤마다 버전 1로 있는 거 하나 읽어서 버전 2로 저장하고
또 다른 거 읽어서 2로 저장하고.
그게 진행이 될 때까지 모든 데이터를 해서
그 프로그램이 끝나는 순간
내가 가지고 있는 데이터는 모두 버전 2가 돼야 돼요.
그럼 그 다음에 뭐예요?
버전 1을 읽던 코드, 버전 1을 읽어서 2로 변환하는 코드 지우고
다시 코드 커밋하면 돼요.
그럼 앞으로는 어떤 프로그램이든 간에 그거를 사용할 때,
내 코드를 사용할 때 이제는 버전 하나만 신경 쓰면 돼요.
실수할 일이 확 줄어들고 테스트할 것도 확 줄어들죠.
이게 어찌 말하면 올바른 라이브 서버가 진행하는 방식이에요.
물론 사용자가 프로그램을 깔아서 사용하는 거는
그게 쉽지가 않아요.
그래서 MS Word 다시 얘기를 드리지만
거기 보면 옛날 버전으로 저장하는 기능들도 여전히 들어가는 있어요.
그런데 이게 정말 버전 1번부터 저장하는 방법이 들어가 있어요?
아니죠.
어느 순간, 시간이 지나면 당연히 옛날 버전 지원을 끊어요.
이제 더 이상 지원 안 할 테니까 이 버전 최소한 써라.
그리고 앞으로 MS Word로 넘어올 사람들,
앞으로 5년이 걸리든 몇 년이 걸리든 5년 동안은 옛날 버전 지원해 줄게.
하지만 계속 저장할...
이러려고 할 때마다 얘기하죠.
새 버전 저장 안 하면 최신 기능이 깨질 수 있어.
저장해, 저장해, 저장해.
최신 버전 이제 끌고 오죠.
그렇죠?
그래서 어쨌든 간에 소프트웨어들 보면 다 이런 식으로 작동을 하고요.
그게 올바른 제품을 만드는 방법이기도 하고
특히 웹 개발하시는 분들 중에
내가 모든 데이터를 가지고 있고 내 내부에서만 사용하는 데이터야.
그러면 100% 마이그레이션 하시는 게 맞고요.
그게 아니라 내가 API고 내 API에서 외부로 뭔가를 해줘야 돼.
그럼 외부에서 제 거를 사용하는 사람들이 있잖아요.
한마디로 아까 Word를 깔아서 사용하는 고객하고 비슷한 개념이죠.
그 사람들을 위해 옛날 데이터를 몇 년간은 지원해 주긴 해야 돼요.
그래서 몇 년 동안 지원해 준다.
이런 거 약속 잡고 그것 동안 지원하고
그다음에는 이 버전 더 이상 지원 안 하니까 새 버전으로 옮겨 타라.
이때까지가 마감이다.
이런 식으로 계속하면서 버전 업그레이드 해줘야 되죠.
그래서 외부 고객들, 외부의 API를 팔 때는 이런 부분이 좀 귀찮기는 해요.
그러나 여전히...
앞에서 얘기한 게 있죠.
읽고 메모리에서 바꾼 다음에 최신 버전으로 처리하는 코드 하나만 돌게 놔두는 건 좋은 방법이에요.
외부에 보내줄 때만
"어, 너희가 나 버전 3인데 버전 1 데이터를 원해?"
"알았어. 버전 3에 들어간 거 다 빼고 1만 줄게."
"어, 그래. 나 버전 3인데."
"어, 그래. 너 버전 2 원해? 버전 2만 줄게."
이런 식으로 실제 보내줄 때, 트랜스포트할 때
그때만 데이터, 그 사람이 원하는 버전으로 바꿔주면 되는 거지
내 로직 안에서는 새 버전으로 하나만 도는 게 좋은 거예요.
MS Word도 그렇게 돌죠.
MS Word 뭐 2020년을 깔아요, 예를 들어서.
그럼 깔았어? 그럼 내가 2020대로 돌고 있는 거잖아.
근데 저장할 때만 물어보잖아요.
"야, 97 포맷으로 저장할래?"
"2003 포맷으로 저장할래?"
바로 그런 개념이에요.
그래서 프로그래머는 당연히 게을러질 수 있어요.
지금 당장은 "아, 버전 1 돌고 있는 코드 있는데"
"얘를 2로 바꾸는 건 너무 시간이 오래 걸려."
"그냥 버전 2 도는 코드 따로 만들자."
"버전 1을 냅둬. 괜찮아."
그리고 나중에 버전 3 올라갈 때 똑같이 하고, 버전 4로 똑같이 하고.
그러다가 어느 순간
의인, 의인이 나타나서
"이거 다 개판이야. 깨끗이 고쳐야겠어."
그러면서 고치는 사람이 한 명이 나오죠.
그러면 그 뒤에 모든 사람이 마음 편안하게 잘 수 있는 거예요.
자, 버전잉, 데이터 마이그레이션.
이 둘 중에 기본은 언제나 데이터 마이그레이션이다.
단, 그게 안 되는 경우들, 약간 애매한 경우들을 말씀을 드렸어요.
그럴 때는 버전 유지하고 가는 게 맞지만
결과적으로는 언젠가는 데이터 다 넘어가야 되니까
뭐 서비스 어그리먼트라든가 몇 년 동안 지원한다는 거
이런 걸 통해서 꾸준히 사람들을 새로운 버전으로 옮기는 일을 하자.
그렇게 말씀을 드릴게요.
오랜만에 돌아와서 하는 포프TV 치고는 꽤 유익한 얘기였다고 생각을 해요.
포프였고요.
예, 또 다음에 뵙겠습니다.
