저번 주 금요일인가, 목요일인가 비디오가 안 올라갔다고 생각하시는 분들이 있던데요. 비디오가 올라갔는데 유튜브 쪽에서 뭔가 프로세싱을 못하고 있어서였어요. 비디오를 링크로 타서 들어가면 되긴 해요. 근데 그게 제 채널에는 안 보인다고 하셔서, 링크를 제가 따로 건 거를 보신 분은 몇 분 계시더라고요. 그래서 그분들은 봤는데, 그 외의 분들이 원래 그냥 제 유튜브 채널을 들어가셔서 보시는 분들은 아예 안 뜨니까 못 보고 계시더라고요. 그래서 그걸 다시 업로드 하긴 했는데, 지금 여전히 프로세싱 중이어서 그게 올라갈지 안 올라갈지 정말 모르겠어요. 그래서 이게 왜 프로세싱이 안 될까 고민을 되게 많이 했는데, 비디오가 좀 밑은 듯이 길긴 했어요. 한 35분? 아마 길면은 이게 프로세싱에 시간이 걸리고 deadlock이 걸려서 그런 게 아닐까 싶어서 좀 짧게 짧게 만들려고 노력을 하는데요. 

요즘 들어 모르겠어요. 굉장히 주절주절 말만 많아져서 길게 만드네요. 오늘은 조금 짧은 얘기를 해보려고 노력만 할게요. 저는 원래 망상이 좀 있는 인간이라 어떤 게임을 만들어보자고 망상을 하다가, '아 이 게임은 결국 내가 만들려면 차라리 내 자체 엔진을 만드는 게 더 빠르겠구나'라는 생각이 들었어요. 그래서 이런저런 생각을 하다가, 예전에 한참 생각하다 말았던, 데이터 load/save 이거에 대해서 생각을 하게 됐죠.
C#에서 주로 많이 쓰는 언어는, data de-serialization. 반직렬화? 그런 거에 문제인데요. C#이나 자바 등의 리플렉션 시스템이 완벽하게 갖춰져 있는 언어 자체에서 RTTI가 진짜 완벽하게 지원되는 언어들은, 그런 거를 클래스 잡아다가 class object 있으면 그거 다 저장하라고 serialization 해버리면 언어에서 알아서 property 이름을 찾잖아요? 그걸 json, xml, binary 든 다 저장할 수 있거든요. C나 C++에서는 언어 자체에서 지원을 안 하죠. 원래 스펙에도 없는 거고요. 옛날에는 그게 중요하다고 생각하지도 않았고요. 어찌 보면은 성능상의 문제로 RTTI 같은 경우도 게임 쪽에서 끄는 경우가 있으니까요. 

그 데이터를 저장할 때마다, 상당히 골아파지는 게 있어요. 그래서 가장 간단한 방법은, 예전에 흔히들 바이너리로 저장하는 거 있잖아요? 예를 들어서 데이터 멤버가 {int, short, float, int, char []} 이렇게 있으면, 그거를 그냥 직접 read/write 하는 함수를 만들어요. 첫 번째 4byte는 int. 다음 2byte는 short. 다음 4byte는 float. 그다음은 char의 개수인 int 4byte를 저장. 그 바이트 수만큼 캐릭터들을 저장하죠. reader를 만들 때도 똑같이 그렇게 하죠. 첫 번째에서 4byte는 어쩌고 어쩌고~ 

그래서 크로스 플랫폼 개발 환경에서 이게 좀 귀찮은 부분 중에 하나가 있었던 게 뭐냐면, big-endian, little-endian 이런 문제가 있잖아요. PC 전용 게임은 다 little-endian이니까 상관이 없지만, 예전에 Xbox 360라던가 PS3 같이 파워 PC 같은 경우에는 big-endian이기 때문에 그렇게 byte 수가 하나가 넘어가는 거는 언제나 이 byte swap을 다 해야 했거든요.

근데 툴은 다 PC에서 보통 도니까, 최종 플랫폼이 뭐냐에 따라 그 byte swap 해주고 좀 귀찮은 거였죠. 그것뿐만이 아니라, 컴파일러마다 그 struct를 그냥 곧바로 세이브를 한다고 하죠. 예를 들어서 struct가 메모리에 있으면, 이 struct가 안에 float 4개 있는 형태로 stream에 몇 개 있다고 하면요. 그냥 메모리를 byte stream에다가 그냥 memcpy를 해버리면 되는 거거든요. 

근데 그것도 alignment 규칙이 약간씩 컴파일마다 다르면 또 귀찮아지는 것도 있죠. 하지만 가장 큰 문제점은 역시 버전 문제였어요. 데이터를 옛날 버전으로 구웠는데, 새 버전이 나왔을 때, '아 과연 이 그전에 없던 데이터 멤버라던가, 그전에 있었다가 사라진 거 데이터 멤버를 어떻게 내가 구분을 할 것이냐'죠. 

그래서 이런저런 장단점이 있다가, C# 같은 경우는 그런 문제가 없는 거죠. 모든 그 데이터 멤버가 이름 기준으로 저장을 해놓고, '이 변수 이름에는 값이 이거'라고 알려주니까요. 

versioning도 쉽고 다 쉬운데, 단점은 이거예요. 메모리 디스크에서 데이터를 로드할 때 이걸 얼마나 빨리 읽을 수 있냐에 차이가 있거든요? 아까 말한 것처럼 C/C++처럼 그렇게 곧바로 memcpy가 되는 경우면 그냥 데이터 하여튼 쭉 읽은 다음에, 여기 struct 만들고 memcpy 해버리면 끝이거든요. 그러면 더 이상 고민할 것도 없고, 그냥 그거 자체로 데이터가 그냥 나오는 거니까요.

근데 아까 말했듯이, 그런 건 버전 문제가 있고요. C#에서는 serialization/de-serialization 하면 그런 걸 알아서 해 주긴 하지만, 말 그대로 디스크도 여러 번 긁어야 되고요. memcpy 한 번 하는 것보다 여러 가지 연산해야 되잖아요? if 조건문으로 무슨 타입이고, 무슨 이름이면 여기서 또 찾아가고 넣고 이런 것들요. 또 그런 것도 나름대로 일장일단이에요. 속도와 편의성의 문제죠. 제가 이 생각을 하다가 최근에 또 다른 생각이 든 게 뭐냐, 면 그 온라인 게임이 일반화되면서 그냥 하드에서 읽은 데이터를 가지고 있다가 그냥 네트워크에 쏴갖고 서버 쪽에 쏴주면 또 어떠냐? 그에 대해서는 또 시큐리티 문제도 있고 여러 가지 문제가 있거든요. 

그래서 프로토콜 버퍼라고는 많이 아실 거예요. 구글에서 개발한 거고, 시큐리티 문제도 굉장히 잘 잡아놨고요. 실제 네트워크 구글 내부에서 네트워크 패킷을 쏠 때, 그 데이터 형식으로 쏘는 거더라고요. 근데 그거는 클래스에서 곧바로 유추가 되는 게 아니라, 미리 데이터 scheme 같은 거 파일로 하나 만들어 놓고 이 struct에 뭐가 들어간다. 거기서부터 C++, C# 클래스 코드를 만들죠. 그러면 서로 그 데이터만 넣어주고 이 데이터를 읽으라고 명령하면 알아서 읽어줄 수 있는 거죠. 근데 이거의 단점은, 아무래도 네트워크 패킷이니까 크기를 작게 하려고 노력을 많이 하려고 여러 가지 압축을 계속해요. 그런 프로세싱 시간이 아무래도 serialization 보다 더 걸릴 수도 있고요. 그런 여러 가지가 있는데 최적화는 잘 하긴 했죠. 

근데 역시 데이터를 읽어서 그냥 곧바로 메모리가 카피할 수 있는 그런 장점이 있어요. 왜냐면 그거의 또 하나 장점은, 메모리 중간 단계의 alloc이 없어도 되거든요? 만약에 이거를 하나하나 분석하게 되면은 그만큼 temp buffer로 만들어 놓고 또 열심히 돌리다가, 다시 메모리 카피하고 나서 temp buffer를 free 하는 이런 것도 있어서예요.

protobuf의 단점은 그런 중간 메모리 allocation 단계가 있다는 거였고요. 메모리 allocation이 얼마나 속도가 느린지는 프로그래밍하신 분들은 다 아실 거고요. 그래서 처음 요번에 시작한 거는, 과연 내가 protobuf를 곧바로 게임 데이터 로딩할 때 쓸 수가 있을까? 그것도 괜찮지 않을까? 약간의 성능 저하나 이런 게 있지만요. 이왕이면 네트워크 데이터 패킷 보낼 때마다 새로 이렇게 struct 만들어서 protobuf 돌리는 것도 귀찮고 하니까요. "그냥 모든 거를 하나의 uniform 포맷으로 한 다음에, 그거를 네트워크 하고 클라이언트 쪽 하고 그냥 서로 공유할 수가 없을까?"라는 생각을 되게 많이 했던 거예요. 

그래서 이렇게 저렇게 보다가, protobuf를 쓰는 사람도 있긴 있더라고요. 이렇게 보면서 아 이게 가능은 하더라고요. 도타 2에서 리플레이 패킷을 다 protobuf로 만들었다고 제가 얘기를 들었어요. 왜 확실한지 아닌지 모르겠고요. 그래서 여러 개를 또 이렇게 찾아봤는데, 그거를 보는 순간에 어떤 사람이 Cap'n Proto(캡틴 프로토)를 추천하더라고요. 

이게 옛날에 protobuf 만들었던 사람인데, 구글에서 그 사람이 나와서 새로 만든 그런 프로토 버퍼랑 비슷한데요. 이거의 장점은 중간 메모리 allocation이 없고, 그 대신 memcpy가 곧바로 된다는 거예요. 
게임 프로그래머들이 게임 쪽을 위해서 만든 그런 프로토콜이 보이긴 보이더라고요. 괜찮았어요. 보안 문제도 구글에서 썼던 그런 기본 원칙을 갖고 썼기 때문에 굉장히 안전하다는 얘기를 하는데요, 이거의 단점은 아직 비주얼 스튜디오에서 C++를 지원 안 한다는 거예요. Clang 기반으로 만들었기 때문에, Clang에 있는 모든 기능을 썼고, C++11/14인가 그런 것도 많이 썼는데, 아직 Visual Studio로는 컴파일을 쓸 수가 없는 게 단점이고요. 누군가 포팅을 하고는 있대요. 그래서 그거를 좀 기다리고는 있긴 한데, 그거 나오면 아 이것도 괜찮겠다는 생각은 들었고요.

그 외에 또 구글에서 새로 나온 게 있어요. 굉장히 비슷하게 Cap'n Proto 하고 되게 비슷한 건데요. FlatBuffers라고 그것도 개념은 되게 비슷하더라고요. 그래서 일단 플랫 버퍼 웹페이지 가면, 장점/단점을 구분해 놓은 게 있고요. Cap'n Proto 만든 사람 블로그에 가도 장점/단점을 비교해 놓은 게 있어요. 

그래서 쭉 읽어보고 제가 느꼈던 건, protobuf를 진짜 게임에서 제가 쓰고 싶을 때, 중간 메모리 알로케이션 단계 없고 어쩌고 저쩌고 생각했을 때 정말 제가 딱 봤을 때 아 괜찮겠은 건 솔직히 Cap'n Proto였어요. FlatBuffers는 시큐리티 문제도 있고, 여러 가지 문제 중 뭔가 하나가 문제가 있었는데요. 제가 지금 기억은 안 나는데 시큐리티 쪽의 문제였는지 다른 문제였는지 제가 굉장히 이건 좀 아니라고 생각을 했었거든요. 그 부분은 좀 문제가 있다고 생각을 했고요. 

Cap'n Proto가 좋은데, 아직 C++ 비주얼 스튜디오 기반의 C++가 지원이 안 되는 관계로 아직 쓰기는 좀 무리가 있는 것 같고요. FlatBuffers에서 하나 제가 마음에 들었던 건 그거였던 것 같아요. 물론 최종 결과는 바이너리를 뽑을 수 있지만, 제 기억에 FlatBuffers 자체에서 json 파일을 읽을 수 있는 그런 라이브러리를 제공했던 것 같아요. 

그래서 실제 툴에서는 그냥 json으로 모두 세이브해놓고, C#에서는 제이선 다 읽은 다음에 최종적으로 게임 데이터 뽑을 때만 FlatBuffers에서 바이너리를 뽑아서 C에서 읽을 수 있지 않을까? 툴은 다 C#으로 만드니까요. 그래서 이것도 괜찮겠다고 생각했죠.

근데 생각을 해보면, 솔직히 Cap'n Proto도 누군가는 C# 포팅 버전을 만들 것 같거든요? 지금 열심히 만들고 있다는 얘기도 들었고요. 내부적으로 좀 복잡하긴 한데, 어떻게 나올 거고, C# 포트가 나오고 클래스가 나오기 시작하면 거기서 json 파일을 뽑아내는 건 문제가 아니기 때문이에요. 그래서 일단은 Cap'n Proto가 좀 더 완성이 될 때까지 기다릴 것 같아요. 근데 Cap'n Proto가 완성이 되면, 한번 모든 데이터를 그냥 Cap'n Proto 프로토콜로 가보는 것도 나쁘지 않을까라는 생각이 들고요. 

지금 당장 제가 생각했던 게임을 만들게 된다면, 네트워크는 당연히 당장 뭘 써야 되는데 어쩔 수 없이 protobuf을 가져다 쓰겠죠? 하지만 게임 데이터를 과연 protobuf을 쓸까, 아니면 아까 말한 대로 그냥 바이너리를 구워서 바이너리 곧바로 읽는 거를 쓸까는 조금 고민이 있어요. 

제가 짧게 끝낸다 그랬죠? 짧게 끝내야 될 것 같아요. 이 정도면 대충 주저리주저리 말한 건 다 한 거죠. 정리 같은 거 필요한가요? 

정리하자면, 데이터 읽는 방식에는 보통 두 가지고요. 
1. 바이너리로 memcpy 하는 방식: 그건 버전 업데이트 처리가 힘들어요. 
2. key-value 태그를 저장하는 방식: C# 같은 경우, serialization 같은 버전 업그레이드나 데이터 누락되거나 이런 거에 대한 대비도 좋고, 읽기도 편하고, 텍스트 파일에서 바이너리도 쉽게 변환 가능한 장점. 그러나 속도가 좀 느린 문제가 있음.

네트워크 게임까지 생각을 해보면 결국에는 네트워크 패킷으로 보낼 좀 작은 프로토콜이 필요합니다. 그럴 때 바이너리를 직접 보내도 상관없겠지만, 역시 해킹에 문제가 있죠. 그러면 그렇게 시큐리티가 준비된 그런 프로토콜을 좀 쓰는 게 좋고요. 그래서 많이 쓰는 게 구글의 protobuf으로 많이 쓰고요. Cap'n Proto와 FlatBuffers가 있지만, 아직은 충분히 완성되지 못한 프로토콜들입니다. FlatBuffers는 시큐리티에 문제가 있다는 단점이 좀 있고요. 그래서 결국 Cap'n Proto가 나올 때 좀 더 기다려야 되지 않을까 생각을 하고요. 

drift도 제가 한번 둘러보긴 둘러봤는데 기억은 안 나요. drift에서는 ByteArray를 내부에서 지원을 안 했던 것 같아요. 게임 데이터처럼 그냥 한 공간에 byte stream으로 쫙 보내려고 할 때 drift가 좀 어려웠던 게 있었던 것 같아요. 그래서 그것 때문에 drift가 별로 마음에 안 들었고, 데이터 형식만으로 봤을 때 protobuf가 좀 더 게임 쪽에 맞다고 생각을 했어요. 캡틴 프로토가 좀 더 기다려지고요. 그 정도로 정리를 하면 될 것 같네요. 포프였습니다.