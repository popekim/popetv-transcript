안녕하세요, 포프입니다.

오늘은 데이터베이스 얘기를 좀 할 거예요. 관계형 데이터베이스, RDBMS. 그게 보통 데이터베이스라고 말하면 다 그걸로 아시죠? 왜냐하면 옛날에는 데이터베이스 하면 90% 이상이 RDBMS였고, 그 뒤에 NoSQL 나오고 Document Storage 나온 이후에도 아무리 걔네가 유명해졌지만, 여전히 RDBMS가 75% 정도 시장을 점유 하기 때문에 데이터베이스 하면 RDBMS고, 그 얘기를 할 거예요.

그 RDBMS 히스토리를 보면 그 안에 이제 RDBMS가 신경 쓰는 것이 사실은 딱 두 가지라고 보면 맞아요. 제일 중요하게 여기 있는 거, 언제나 그렇진 않지만 거의 대부분 그런 거 하나가 '데이터를 굉장히 작게 효율적으로 저장해야 한다.', 그리고 데이터 Anomaly, '중복되는 데이터가 있는데 하나를 바꿨을 때 다른 게 안 바뀌는 일은 없도록 해야 한다.' 한마디로 프로그램에서 맨날 얘기하는 Single Source of Truth, '한 군데 정보가 Source고 나머지 것들은 다 올발라야 한다'는 그런 얘기죠? 그래서 하나만 바꾸면 모든 게 바뀌어야 하는 그런 걸 되게 신경을 쓰죠. 그래서 그것 때문에 나온 게 정규화, 그리고 정규화가 되면 당연히 데이터 스토리지를 훨씬 적게 저장하니까 효율적인 데이터 스토리지, 이 두 가지가 굉장히 중요한 토픽이고 여전히 그래요.

그런데 DB에서 효율적인 데이터를 저장하려면 결과적으로 내가 집어넣으려고 하는 데이터에 맞는 가장 조그만 데이터형을 골라야 했어요. 그게 일반적인 히스토리고, 지금도 많이 그래요. 그걸 할 수 있는 것이 보통 정수거든요? '내가 정수로 저장할 때 이 정수 값이 8비트 이상이 될 거냐? 16비트 이상이 될 거냐 32비트 이상이 될 거냐? 64비트까지 갈 거냐?'에 따라서 그 각 필드에 그걸 저장했고, 그리고 캐릭터 같은 경우는 무조건 통째로 '얘는 128 캐릭터 짜리야'라고 정할 수도 있지만, 그것보다는 VARCHAR라고 해서 '최대 몇 까지 돼'라고 하면 최대 '얘는 0부터 127까지 된다' 이런 식으로 많이 저장해 놨고, 그리고 일반적으로 '4,000 캐릭터가 넘는 발차는 저장을 안 하는 게 좋다'는 식으로 얘기를 많이 했죠? 왜냐면 그 이후로 저장하는 공간에 문제가 생기니까. 특히 만약에 'VARCHAR(MAX)를 해버렸다' 그러면 고개를 절레절레 흔들죠? 그 이유는 어마무시한 데이터가 들어오면 이만큼 저장하려고 하다가 이제 DB가 또 문제가 생길 수 있으니까요.

그래서 결과적으로는 그 데이터를 저장할 때 데이터의 모든 유효성 같은 걸 DB 소프트웨어에서 깐깐하게 잡으려고 하는 게 DB 쪽이었어요. 하지만 그럼에도 불구하고 어떤 경우에는 굉장히 Generic 한 그런 데이터 타입을 고를 수밖에 없는 경우들이 있죠? 대표적인 예가 이런 걸 거예요. 어떤 Column이 하나 있어요. 그 Column에는 Row, Row가 한 줄이죠? 그 데이터 한 줄이 들어온 무슨 예를 하나 들어보죠. Source가 어딘지를 보통 얘기를 하는 거예요. 그 Source를 이제 Reference라고 할게요. 어디 Join을 해서 foreign key로 연결하려고 이런 게 아니라, 그냥 이 데이터는 저쪽에 있는 어떤 ID가 준 거예요. 예를 들어서 '저쪽에 있는 Employee 번호 누가 준 거야', '저쪽에 있는 오더에 번호 뭐가 준 거야. ID 누가 준 거야' 이런 식으로. 그래서 요건 그냥 Bookkeeping용으로 있는 건데, 문제는 이 Column이 우리가 생각하는 모든 그런 데이터들이 다 똑같은 데이터형이면 아니면 최소한 정수형이면 어떤 그중에 제일 큰 정수형으로 만들어 놓고 숫자를 적으면 되거든요? 근데 저 테이블의 경우에는 이게 정수고, 저 테이블인 경우에는 캐릭터고 뭐 이런 경우들이 있어요. 그러면 어쩔 수 없이 얘를 String형으로 저장을 했어요. VARCHAR가 됐든 그냥 특별한 정해진 String이든 보통 VARCHAR로 하죠? 그런 식으로 저장을 했는데, 문제는 그 순간에 효율성이 떨어질 수 있다는 거예요. 예를 들어 정수를 Int를 저장하면 필요한 수가 솔직히 4바이트가 전부잖아요? Int를 십진수로 쫙 적어요. 그리고 String으로 바꿔요. 그럼 걔는 4바이트가 넘어 버리거든요? 그러면 실제는 4바이트로 저장할 수 있는 어떤 것들이 꽤 큰 10바이트라든가 12바이트라든가 이런 식으로 돼 버리는 거예요. 그래서 용량을 쓸데없이 많이 먹게 되는 그런 문제들이 있어요. 그래서 이런 건 어쩔 수 없이 해왔죠.

근데 이게 아니라 회사의 모든 데이터 Column이 String으로 되어 있는 데도 있어요. 왜냐하면 '나중에 어떻게 바뀔지 모르니 String으로 다 처박아 놓고 고민하지 말자.' 그럼 제가 아까 앞에서 말해왔던 'DB의 효율적인 데이터 저장과 중복을 효율적으로 막겠다'는 그 방법들이 완벽히 깨지는 거고, 그건 DB를 그냥 Document Storage로 사용하고 있는 거기 때문에, 그런 회사가 있다면 탈주하는 게 좋아요. 근데 요즘 세상에 이 문제가 생겼더라면 웬만한 경우 이 꼴은 안 났을 것 같아요. 왜냐하면 요즘 세상에서 여전히 이런 일을 하고 있다가 여기 Reference ID로 넣어야 하는 또 다른 아이디가 하나 생겨요, GUID로. Globally Unique Identifier, 아시죠? 이런 게 생겼을 때 이제 걔까지 저장하면 얘를 또 String으로 바꿔서 GUID String으로 집어넣는단 말이예요. 그럼 32바이트가 되는 거예요. 그러면 원래 GUID를 저장하면 16바이트로 저장할 수 있는 것을 32바이트를 저장하고 있는 거예요. 2배를 더 많이 쓰고 있는 거죠? 이런 문제들이 생기는 거예요. 근데 이렇게 될 수밖에 없던 이유는 옛날에 DB에서 GUID들을 데이터형으로 지원을 하지 않았었어요. 어느 순간부터 지원하기 시작했어요. 그 대신 GUID가 지원이 되면 장점이 뭐냐면 DB에 GUID를 String이 아닌 GUID, Unique Identifier로 집어넣었을 때 실제 DB에 저장되는 공간은 GUID 정수형만큼만 저장이 돼요, 아까 말했던 16바이트. 근데 제가 코드에서 SELECT 어쩌고 딱 봤을 때는 그걸 Hex String으로 바꿔서 예쁘게 보여주는 거죠. 한마디로 보여줄 때 Hex String으로 보여주고 저장은 효율적으로 저장하는 GUID 타입이 나온 거예요. 근데 이걸 아까 말했듯이 어떤 여러 가지 데이터형이 들어가야 하는 곳들, 거기에 Int도 좀 들어가고 막 이랬던 것들, String으로 만들어 놓은 거, 거기에 GUID로 받기 시작하면서 얘네가 크기가 커지는 거예요.

근데 GUID를 사용하는 순간 이게 방식이 좀 괜찮아지는 게 있더라고요. 그 Reference ID를 넣는 Column 자체를 그냥 Unique Identifier로 바꿀 수 있으면 그걸로 바꿔버리세요. 그럼 Unique Identifier를 넣는 순간 어떤 방식으로 뭔가가 되냐면, 정수를 넣을 때 GUID로 바꿔 넣으라는 얘기가 아니에요. 정수를 넣을 때 애플리케이션에서 GUID의 자릿수가 32자리인가 그렇잖아요 Hex로? 그렇죠? 그러면 그 32자리만큼의 정수 String을 넣을 수 있어요. 그리고 그걸 그냥 GUID로 저장하면 돼요. 그러면 내부적으로 저장은 16바이트로 저장이 되겠지만 화면에 보일 때는 -까지 포함해서 숫자가 그대로 보여요. 그리고 여기서 한 단계 더 나아가면 GUID 첫 번째 세 자리 정도를 뽑아서 이 데이터가 어떤 데이터 타입인지 그냥 보기 편하게 넣을 수도 있어요. 예를 들어서 이게 '고객 정보에서 온 거다', 그럼 고객이 Customer잖아요? 그럼 제일 앞에 C를 넣고 u랑 비슷한 캐릭터를 하나 찾아서 넣는다거나, A가 좀 뒤집어서 비슷하면 CA, S는 5랑 비슷하잖아요? 그러면 'CA5가 되면 얘는 Customer를 뜻하는 거. 중간에 다 0이고, 끝에 커스텀은 넘버.' 이렇게 누면 원래는 String으로 다 넣었던 것들을 GUID로 넣으면서 저장할 수가 있고, 그리고 만약에 어떤 다른 정보를 그냥 읽기용으로 보기 위해서 어떤 String을 저장해야 할 때도 비슷하게 보이는 String들을 저장할 수도 있어요. 그리고 이런 두 가지 다른 데이터 형식의 변환을 돕는 건 애플리케이션 단에서 프로그램을 작성해 두면 되죠. 그리고 거기서 변화해서 보면 되고요. 장점은 뭐냐면 내가 DB 가서 그냥 query 날려도 대충 보고 '아, 이건 그 코드지? 이건 그 숫자지? 얘가 저기서 왔구나.'라고 쉽게 어디서 데이터가 왔는지 확인하는 방법들이 있어요. 그래서 예전 같은 경우는 무조건 그냥 Generic 한 데이터형으로 가야 되면 어쩔 수 없이 다 String이나 VARCHAR로 갔는데, 요즘 세상에는 숫자 갖고 비슷하게 보이게 하는 ASCII Art 뭐 이런 식의 약간 장난을 칠 수 있다면, 그리고 그 String화된 데이터 크기가 32자리 미만이라면 GUID로 놓는 게 훨씬 효율적인 대안이 될 수도 있어요.

그래서 이걸 보면서 얘가 '아, DB가 처음부터 GUID를 지원했다면 아마 일반적인 데이터형을 할 때 GUID 매직을 한번 쓰고, GUID 매직으로 안 되면 그제야 String으로 가지 않았을까?'라는 생각을 하게 됐어요. 저희도 그렇게 바꾼 게 최근에 있고요. 그래서 'GUID라는 게 DB에서 직접적으로 지원해 주면서 편해진 것들이 이런 게 있구나' 사람 눈에 보이는 것과 저장은 다른 문제잖아요? 저장을 효율적으로 해주니까. String 같은 경우는 보여주는 것과 저장을 거의 비슷하게 하겠죠? 근데 문제는 당연히 용량이 더 커지겠고.  무슨 비교 같은 거 연산할 때도 당연히 얘네들은 String Search로 해야 하는 거고요, 하지만 Int 비교는 바이트만큼 비교하는 것만큼 훨씬 짧게 잘 끝나겠죠? 그리고 CPU 아키텍처에 맞는 ALU 크기 따라 제대로 바이트를 한 번에 비교하는 것도 들어갈 수 있고요. 그래서 여러 가지 장점들이 있는 것 같아요. 

그래서 한 번쯤 이렇게 굉장히 Generic 한 Column을 만들고, Join용이나 Foriegn Key용이 아닌 다양한 형태의 데이터를 넣어야 할 때, 그게 GUID String 길이 안에 넣을 수 있고, 그리고 약간 숫자나 이렇게 섞어가면서 이런 비슷한 짓을 할 수 있는 경우들, 그런 경우는 GUID를 충분히 사용하면 좋을 것 같아요. 그리고 거기에 진정한 GUID가 들어가야 한다면 그것도 그냥 넣으면 돼요. 보는 순간 '아, 얘는 진짜 GUID처럼 보이네?', '얘는 진짜 GUID니까 어디서 왔겠구나' 생각하는 거고, 나머지 것들은 보고 읽을 수 있는 거고요. 그래서 DB 단에서 숫자를 읽을 수 있고, 곧바로 String을 읽을 수 있고 볼 수 있는 건 굉장히 개발자한테 편한 일이거든요? 그게 안 되면 되게 복잡해하고 막 String 박고 이상한 짓 하는데, 안 그래도 될 수 있다, 그런 나름 혼자 깨달은 세세한 꿀팁을 전해드리고 오늘은 여기서 끝내겠습니다.

포프였습니다.