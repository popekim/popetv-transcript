안녕하세요 포프입니다.
얼마 전에 페이스북에서 그 누구지 그 누구지 회사량 까먹어서 안되는데
배현직 사장님 계신데 프라우드넷 그 배현직 사장님께서 stl 관련
이렇게 글을 올린 적이 있어요 그 분이 이제 댓글을 단건지도 까먹
었는데 그래서 이제 게임에서 과연 stl을 얼마나 쓰냐 이제 stl이라고
하면은 c++의 스탠다드 라이브러리 에서 이제 컨테이너들 있잖아요
벡터라던가 맵이라던가 이제 뭐 얼마나 쓰냐 이런 얘기 나오면서
막 뭐 이렇게 나는 이만큼 쓴다 나는 이만큼 안 쓴다 이러는데 이게
되게 재밌는 게 뭐냐면 이런 똑같은 논의가 사실은 한참 c++ 막 처음
c++03인가 나오고 막 이럴 때 그 해외에 있는 게임데브닷넷이라는
웹사이트 있잖아요 그런 데서도 되게 많이
도움이 되거든요.
돌았던 얘기예요 되게 재밌는 게 뭐냐면 그 당시에 이제 굉장히
많은 게임이 콘솔 쪽이었고 아니면 pc 게임이었던 것도 콘솔로 넘어가는
게 많았고 그래서 실제 업계에서는 stl은 거의 금기사항이었어요 일단
stl이 왜 금기사항이냐고 물으면 그렇게 물으시는 c++ 프로그래머가
있다면 일단은 솔직히 그 이유를 모른다면
그냥 c++를 잘 이해를 못 하시는 거 같아요 그 하드웨어를 잘 이해
못하는 거고 메모리가 실제 어떻게 도는지를 이해를 못하는 거고 그리고
stl에서 그 뒤에서 해준 온갖 마법적으로 해주는 그 모든 일들이 마법으로
만 생각하고 있는 가능성이 높거든요 일단 뭐 한 가지 이유만 들면은
stl에서의 메모리 관리 부분이 굉장히 좀 트리키한 부분이에요 뭐 메모리
를 그러니까 예를 들어서 stl에서
벡터를 놓었어요 그러면 벡터를 저장하기 위해서는 무슨 뭐 어느 정도의
어레이가 있어야겠죠 배열 사이즈가 그럼 이 배열이 커질 때 어떻게 되냐
그럼 당연히 메모리 재활당이 있어야 되고 메모리 카피가 있어야 되고 이런
문제들이 여러 가지가 있어요 그럼 메모리가 재활당되는게 뭐가 큰
문제냐 뭐 속도가 느리고 그럴 수 있지 정도까지만 가면은 뭐 그래도 속도가
느릴 수 있다는 걸 알면은 나쁘지 않은 거거든요 근데 그 이상을 넘어가면
어떤 플랫폼에 이제 게임을 먹으면은 그 이상의 메모리가 없으면은 그 이상에
게임을 올리냐에 따라 가상 메모리가 없는 플랫폼도 있어요, OS에서.
가상 메모리가 없고 메모리가 제한적이라면 메모리 하나하나에 구멍이 나는 순간
나중에 메모리는 충분히 많지만 파편화 때문에 메모리 할당을 못해서 뻗는 경우도 있어요.
근데 그 뻗는 상황이 게임을 뭐 한 5시간 한 뒤에 뻗는다거나 3시간 한 뒤에 뻗는다거나 파편화가 나야 되니까
그러면 일단 게임을 개발하는 도중에는 모르다가 나중에 게임 출시하고 나서 파편이 나는 경우도 있고 별별 이상한 일 다 했거든요.
그래서 그런 것들에 문제가 많기 때문에 이제 STL을 되게 좀 자제했던 부분이 있고
또 하나 이제 STL 자체가 인터페이스 자체로만 보면은 이렇게 실수를 좀 유발하는 인터페이스가 좀 있고요.
그리고 또 하나는
음
뭐라 그러지 그거를?
그 각 플랫폼마다 각 라이브러리마다 실제 내부가 어떻게 구현되어 있는지를 정확하지 않은 경우도 있거든요.
대표적인 예가 이제 스트링 클래스 같은 경우인데 기본적으로 스트링을 만들 때 처음에 배열 사이즈를 몇으로 잡아줄까요 이 컴파일러가?
왜냐면은 만약에 배열 사이즈 16으로 잡아주면은 캐릭터를 16까지 늘릴 때는 메모리 제할당이 없지만 그 뒤에 가면 메모리 제할당이 되거든요.
그 뒤에 가면 메모리 제할당이 되거든요.
그러면 consistent hj에서는 했는데 이제 제할당이 없던 게 다른 플랫폼 맥으로 가면 재할당이 될 수도 있고 그런 여러 가지 이상한 것들이 또 있을 수밖에 없어요.

그 자체적으로 최적화를 한다고 내부적에서 한 건데 되게 마법같은 최적화죠.
그러니까 자체적으로 최적화를 한다고 내부적으로 한 건데 되게 마법같은 최적화죠.
cabeutter 지역의 없지 cuantoifaoma 더깄지 그래서 실제 모든 코드가 투명하게 안 보인다는 점에서
그리고 이제 메모리 관리라던가 이런게 나중에 터지는게 되게 힘들고
그 터졌을 때 이걸 잡기도 힘들고 고치기도 힘들고
그만큼 굉장히 많은 프로그래머들이 대충대충 이렇게 어설프게 코드를 짜게
이렇게 허용한다는 부분에서 되게 용납이 안됐던건데
재밌는거는 2000년도에 만약에 누군가가 배열을 써갖고 코드를 만든 그런 코드를
게임데브닷넷에 올리면 거기서 키보드 워리어들이 있어요
게임데브닷넷이 되게 훌륭한 개발자들이 모여있는 곳으로 찾으신 분들이 많은데
대부분의 그 당시에 거기 있던 애들은 그냥 대학생들이 되게 많았고
그럼 걔네들은 이제 언제나 댓글을 달아요
아 이렇게 짜면 안되는거다 어레이같은거 쓰면 안된다
이건 씨브뻘에서 이러면 안되는거다
이거는 이러면은 뭐 뭐 어쩌고저쩌고 하면서
여기서는 당연히 이제 뭐 벡터를 써야되고 스트링을 써야된다고
이렇게 되게 막 거품을 걷고
싸웠어요 그러면 문제는 이제
그런 이제 그런 글을 처음에 썼던 애들 중에 제 동료도 하나가 있었거든요
되게 큰 게임 만들고 이제 되게 큰 엔진을 만들던 친구들인데
보고나서 이제 저한테 하는 얘기가
그냥 여기서는 상정을 안하는게 좋을거 같애라고 그냥 글을 지우고 떠났던 적이 있어요
그래서 그런식으로 그냥 온라인상의 어느 특정 커뮤니티에서 주도하는 의견 자체가
아 뭐 뭐
양쪽 다
정확히 틀린 틀리고 옳다라고 말할 순 없는데
반대쪽이 반드시 틀리고 이게 옳다라고 믿는 근거가 없는데
그냥 누가 그런다고 믿게 되는 상황이 있거든요
예전에 말했던 뭐 불편한 진실이나 이런것도 비슷한 얘기 같은데
누가 그렇다고만 믿는 것들
이제 그게 지금까지도 어찌보면 계속 내려왔어요
내려왔고
이제 뭐 제가 아까 페이스북 처음 봤다 그랬잖아요
그 페이스북에서도 대여부는 이제 어느정도 쓴다라는 개념이 좀
많더라구요
근데 뭐 간단한건 만들어 쓴다라고 하는 회사도 되게 많고 사실은
PC쪽만 하는 사람들은 이제 아 STL 쓴다라는 식으로
이제 많이 얘기를 하시는데
문제는 제가 그렇게 PC게임을 만들었다가 나중에 콘솔로 바뀌면서
그것 때문에 엄청 힘들었던 프로젝트들을 몇개 알아요
그리고 그것 때문에 이제 32비트 지금 64비트 많이 쓰지만
32비트 게임이 점점 커지기 시작할 때 메모리가 커지고
그 순간에 메모리 파편화가 되니까요.
그 순간 때문에 더 이상 메모리를 못 잡는 경우가 나는 경우도 봤거든요
그래서
그래서 어찌보면은 그
좀 까탈스럽게 게임을 만들었던 회사
그리고 엔진이 끝까지 잘 유지되고
나중에 가면서 이제 이렇게 게임을
제가 볼때는 그렇게 보는거면
게임을 이렇게 스케줄 따라 잘 냈던 회사
큰 이렇게 나중에 뭐 이상한거 터져갖고 막 고치는데 이상한 노력 안하고
그런 회사들은 굉장히
월드 레벨로 짰어요
그런식으로 어레이 기반으로 짜거나 아니면 자체 컨테이너를 만들 때
컨테이너가 이제 STL에서 쓰는 것보다는 좀 제한적이라는 거
특히 이제 메모리 관리 쪽이라던가
메모리 이제 재활당이라던가 이런 부분에서 되게
제한적으로 만든 일을 많이 봤고
그 다음에 EA가
그니까 제한적으로 만든 데 단점은
인터페이스가 STL 컨테이너의 인터페이스가 다르죠 당연히
그러면은
뭐 STL 컨테이너 인터페이스가 별로 좋다고는 생각하지 않아요
뭐 굉장히 서로 다른 컨테이너끼리 똑같은 게임인데
인터페이스를 유지하기 위해서 이상한 짓을 많이 하고
뭐 거기다 알고리즘을 넣기 위해서 또 이상한 짓을 많이 하고
원하는 바는 뭔진 아는데
일단 그 방향성 자체가 좀 너무 익스트림으로 간 OOP 케이스라고 저는 보고 있고
그리고 요즘 최신 나오는 모던한 그런 언어들에서는 그 방향을 더 이상 안 가잖아요
컨테이너별로 이제 특화된 좀 인터페이스가 있고 공통된 거는 공통되게 가는데
그런 식으로 많이 가게 되죠 게임 회사에서 만들면
근데 그중에서도 유일하게 이제 정말 STL C++ STL의 그 규격에 똑같이 하면서도
자기네가 좀 더 뭐 메모리 할당을 좋게 한다거나 내부적으로 좀 더 성능을 높이 올린다는
그런 측면에서 만들었던 STL도 하나 있고요
그게 EA에서 만들어온 EA STL이라고 있고 그거는 오픈소스라서 많이 쓰기는 해요
그리고 일단은 STL이 이제 되게 간단한 것만 쓰면 만들었을 수 있는데
그 이상은 안 되거든요
그 이상이 되는 좀 더 복잡한 거를 쓰기 시작을 하면은
이제 그런 EA STL 정도를 가져다 갖다 쓰는 것도 좋죠
이제 메스 라이브러리를 직접 안 만드는 사람이 있듯이 STL 라이브러리도 직접 안 만드는 사람이 나오곤 있는 거예요
근데 뭐 어찌 보면 대부분의 게임에서 다행이라고 할 점은
쓸 수, 뭐 써야 되는 게 Array, Vector, Map, Set 이 정도가 솔직히 대부분이 쓰는 거지
거기서 좀 더 깊이 들어가는 경우는 좀 덜 쓰잖아요 사실은
그래서 그런 의미에서는 뭐 만들어 쓰는 것도 아직도
유효하고 EA STL을 씁니다 라고 하는 사람도 저는 박수 쳐줄 것 같고
C++ STL을 직접 씁니다 라고 하는 사람들은 조금 걱정할 것 같아요
솔직히 제 개념은 그래요
그래서 일단 그게 있고
근데 또 재미있는 거는 이제 Unreal Engine 4를 보면은 그게 오픈소스로 되어 있어요
굉장히 오랫동안 오픈소스로 되어 있었고 모든 엔진의 코드를 볼 수가 있어요
그리고 제가 Unreal Engine 4를 좋아하는 것 중에 하나가
근데 문서가 잘 되어 있어요
걔네 웹페이지에 가면은 코딩 스탠이라도 문서가 있어요
우리가 코딩을 어떻게 짰고 이렇게 코딩 스타일을 따라라
굉장히 좋은 어드바이스들이 많고
또 하나 여기서 주목해야 될 거는
걔네들도 자체 STL이 있어요
자체 이제 뭐 Vector 같은 타입이 있고 자체 Map 같은 타입이 있어요
STL하고는 다른데 걔네는 기본적으로 그걸 써요
이유는 제가 아까 말한 거랑 똑같아요
아 뭐 그렇게 복잡하게 할 필요 있냐
어차피 간단하게 하면 되는 거 아니냐라고 말해도 되는데
걔네가 지금 추구하는 플랫폼을 보면은
예전에 뭐 당연히 PC 할 때는 좋았죠
XBOX 할 때도 그때도 이제 가상 메모리가 제대로 안 돌았기 때문에
그런 문제 있으니까 그때부터 갖고 온 걸 수도 있는데
그래서 아 요즘은 이런 세상이 돼서 걱정이 없지 않냐
이제는 뭐 최신 콘솔도 이제 제대로 지원하지 않냐
라고 말하는 순간 모바일폰 지원해야 되고?
이제 안드로이드 TV 이런 이상한 플랫폼 지원해야 되고
그 메모리가 훨씬 작은 이상한 플랫폼을 지원할 수밖에 없고
거기서 메모리 할 땅이 어떻게 될지 OS가 제대로 지원할지 모르는 상황이거든요
그 상황에서 이제 그런 걸로 폴팅을 하기 시작한다고 하면은
난리가 나는 거죠
게임에 있는 코드를 뒤집어야 되는 상황이 오는 거죠 사실은
근데 그걸 처음부터 잘 관리를 해야 할 때면은
게임에 있던 코딩은 두고 나머지 것들을 이제
그러니까 엔진 쪽에서만 좀 고치면 되는 거고
그런 것도 있는 거 같아요
대표적인 얘가 이제 또 하나가 이제
마이크로소프트가 마인크래프트를 하나 사갔잖아요 예전에 모장으로부터
그리고 그 뒤에 마이크로소프트 아니 그니까 마인크래프트 게임이 여러 플랫폼으로 나왔어요
지금 PC, UWP로도 나왔고 이제 뭐 안드로이드폰으로 나온 것도 알고 있으실 거고
엑스박스로 나온 것도 알고 있으실 거고
처음 모장이 만든 건 자바였거든요
근데 이제 얘네들은 당연히 다른 플랫폼 가야 되니까
당연히 자바로는 안 되니까 다른 언어로 폴팅을 했겠죠
그럼 그거를 지원하면서 메모리 관리는 어떻게 하겠어요?
그냥 자바에서 했던 레퍼런스 기반으로 무조건 다 던질 수 있겠어요?
그럼 인베드 시스템에서? 불가능하다고요
그럼 걔네들은 엄청난 엔진형을 집어넣어서 고친 거예요
근데 이거를 처음부터 짰던 사람이
아 이게 언젠가는 클 수 있구나 생각을 하고
컨테이너를 만드는데 아니면 컨테이너를 만드는 패턴을 확실히 정립하는데
초기에 정말 한 길어봐야 1주 미만이거든요
그 1주 미만의 시간을 퍼부어서 그걸 만들어 놨다면
그 나중에 해야 되는 폴팅 작업이나
그런 게 훨씬 쉬웠을 수밖에 없어요
왜냐면은 코드 리팩토링 하시는 분들 알겠지만
코드 하나 바꿀 때마다 어차피 테스트 다 해봐야 되는 거니까
그런 걱정이 없는 거죠
이미 존재하는 이 라이브러리, 인터페이스 정해져 있고
인터페이스 바꿀수록 그냥 그대로 갈 수 있으니까
그러면서도 메모리 그렇게 걱정 안 해도 되니까
근데 저는 특히나 이제
뭐 딱 플랫폼 하나용으로 만드는 게 아니면
뭐 게임이든 인베드 시스템이든 가끔 플랫폼 하나용으로 만드는 프로그램이 있어요
그거는 그냥 어떻게 되면 솔직히 상관은 없어요
근데 그게 아니라 여러 플랫폼으로 가야 될 게임이나 애플리케이션이나 이런 것들은
그 뭐라 그럴까 애플리케이션 레이어와 엔진 레이어의 분리가 굉장히 중요한 것 같아요
인터페이스를 통한 그니까 뭐 제가 말한 뭐 인터페이스
OOP에서 인터페이스를 얘기하는 게 아니라 API 인터페이스
그러니까 한마디로 함수 호출 어떤 시그네트를 쓸 거냐
그러면 애플리케이션 레이어에서는 이 함수를 호출하면 언제나 자꾸
작동한다는 걸 가정을 하고 엔진 레이어에서는
그거를 따로 이렇게 구현만 해주면 되는 거거든요
근데 이게 어찌보면은
그 예전에 OOP 그룹에서 OOP에서 처음 나왔던 Inversion of Control이라고 있잖아요
컨트롤의 전환이라고 하는 거
그래서 그게 요즘 막 DI로 이상하게 변질이 되고 막 그랬는데
그 Dependency Injection으로
거기에서 주장했던 것도 솔직히 저는 그런 부분이라고 봐요
내가 이거를 바꿨을 때도 밑에는 무리 없이 돌아야 된다
아니면 밑에를 바꿔도 위에는 안 깨져야 된다
이런 개념으로 보는데
그거를 이렇게 레이어별로 분리가 아니라
거의 오브젝트별로 분리를 한 느낌? 이제는?
그래서 수백만 가지의 조합이 나와서 이상해질 수 있는
되게 관리하기 힘들어지는 그런 개념인데
사람 두뇌에서는 두 개는 쉽게 분리 가능하다고 생각을 하거든요 저는
그래서 그런 식으로 확실히 분리를 해주고 사용하는 습관이 들어야 되는데
모르겠어요 이거는 거의
안 그런 사람이 더 많지 않나 싶은 생각이 들어요
그러니까 좀 딱 원칙이나 바운더를 정해놓고 코딩을 못하는 사람들
제가 이거를 또 다른 곳에서 느꼈던 게
최근에 또 다른 이상한 짓을 하고 있는 게 하나 있는데
최근에도 그런 걸 느꼈어요
굉장히 요즘 유행하고 있는 그런 웹패러다임이 있는데
거기서 이제 하는 좋은 가지 두 가지가 있어요
그냥 이제 여기서 이득이 되는 왜 그래야 되는지는 알겠는데
이거를 사람들이 관리를 못하는 거예요
어떻게 해야지만 이게 나중에 관리가 되고
나중에 뭔가 변하더라도 쉽게 쉽게 바꿀 수 있고
이런 생각을 해야 되는데 그냥 너무 이상적으로 간 건지
그냥 너무 자세히 알아보지 않고 그냥 아 이렇게 하면 되는구나 해서
그냥 수백만 가지를 던지는 건지는 모르겠지만
그게 잘못돼서 나중에 관리가 안 될 수 있는 그런 이상한 패턴을 따라가고 있는 게
보이는 게 하나 있어요 그게
단순히 몇 명의 문제에 따라서 관리가 안 되는 게 아니라
전체 인더스트리에서 그렇게 가고 있는 게 보이고 있고
저도 그거에서 열심히 고생을 한 끝에
그 중간에서 이거를 어떻게 원칙을 세워서 이런 패턴으로 가면은
훨씬 낫겠구나라는 생각이 드는 게 있거든요
그래서 그런 뭐 그거는 정리되면 나중에 더 자세히 얘기할 거고
그런 식의 사고방식을 발전시키는 게 되게 좋을 것 같아요
그러면 그걸 하려면 역시 제가 좀 전에 예를 들었던 뭐 언리얼이라던가
무슨 제대로 만든 엔진들이라던가 이런 걸 봐가면서
얘네들은 이렇게 했구나
아 그리고 왜 이렇게 했을까를 고민해 가는 과정이 되게 중요하다고 보거든요
그래서 뭐 제가 나서 갖고 언리얼 엔진을 고치고
막 이거를 뭐 몇 주 동안 고쳐 갖고 아 내가 이거 하나 고쳤어 라고
좋아하는 스타일이 아니기 때문에 저는 안 그러는데
가끔 어떤 분들은 그런 거를 직접 고치시는 분도 있더라고요 그냥
열심히 고치는 거 좋아하고 나중에 열심히 열심히 고쳤고
또 이제 오픈소스니까 거기다 공헌도 해보고
그럼 거기서 또 이제 받아들여지면은 이제 나는 거기 공헌자라고 좋아하시고
그리고 그게 좋으면 계속 하시는 것도 있는데
그런 분들이라면은 그리고 그런 분들이 게임에 있다면은
저는 언리얼 엔진을 한 번쯤 그런 식으로 들여다보고 거기에서 넣어놓은
수많은 제약점을 이해해보는 거 되게 좋을 거라고 생각해요
게임 개발자로서
그리고 또 하나의 장점은 이제 이게 오픈소스가 돼가면서 이상해지는 거죠
그래서 오픈소스에 참여해가지고 열심히 컨트리뷰트를 하고
그래서 이제 본사에서 아 얘 참 잘하는 애구나
컨트리뷰트 대충 하는 게 아니라 잘하는 애구나라는 게 이제
인식이 되면은 그렇게 채용을 하는 경우도 있더라고요
그래서 뭐 제가 이렇게 나아가는 채용 방식은 아니지만
저는 그 정도로 끈기가 좋지는 않기 때문에
그렇게 채용되시는 분들을 보긴 봤어요
그래서 제가 이렇게 나아가는 채용 방식은 아니지만
그래서 정말 이제 뭐 말도 안 되게 북미 취업을 하겠다고 하시는 분들 중에
아 그래 난 오픈소스 컨트리뷰트에서 북미 취업할 거라고 생각하시는 분들이 계시면
그것도 불가능한 방법은 아니에요 사실은
그리고 심지어는 제가 또 마소 쪽에서 하나 말씀을 드리면
마소에서 옛날에 XNA라는 플랫폼이 있었어요
여기도 굉장히 잘 만든 게임 엔진이었는데
제가 그래서 많은 사람들한테 이걸로 배우라고 추천을 했었는데
지금은 죽었죠 그게 이제
더 이상 만들지 않는데
그 XNA가 나왔던 시점에 커뮤니티에서
그 XNA에 굉장히 포럼글에 댓글을 잘하고
XNA가 이런 게 있으면 이런 식으로 패턴을 만들어서 이렇게 만들어라 라고
되게 답글을 잘 달아주는 사람이 있었어요
이름은 얘기할 수 없겠지만 그 사람이 나중에
제가 마소 세미나 가보니까 MVP 세미나 같은 거 가보니까
거기서 디렉텍스 팀에서 실제 일하고 있더라고요
그니까 그 당시에 윈도우스 폰 지원하고 이런 거 때문에
이제 디렉텍스 라이브러리를 전부 다 하나로 뭉쳐가지고
모든 걸 지원하게 만드는 과정이었거든요
그때 그 사람을 채용해가서 그 사람이 거기서 일하고 있었어요
그래서 그런 것처럼 오픈소스에서 열심히 작업하고 활동하는 게
직업을 잡는 데도 도움이 되긴 돼요
그게 반드시 이걸로 잡을 수 있다는 건 모르겠지만
그냥 자기 성향이 그런 사람이고 그런 걸 좋아하는 사람이라면
그거를 통해서 이제 돈을 번다고 얘기를 하죠
돈을 버는 방법을 찾는 거죠
그런 방법을 찾는 게 나쁘진 않은 거 같아요
오늘 얘기도 뭐 보통 때와 같이 주저리주저리 말이 많았는데
처음 시작은 그냥 STL 얘기로 시작을 했고
제가 생각하는 STL은 저는 쓰지 말자는 주의에 좀 가까워요
근데 요즘 또 막 그 뭐 무브 컨스트럭터 나오고
막 이런 알로데일 레퍼런스 나오면서부터
아 이걸 내가 직접 만들어야 되나? 이 생각도 솔직히 많이 드는데
제가 엔진을 만들었을 때는 마지막 엔진을 제가 제 손으로 직접 잘 만들었을 때는
그냥 선보일 시간이어서 다시 한 번 검토는 해보긴 해야 돼요
근데 제가 만약에 STL을 쓰겠다고 결정을 한다면
저는 E의 STL로 갈 가능성이 되게 많아요
그래서 그 정도 이제 제 생각을 말씀드리고
그리고 이제 STL을 쓰더라도 언제나 메모리 관리 쪽을 제일 신경써야 되고
특히 이제 벡터 같은경우에 리조브 함수가 있잖아요
리조브가 가능하다면 리조브를 반드시 해야 돼요
근데 그걸 안 하는 사람들이 되게 많아요
그걸 강요하는 이제 패턴 자체가 STL에 없었고 너무 자유롭기 때문에
그래서 그런 거였고
이제 그런
까다롭게 빡세게 코딩한다는 거는
이게 굉장히 개발 속도를 느리게 만들지 않는 이상은
대부분이 좋은 일이에요
그 이유가 일단은 유지보수가 되게 쉬워지고요
그리고 일단 뭐 나중에 디버그라던가 아니면 뭐
사람이 코딩 이해하는지도 편해지고
그래서 그런 원칙을 지키며 코딩하는 거 자체가
나중에 가서 뒤에서 유지보수나 리플렉터링이 되게 쉬워지고
그리고 나중에 가면 큰 시스템을 디자인하는 것도 되게 도움이 돼요
또 그런 거를 보고 싶으면 괜찮은 오픈소스들
나쁜 오픈소스가 아니라 괜찮은 오픈소스들을 좀 보길 원하고
게임 쪽이라면은 저는 언리얼4를 굉장히 괜찮다고 생각을 해요
참고로 유니티가 오픈소스가 안 되는 이유는
코드가 되게 구리기 때문입니다
그래서 그건 업계에서 흔히 돌고 있는 유니티는
코드를 보는 순간 암 걸린다고
그래서
뭐
그만큼 이제
유니티의 문제는 조금씩 더 많아지는 반면에
언리얼에는 좀 더 강해지는 이유이기도 하겠죠
유지보수가 쉽다는 거 자체가
그래서 그 정도로 정리를 하고
네 포프였습니다
