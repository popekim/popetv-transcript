옛날에 한번 좀 오래된 비디오인데 c++에서 유니코드란 참 이런 비디오를
올린 적이 있어요 그때 이제 얼마나 c++에서 유니코드 지원하기가 힘든지
를 얘기했었는데 그때 이제 제가 물론 유니코드의 까탈 속에 들어가면
코드 페이지 있고 글자 있고 이런 게 있는데 그거에 대해서는 이제
이제 저랑 이제 한번 한두번 얼굴 본 적이 있었고 그 당시에는 고등학생
이었지만 굉장히 미래가 촉망되는 프로그래머였던 여전히 촉망되는
프로그래머에요 그 종찬씨 최종찬 님이라고 하죠 극존칭 최종찬 님
이 좀 아 이런 건 용어를 좀 이렇게 제대로 정립을 해야 된다라고까지
얘기를 해줬고 그때는 이제 유니코드를 그래서 아 그렇구나 어차피 나는 유니코드를
별로 만들 일이 없으니까 c++에선 신경 쓰지 말자
라고 넘어갔었죠 그러다가 이제 최근에 다시 좀 유니코드를 지원해야
되는 c++ 게임 엔진을 개인적으로 조금 만들고 있고
그런게 있어서 생각을 좀 많이 했었어요 과연 이제 내가 멀티 언어를 제대로
지원하려면 어떻게 해야 될까 그러다가 이제 다시 유니코드 스펙을 좀 더 보고
고민을 많이 했죠 그러다가 재미있었던 재밌는 웹사이트를 하나 찾았어요
그러다가 재밌었던 재밌는 웹사이트를 하나 찾았어요

u tf8 f w !!인데 한국말로 하면 utf8을 모두 나 쓰자 이 얘기였는데
Qué hacia
결과적으로 유닛코드가 처음 나올 때 세상에 있는 모든 글자는 2바이트
로 표현이 가능하다. 그러니까 지금 우리가 아스키코드는 0부터 255
고 영어만 표현이 가능하고 예전 에는 한글을 하기 위해 거기에 또
이상하게 섞어놓잖아요. 근데 처음에 유닛코드가 나올 때 딱 2바이트
만 있으면 2바이트면 2에 16승이거든 요. 그 안에 세계의 모든 언어를
쳐박을 수 있다라고 생각을 했어요 . 그래서 그것 따라 윈도우스 쪽에서
만든 게 멀티바이트 코드라고 유닛코드 가 조금은 아니에요. 그래서 2바이트
에 모든 걸 들어가게 만들었어요 . 그래서 윈도우스 api 쓰시는 분들
보면 가끔 멀티바이트 코드 만들고 이런 거 있잖아요. 그게 바로 그
규격이에요.
그래서 그 일부분은
utf-16 가고 맞긴 맞아요. 근데 나중에 보니까 전세계 언어가 다
안 들어가. 중국 놈들 나뻐. 이게 된 거야. 솔직히 중국어도 대부분
2바이트 안에 들어가요 사실은. 근데 그 상황에서 그러면 아 그러면 어떤
캐릭터를 표현하기 위해서는 4바이트 가 필요한 거예요. 요즘은 유닛코드
에 아이콘도 들어가요. 이모티콘 . 그래서 4바이트가 필요하니까
이 유닛코드 아까 말했던 멀티바이트 는
작동을 안 하고 대신 utf-16에 제대로 된 규격은 이 기본 단위가 2바이트
을 뿐이고 이게 하나가 넘어가면 2바이트를 더 추가해서 4바이트가
될 수도 있는 거예요. 그리고 뭐 더 추가하면 뭐 더 늘어나면 6바이트
도 될 수도 있고 8바이트 될 수도 있고 이거는 하나하나에 그 짤리는
그거 있죠. 뭐라 그럴까. 증가 단위 가 2바이트일 뿐이에요. utf-16이 그렇게
나왔고 그런데 재미있는 거는 utf-16 이라는 거는 바이트가 1바이트 2바이트
가 있는 거잖아요. 그럼 메모리에서 첫 번째 바이트 두 번째 바이트
가 들어가요. 왼쪽 오른쪽으로. 그런데 이 메모리 구조상 cpu 아키텍처
상 리틀 앤디언과 빅 앤디언이 있거든 요. 의미는 뭐냐면 제일 왼쪽에
있는 게 메모리 구조에서 이게 바이트 0이야 1이야 그거예요. 그래서 그것
따라 이제 순서에 차리죠. 그러니까 2바이트를 박으면 이게 1 2 이렇게
할 수 있어요. 순서로 0 1 이렇게 하거나 그 반대로 0 1 이렇게 하거나.
이게 4바이트가 되고 똑같아요. 0 1 2 3 이 순서로 가거나 0 1 2 3 이
순서로 가거나. 그래서 그것 때문에 이제 똑같이 규격을 정해도 어떤
앤디언을 쓰는 거에 따라 이게 바뀔 수가 있어요. 그래서 utf-16도 그런
거를 지원을 해요. 이게 뭐 이쪽 앤디언인지 저 앤디언인지. 한마디로
엄청 골아프죠. utf-30이라는 거는 기본적으로 한 모든 그러니까 최소
크기 한 글자의 최소 크기가 무조건 32 32 비트라는 거예요. 4바이트
32 비트라는 거예요. 그래서 아스키 코드 a를 넣어도 이거는 32 비트
다. 이 개념이 되는 거죠. 그래서 이거는 뭐 세상의 모든 단어를 한
단 모든 글자를 현재 한 4바이트 블록에 넣을 순 있지만 그만큼 낭비
가 많아지는 그런 것도 있는 거고 .
아까 말했던 그런 바이트 뒤집는 문제가 없어요. 있을 수가 없죠.
그 대신에 또 재밌는 게 아스키 코드를 그냥 줬을 때 아스키는 0부터
128이잖아요. utf-8 스펙대로 보면 은 이게 그냥 똑같아요. 아스키 코드
는. 근데 아스키 코드가 아닌 게 넘어갈수록 이제 바뀌는 거니까
127까지는 7까지는 아스키랑 똑같 고 그 다음부터는 달라져요. 그래서
utf-8 everywhere로 돌아가면은 얘네 가 하는 말은 utf-16 버려. utf-30
버려. 다 버려. 그냥 utf-8으로 가. 이게 제일 깔끔하고 제일 편해 라고
말하는 거예요. 그래서 저도 이제 고민을 하다가 저도 내부 구현을
결과적으로 utf-8로 다 갔어요. 그 이유가 뭐냐면 utf-8이 아까 말했던
127까지는 아스키랑 똑같잖아요 . 그리고 그 다음에 이제 다른 캐릭터
들. 예를 들어 한글 캐릭터를 만들 때는
이게 한글 캐릭터를 만들 때 한글 캐릭터를 만들 때는 한글 캐릭터를 만들 때는 한글 캐릭터를 만들 때는 한글 캐릭터를 만들 때는 한글 캐릭터를 만들 때는 한글 캐릭터
뜨면 한글 캐릭터가 되는 거예요. 한글 캐릭터가 되는 거야 . 방금 말했어요
. 솔루션 요새 기술 수준 세대에 보면аются ios2 중의 몇 번 보면
이 boils.tar 하나를 Lionutrientoniage.공 jest
동원 дисvenir Marker하고 요리를 해� sayin 하 끊은번 comrades도 말 Chapo
요.
제일 앞에 게 제 기억에는 0이면은 그걸로 글자가 거기서 끝나는 거예요
그래서 만약에 string_length 함수를 뭐 쓰거나 그럴 때도 그냥 제일 앞에 비트가 0인지에 따라 그게 실제 string 그
뭐라 그럴까 depth라는 걸 확인할 수, 아니 string 길이라는 걸 확인할 수 있는 글자가 거기에 하나가 있다
그리고 만약에 얘네가 계속 연결이 되는 거다 이래서 byte가 연결이 되는 거다 그러면 첫 번째 byte만 봐도 나와요
첫 번째 byte가 3개가 1, 1, 0 그러니까 0으로 시작하는 거 거기서 끝나는 거고 1, 1, 0으로 시작하면 그게 2byte짜리 글자예요
그리고 그게 1, 1, 1, 0 이면 그게 세 번째 그리고 byte가 3개 그리고 1, 1, 1, 1, 0 그럼 4개잖아요 1, 2
그리고 0이 붙잖아요 그러면 byte가 4개짜리라는 거예요
그리고
그리고 그 뒤에 오는 모든 byte들은 1, 0으로 시작을 해요
그래서 string_length 구하는 함수를 만들 때도 byte에 쫙 쳐박아두고 앞에 거만 딱 보면 되는 거예요
너 내게 이게 0이야? 1, 1, 0이야? 1, 1, 1, 0이야? 1, 1, 1, 0이야? 이런 식으로
그러면은 그리고 점프를 하면서 숫자, 그러니까 string_length도 쉽게 구할 수 있고
그래서 이제 이거를 쓰기 시작하면은
보통 character_array를 쓰잖아요 uint8_array 그 array 길이가 string 길이가 아니게 되는 거죠
그래서 근데 단점은 윈도우스 자체에서 UTF-8을 그렇게 잘 지원하지 않아요
그래서 요즘 씨뿔뿔에서 조금 함수가 나오고 이런 게 있긴 한데
그 윈도우스 API는 여전히 다 아까 말했던 multibyte, UTF-16에서 약간 들떨어지네 그렇게 작용을 하고
그래서 UTF-8 everywhere에서 말하는 건 뭐냐면
그러면 네 프로그램 안에서 도는 모든 string은 기본이 UTF-8이라고 가정을 해라
네가 코드를 짤 때 그러면 하나로 통일되니까 이게 ASCII 캐릭터인지 유닛코드 캐릭터인지 고민할 필요도 없고
딱 하나로 가고 마지막에 외부 API 호출할 때 예를 들어서 파일 읽어온 API라든가
이런 걸 호출할 땐 걔네는 multibyte를 받을 수밖에 없거든요
그럼 그 순간에만 씨뿔뿔 함수 중에 UTF-8을 16으로 바꾸는 게 이제 들어왔어요 그런 식으로
그래서 변환을 해서 호출을 하고 아니면 뭐 또 역시 읽어오는 게 있으면
API에서 읽어온 다음에 그 순간에 다시 UTF-8으로 변화해서 네 코드 안에서는 UTF-8으로 돌아와라
그 얘기래요 그러면서 이제 하는 얘기가
UTF-16을 쓰는 이유 중에 하나가 사실은 웬만한 한국 언어들이 2바이트에 다 들어가요
한국 언어는 다 2바이트에 들어가거든요 그래서 굳이 3바이트를 갈 필요가 없으니까 공간을 아낄 수 있다 이건데
솔직히 요즘 메모리가 좀 많이 남기 때문에 전보다 3바이트씩 쓰더라도 코드가 깔끔해지고
그러니까 모든 게 좀 이렇게 명백하게 드러날 수 있다면 UTF-8이 낫다는 거죠
그리고 UTF-8의 장점 중에 또 하나가 제 생각에는 그거예요
ASCII 코드를 많이 놓여서 코딩하다 보면 한글 넣을 필요 없고 영어만 해도 되니까
ASCII 코드가 들어가는 순간에 그 ASCII 코드가 그냥 이제 쉽게 읽을 수 있는 거죠 어떻게 얘기하면은
그 실제 우리가 여태까지 보던 ASCII 코드랑 일치하는 코드가 있는 거죠 어떻게 얘기하면은


그런 것들을 유지한다는 것도 프로그래머 입장에서 큰 장점 중에 하나예요
그리고 아까 말했던 Indianness 이게 Byte order가 0 123인지 3210인지 그거에 따른 구분이 없다는 것도 장점 중에 하나고요
그래서 저도 코드를 일단은 그 방향으로 짰어요 그래서 저도 이제 UTF-8이 기본적으로 지원하는 유닛 코드이고
다른 유닛 코드는 절대 지원 안 하고요 그러나 저는 약간 한 가지다르게 한 게 뭐냐면 저는 ASCII 스트링을 따로 뺐어요 그래도
왜냐하면은
내부적으로 저는 이제 유저한테 보여주는 스트링도 아니고
뭐라고 얘기해야 될까
유저한테 보여주는 게 아니고
파일 시스템을 긁는 것도 아니고
그냥 제 프로그램 안에서만 도는 거
그런 건 솔직히 굳이 제가 유니코드를 써야 될 필요성을 못 느꼈거든요
그래서 솔직히 제가 클래스를 두 개 만들긴 했어요
스트링 하나하고 유니코드 스트링하고
그리고 이제 그 안에 어섰트를 열심히 박아서
아스키 스트링은 제일 앞에가 언제나 0이라는 걸 확인을 하고
utf-a 스트링은 제가 말했듯이
아스키도 솔직히 포함하는 개념이기 때문에 그냥 냅두고
그래서 이제 그 두 스트링 클래스의 차이는
일반 스트링 클래스는 이제
그 길이가 배열의 길이가
실제 스트링의 길이라고 가정을 하죠
이제 그거를 디버그 때는 이제 어섰트를 박아놔서
앞에가 0이 있는지 없는지 확인을 해서
확실하게 사람들이 코드를 유니코드를 넣는 순간
어섰트가 나게 바꾼 것뿐이고
그래서 외부에서 들어오는 스트링들은 절대 여기에 못 들어가게 돼 있어요
그래서 그런 식으로 이제 어섰트를 통해서
좀 이용을 좀 제한을 한 게 전부고
그래도 제가 utf-a 네브리어 읽어보고
한참 고민도 해보고 이것저것 코딩도 짜봤는데
확실히 가장 깔끔해요 가장 깔끔해요
약간의 문제는 있지만
좀 더 메모리를 과소비하는
이게 만약에 와이어 그러니까 네트워크를 통해
주고받아야 되는 스트링이라면은
압축을 하면 될 것 같긴 해요 사실은
압축을 해서 보내도 되고
뭐 그게 아니면은 뭐 그런 트래픽이 1.5배 늘어나는 거에 문제가 없다면
그냥 보내도 되고
생각보다 utf-8을 압축을 했을 때 압축률이 좋다고 나오더라고요
utf-8 everywhere 보면 나와요 그래서
그거를 보셔도 상관이 없을 것 같고
그리고 만약에 보낸 스트링이 순수하게 모두 다 한글이 아니라
대부분이 영어라면 영어하고 한글 비율이 80:20이라면
80%는 그냥 1바이트 쓰는 거고요 20%만 2바이트씩 더 쓰는 거거든요
그러면 실제 늘어나는 바이트 수도 그렇게 많지 않아요
뭐 압축키면 되고
그래서 제가 utf-8 everywhere라는 걸 봤고
저도 조금 구현을 해 본 상황에서 뭐 이게 아니라서요.

라이브러리가 엄청나서 누구한테 줄 수 있는 라이브러리는 아니에요
제 엔지니어 쓰기 위해 만든 간단한 클래스 몇 개일 뿐이지
써본 결과 저는 만족스러워요 그래서
유니코드를 지원할 생각을 하시는 분들
단순하게 그냥 지금 2바이트씩 박아 놓아서
지원 안 되는 캐릭터 무시하고 이럴 사람들이 아니라면은
한번 만드실 때 utf-8쪽을 고려해 보시는 건 좋을 것 같아요
물론 이거에 대해서 반발을 하는 사람들도 있긴 있어요.
이거 utf-16이 훨씬 나은 거다라고
현재 목이 잠겨서
웹 쪽은 전부 다 utf-8으로 거의 적립이 됐죠
utf-16이 나왔음에도 불구하고
utf-8을 거의 써요
웹 쪽은 영어가 많아서
그래도 이제 utf-8이 굉장히 많아지고 적립이 돼 가는 과정이고
제가 볼 때는 여러 가지 utf 확실히 스펙 중에 가장 많이 쓴 것도 utf-8이고
저는 그게 나쁘지 않다고 봐요
그래서 utf-8 쪽을 저는 개인적으로 추천합니다
제가 최근에 만들었던 유니코드 뻘짓을 공유를 했고
utf-8 everywhere 웹 사이트는 밑에 제가 붙이던가 할게요
예 포프였습니다
