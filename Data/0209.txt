오늘은 진짜 오랜만에 유니티에 대해서 좀 얘기를 하려고요.
제가 유니티 튜토리얼을 하는 건 아니고 유니티에 보면 이제 처음
사람들이 유니티 그러니까 굉장히 많은 사람들이 유니티를 처음 엔진으로
접하고 있고 유니티가 게임 엔진 의 루프를 구성하는 방법에 대해
조금씩 뭐랄까 좀 복잡하다 이상하다 이렇게 느끼시는 분들이 있어요
. 그래서 그냥 좀 이게 왜 이렇게 이런 일이 일어났나를 설명 드리고
싶어요. 사실 유니티에서 게임 오브젝트 라고 하는 거는 오브젝트가 아니에요
. 그래서 이게 사실은 그냥 그 뭐라 그럴까 이름표라고 하죠. 컨테이너
. 이름표예요. 그러니까 어디부터 얘기를 하면 좋냐 하면 예전의 게임
을 어떻게 만들었는지. 예전에 일단 제가 게임을 만들 때는 주로 이랬어요.
. 뭐 op 개념에서 예를 들어서 사람 클래스를 만들어요. 뭐 캐릭터
. 사람이라고 하죠. 캐릭터를 만들어요. 그러면 이 클래스에서 이 클래스
의 일부인 게 뭐냐면 사람도 캐릭터 일 수가 있어요. 그러니까 플레이어
라고 하죠. 플레이어도 있고 ai도 있어요. 그죠 ai면 npc 같은 경우
. 그러면 이게 둘 다 캐릭터에서 상속을 받아요. 그리고 이제 플레이어
는
. 뭐 뭐
뭐라 그럴까 그 피직스 물리 법칙 이 들어간다고 예를 하죠 일단
은. npc는 안 들어가고. 그러면 어 그러면 나는 이 캐릭터가 피직스
가 필요하니까. 그리고 다른 캐릭터 도 피직스가 필요할 수도 있잖아요
. 그러면 이 캐릭터에서 피직스 캐릭터를 만들고 그 피직스를 받는
캐릭터에서 사람을 만드는 거예요 . 그쵸 플레이어를. 그러면 npc는
만들 때는 아 난 물리 법칙 넣기 싫으니까 그냥 캐릭터의 상속을
받을래.
그래서 이렇게 나왔어요. 근데 게임을 만들다 보니까 어느 순간
뭔가 npc에도 물리를 집어넣어야 될 것 같아. 그러면 oop 상속 구조
는 어떻게 해요. 보면은 음 아 npc 를 여기서 따다가 이제 플레이어
하고 옆에 바로 옆에 그 아까 있죠 그 피직스 캐릭터 있던데 거기랑
넣으면 되겠구나. 그래서 넣는 거예요 . 근데 이걸 하려면은. 이게 뭐지


이 게임 기획자들은 솔직히 이거를 물리 법칙을 넣어야겠다 말겠다라는
그 결정은 예전에는 프로그래머 목이었죠. 게임 기획자가 별로 많지
않았던 시절이니까. 근데 요즘은 게임 기획자가 그런 것들을 많이
바꾸고 싶잖아요. 근데 바꾸고 싶을 때마다 프로그래머가 클래스 구조를
바꿔야 돼. 코딩을 바꾸고 컴파일 을 다시 해서 툴을 줘야 되는 거예요
. 얼마나 복잡해요. 그래서 아 이거를 왜 너무 프로그래머에 막히는 경우가
많다. 그래서 한 2005년쯤인가 게임 프로그래밍 잼스를 통해 소개된
그런 내용 중에 컴포넌트 기반 게임 오브젝트라는 개념이 있어요. 이게
뭐냐면 이제 뭐 상속 아니 상속이 아니라 oop에서 보면은 상속이 있고
아니면 컴포넌트 컴포지션이라고 하죠. 컴포지션이 있다라고 하는데
그 컴포지션 패턴인데 이 개념은 뭐냐면. 그 이런 상속 구작은 일단
없는 거예요. 아예 아예 없는 거예요 . 그래서 저는 내가 누구냐. 내가
누구다라는 이름 태그만 있는거에요
아이디라고 하죠 그냥
그걸 게임 오브젝트라고 유니티에서는 불러요
내 아이디는 뭐야? 게임 오브젝트
이름은 예를 들어서
아까 말했던 플레이어 그 전부에요
이게 아는거는 플레이어가 전부에요
그러면 어 플레이어인데
나는 위치가 있어야돼
아 그래 위치면은 나는
엔티티 컴포넌트
컴포넌트라는게 그냥 부품이라고 생각하시면 되요
엔티티 컴포넌트라는게 있어
이 컴포넌트는
그냥 x,y,z 위치하고
뭐 트랜스포메이션이니까
스케일이라던가 확장,축소
회전값을 정의하고 있는
플롯 아홉개가 전부에요
그러면
어떤 오브젝트든
원래 그
논문이라고 해야되나
기사에서 나왔던 내용은
이 컴포넌트가
내가 어떤 오브젝트에
속해 있는지를 알아요
이 컴포넌트 있죠 엔티티 이걸 만들면서
아 나는
엔티티 아이디가 아니라
오브젝트 아이디 플레이어에 속해있어
라고 카테가 달려있는거에요
그리고 이 게임엔진에는
이런 컴포넌트가
그냥 무수하게 많은거에요
물론 컴포넌트는 어떤 부모로부터 상속을 한번 받겠죠
그리고 이제 그냥
배열에 같이 박아놓고
여기 엔티티는 이 플레이어 1용
이 엔티티는 플레이어 2용
이 엔티티는 플레이어 3용 이런식으로 가는거에요
그래서 엔티티가 엄청 많아요
어 나는 화면에 그림도 그려야돼 그러면 이제 유니티에서는
메쉬랜드로 컴포넌트가 있죠
메쉬랜드로 컴포넌트 하는게 뭐냐
메쉬가 갖고 있구요 뭐 텍스쳐 머테리얼 같은거
커넥트 할 수 있고 똑같은 개념은 똑같아요
그래 난 새로운 메쉬 그걸 만들어서
어 나는 누구 메쉬꺼?
아 플레이어 1꺼 그럼 플레이어 1이 있고
아까처럼 배열에 박혀있는게 전부에요
거기다가 아까 피직스 얘기했죠
그럼 피직스도 하나 만드는거에요 나는
뭐 런어웨이 아니 런어웨이가 아니지 뭐
리지드 바디 피직스다 그러면 리지드 바디 피직스가 있고
내가 나를 가지고 있는게 누구냐
그리고 뭐 내가 만약에
헬스를 가지고 있는거면은
뭐 HP 컴포넌트가 있고
내가 만약에
뭐 뭐라 그럴까
AI를 가져야 된다 그러면
내 AI가 도망가는거에요
그럼 뭐 런어웨이 컴포넌트를 만들어서
AI 컴포넌트로 박을 수 있고
그리고 얘는 그냥
아까 말했듯이 오브젝트는 나는 누구요
라는거만 있고 실제
저도 이거를 예전에 한번
학교 다닐 때 구현을 했었거든요 2005년 정도에
그냥 재밌어 보여서
제가 그때 C로 짰었는데
그때 저는 오브젝트가 그냥
인테리어 하나였어요 아이디 해시코드 하나
그게 전부였어요
그리고 컴포넌트는 아까 말한 대로
클래스인데 이제 그런식으로 만들어서
배열에 박아놓고 쫙 돌리는거고
재밌는거는
이제 여기서 재밌는게 들어오는거에요
이게 왜 좋냐
이 컴포넌트만
미리 만들어 놓고
거기에 대입할 수 있는 값들이 있잖아요
프로퍼티라던가 뭐 예를 들어서 내 처음 위치가 어디냐
XYZ 이런거
그런거만 에디팅을 가능하게 해놓는다면은
프로그래머의 도움이 없이도
디자이너가 알아서 이걸 다
할 수가 있는거에요
어 난 이런 플레이어 너무 안되고
아 나 요번에 피직스를 넣고 싶어
아 그래 얘는 이걸 가져 이거 넣고 저거 넣고
아 NPC가 피직스가 없었는데
피직스를 넣겠다고? 그럼 갖다 넣으면 되는거에요
그쵸?
서로 연결만 해주면 되는거에요 새로 만들어서
그래서 디자이너에게 게임을
쉽게 바꿀 수 있는걸 주겠다고
만든게 이거였고
저희가 스페이스마린에서 실제로는 C로 닫자는 코드지만
거기서도 유니티 안썼구요
거기서도 저희는 똑같은 방식으로
실제 모든 오브젝트를 관리했구요
그러니까 2005년도부터는 되게 많은
회사가 그렇게 했어요 유니티는
이걸 한 이유가 말그대로
그 디자이너들도
게임을 만들 수 있다라는걸 하기 위해서고
그리고 유니티는 이제
C샵 기반이기 때문에 리플렉션이
잘 되어있거든요 그래서 프로퍼티라는걸
실시간으로 다 긁을 수가 있어요 어차피 C샵은
그래서 그거를 UI하고 연동하기에도
쉬웠고 그게 두가지 이유죠
그게 유니티의 컴포넌트 시스템이
생겨난 이유에요
그게 전부에요 사실은
디자이너들이 게임..잠깐만 죄송
제가 디자이너라고 말할때는
게임 기획자들이에요 제가 한국하고 쓰는
용어가 달라서 가끔 헷갈리는데
그렇게 됐고
그래서 이제 이게 사실은
멀티스레이딩에도
굉장히 유용한 방법이긴 한데
그건 잠깐 뒤에 말씀드리고
이 컴포넌트 기반으로 가면서
생기는 문제가 뭐냐
컴포넌트끼리 통신이
어려워져요 예전에는
예전에 게임 만들때는 어떻게 했냐면
플레이어1에 모든게 들어있잖아요
그냥 이 OOP 개념의 오브젝트에
어 내가 맞았어 그러면
헬스를 바꾸면 돼요 -1
뭐했어 그러면 이걸 업데이트 하면 돼요
근데 지금은 아까 말했던
플레이어에서 뭐 맞았다는 그런
뭐 뭐 뭐 피직스가 있다면
그 피직스 컴포넌트는
내가 어떤 컴포넌트를 가지고 있는지 전혀 모르는거에요
이 플레이어1이
알수가 없는거에요 원칙상은
그래서 나온 개념이 뭐냐면
서로 직접 통신을 주고도 하지 말라라
그 대신 이벤트 기반으로
가자 그게 이제
뭐 유니티에서 보는
브로드캐스트 메세지라는 그런 함수 있죠
그거에요 그니까 뭐냐면
내가 맞았어 그러면은
아니 그쵸 제가 이제
맞았어요 피직스에 딱 맞았어요
어 내가 맞았어 근데 난
피직스이기 때문에 전 헬스를 몰라요 그러면
나는 플레이어1인데
어 헬스
아 그니까 힙 뭐 뭐
블랙 그니까 총알에 맞았어
그리고 총알의 데미지는 뭐
O야 이런식으로 하던가 아니면 총알 아예
오브젝트를 주던가 컴포넌트를 그렇게 딱
브로드캐스트 메세지를 써놓으면은
그 단순하게
말씀드릴게요 뭐 필터링 메카니즘이 있지만
이 제 게임 세상에 있는
모든 오브젝트들이 그니까 모든
컴포넌트들이 그 메세지를
듣고 있는거에요 받았어요 메세지를
받았는데 어
플레이어1이 맞았대
그 예를 들어서 근데 이제 필터가 가능하다고 그랬죠
헬스 컴포넌트만
그걸 듣는다고 해볼게요 헬스 컴포넌트가
이 메세지를 언제나 들어요
맞았다는 메세지를 어
헬스 컴포넌트에요 저는 어 메세지를 받았어요
어 플레이어가
맞았대 그래 이 플레이어
넘버가 뭐야 플레이어1이래
근데 어 나는 플레이어2인데 에이 그럼 무시할래
무시하고 넘어가는거에요
근데 거기 만약에 헬스 컴포넌트가 플레이어1에
속한 헬스 컴포넌트가 있다 딱
듣고 오 나다
그러면 아 뭐 뭐
-5를 감하자 그걸 감한거에요
딱 감했는데 오
헬스가 0보다 밑이야
그런 경우 있죠 그러면은 저는
다시 또 메세지를 쏘는거에요
어 헬스가 0보다 밑이야 아니면
나 죽어야 돼 그러면
뭐 죽여줘 라는 메세지를 쏘는거죠 플레이어1
그러면 또 이제 플레이어1 메인클래스가 듣다가
어 날 죽이래
그러면 그냥 죽이는거에요
뭐 그거는 뭐 이제 엔티티 프레임
엔티티 메세지라던가 뭐 다른 메세지
다른 컴포넌트에서 하면 되는거고
그래서 모든거는 브로드캐스트가
기반이에요 이제 뭐 그래서
유니티가 브로드캐스트 기반으로
하는게 그 이유에요 그래서 만약에 유니티에서
컴포넌트를 직접 억세스하기
시작한다 이건 잘못된거에요
원칙상 진짜 잘못된거에요 근데
이제
재밌는게 아까 제가 말씀드렸잖아요
브로드캐스트를 한다고 모든 물체한테
이게 느려요
빠를 수가 없어요
c++에서 이거를 만들 때는 옵티마이제이션
어떻게 하고 막 어떻게 해갖고
실제 완벽히 순수
oop로 가는것보다 제가 만들었을 때는
한 속도 저하는
한 10%
20%정도의 미만이었던걸 기억을 해요
근데 이제
뭐라 그럴까
아무래도 c#은
c++보다 조금 느린것도 있고
그리고
오브젝트가 얼마나 많아지냐에 따라서 성능도 달라지고
이벤트 필터링을 어떻게 하냐에 따라서
달라지고 그래서 굉장히 최적화가
많이 들어가야 되는 부분이죠
그런데
게임쪽에서 그 10%가 느려지더라도
이걸 썼던 이유는
게임 기획자가 이걸
빨리빨리 바꾸면서 뭔가 테스트 할 수 있다는거
자체가 굉장히 큰 메리트에요
그니까
어떤 제품을 만들던간에
이터레이션을 10번을 돌리면 2번 돌릴 때보다 나아요
그럼 몇번을 반복할수록
빨리 반복이 가능할수록
프로타이어 빨리 할수록 좋은거거든요
그게 가능하기 때문에 한거에요
성능상의 약간 문제를 잡더라도 이걸 하겠다
똑같은 개념으로 이제 렌더링에서 라이팅을 베이킹하지 않는 이유가 똑같은거죠
아트에서
빨리빨리 바꿀 수 있고 볼 수 있고
그거 하는게 차라리 베이킹보다 낫다
1시간 2시간 걸리는
그래서 그렇게 갔었고
유니티는 재밌는게
그니까
제가 c++로 만들었을 때는
어떤 오브젝트한테만 브로드캐스팅하는 법도 있고
오브젝트를 쉽게 찾는 법도 있고
뭐 이런 여러개가 있었거든요
그리고 아니면 c였으니까
함수 이름으로 그냥 브로드캐스트라는게 아니라
이벤트 언제나 이벤트가 있고
그 이벤트 이름으로 if else 뽑는게 전부니까
리플렉션에 의존하지 않았기 때문에
좀 빠른걸수도 있죠
유니티는 그냥 함수 이름을 넣어요
브로드캐스트 함수 이름
그리고 패러미터 그러면 그 함수 이름을 가지고 있는
컴포넌트가 다 듣고 아 이거구나
지우자 하자 죽이자
막 이런걸 하는거고
그래서
유니티는
조금 느려요 아직 그 부분이
그래서 굉장히 많은 꼼수가 사실 있어야되요
그래서 이제 대표적인게
만약에 제가 예전에 한번 타일맵 에디터를 만든적이 있어요
화면에 2d 타일을 쫙 발라보고 싶을때
아 타일맵 에디터는
그냥 타일맵으로 된 게임이었나보다
그때
그냥 개념상으로는
뭐 각 타일을 오브젝트로 만들어도 상관없거든요
만들어보니깐
10x10 20x20 정도가 넘어가면
엄청 느려지는거에요
이 브로드캐스팅 때문에
그래서 결과적으로는
타일맵 매니저를 하나 만들어서
그 타일맵 매니저가 아예 오브젝트구요
그게 이제 차일드로 타일을 다 같이가 만드는거죠
그러면 이벤트는
얘 하나만 들어 그리는것도 얘 혼자 그리는거야
그리고 그 이벤트를 받아서
그 아래를 다 뭐
그 다음에 이제
매뉴얼하게 처리해주는거죠
그래서 그런 매니저 클래스로
그룹을 지어야 될 때가 꽤 많아요
그런 유니티에서
그래서 그런거 좀 신경을 쓰셔야 되고
그래서
갑자기 유니티의 속도가
오브젝트가 많아지면 느려진다
라고 할 때는
두가지 중에 하나에요
이제 오브젝트가 그리는 메쉬가 너무 작아서
배칭을 잘 안해줄 때
근데 유니티 아마 지금은 해주는거 같아요
옛날에 안해줬지만
근데 예전에 제 경우에는
그림을 안그리더라도
업데이트만으로도 엄청 느렸거든요
그래서 그런 브로드캐스트 메세지가
거기서 오는 단점이 있어요
그래서 그걸 필터링 어떻게 해주냐 이런거 생각을 많이 해줘야 되고
근데 이제
유니티가 어렵다고 생각하시는 분들은
제가 볼때는 대부분이 컴포넌트
때문이거든요
그래서 이게 왜 생겼는지를 알고
원칙상으로 이게 어떻게 작동해야 되는지
물론 저희는 게임을 만들기 때문에
원칙으로만 가지 않고 많은 해킹을 합니다
성능을 높이기 위해
그래도 원칙이 어떤거고
그런 스파게티 코드가 되는걸 잘 막아놔야
컴포넌트끼리 서로 호출하고
이런걸 좀 잘 막아놔야
나중에 코드 유지가 되게 편해져요
그래서 한번 꼭 말씀을 드리고 싶었고
이제 만약에
이게 궁금하신 분들은
찾아보세요 게임프로그래밍잼스에 어딘가 있어요
왜 이게 만들어졌고 어떻게 구조가 됐고
제 기억에 소스코드 이거잼플도
어딘가에 나왔던걸로 기억을 해요
3권이었나? 2005년?
2005년이 아니라 2004년이었을거에요
포프였습니다
비디오가 길어진거 같아요
