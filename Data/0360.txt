예 안녕하세요 포프입니다 오늘은 코딩 스탠다드에 대해서 코딩 컨벤션
스탠다드에 대해서 또 한 번 말을 하려고 해요. 제가 쓰는 코딩 스탠다드
에서 온라인에 다 널려있는데 제가 공개해놨는데 거기에 썼는지 안
썼는지는 기억이 안 나는데 안 썼을 것 같아요. 제가 회사를 돌리던
제 프로젝트를 하던 한 가지 제가 되게 까탈스럽게 구는 부분이 또
하나가 있어요. 뭐냐면 쓸데없는 함수 좀 만들지 말라고. 제 개념
에 쓸데없는 함수가 뭐냐면 함수 의 개념을 이해하는 사람들의 방식
이 되게 다른 것 같아요. 이제 퓨어 한 oop 진영에 예전에 약 많이 빨던
사람들은 모든 거는 oop에서 모든 거는 함수로 결정이 된다. 그래서
심지어는 한 줄짜리 코드까지 함수 로 짜서
호출하는 경우를 되게 많이 봤어요. 딱 한 번을 쓸지라도. 그래서 예를
들어서 파일 스트림이 있고 파일 스트림에서 단어를 하나 읽어서
그걸 이제 내 이름이라고 하자. 이름을 읽는 코드가 있으면 솔직히 그냥
파일 스트림에 넣고 이제 뭐 읽는 코드가 뭔지 모르겠지만 이제 읽은
다음에 name이라는 변수에 넣으면 되잖아요. 그럼 한 줄에 이미 보여요.
아 파일을 한 줄 읽는 거구나. 근데 이것마저도 그냥 read name이라는
함수를 만들고 거기다
이제 파일 스트림을 패스해 준 다음에 거기서 파일 스트림에서 읽고
스트링 반환해서 반환하는 경우도 있어요.
이제 제가 옛날에 생각해 보니까 여기서 학교를 다닐 때 그때가 이제
닷컴버블 붕괴되고 얼마 안 됐을 때거든요. 그때 이제 한참 자바교
이제 신자들이 많이 학교로 돌아왔 죠. 직장을 잃었기 때문에. 그 사람들이
꼭 그런 식으로 코드를 짜서 썼어요. 그래서 그 교육약이 남아있는 게
아닌가 싶고 그리고 어떤 경우에 그러니까 뭐 일단 나쁜 예는 한 가지
둘죠. 자세에 그러니까 뭐가 중요한 거냐에 따라 그런 코드를 짤 수 있다고
생각하는데 난 그게 왜 중요한지도 모르겠다는 거죠. 제가 보는 함수는
뭐냐면 함수를 짜는 순간 그 함수는 약속이라고 생각을 해요. 약속이라고.
저는 이제 함수에서 이제 그 함수가 있다는 거 있잖아요. 멤버 함수라고
하죠. 그러면 결과적으로는 저희가 흔히 생각하는 인터페이스랑 비슷한 거예요.
그러면 프로그래밍 인터페이스가 아니라 전구 키고 끄는 스위치가 있잖아요.
그러면 아 이거를 올리면 이게 전구가 켜지는 거고 이거 하면 그 반대의
상황이 일어나는구나. 이런 규약들이 있는 거거든요. 그러면 이제 이거는
그 모양은 그냥 전구 스위치 모양으로 있는 거고 프로그래밍에서는 그게
함수 이름으로 있다고 저는 생각을 해요. 그래서 그 함수 이름이 있기
때문에 이 함수 이름이 있고 여기에 들어가는 매개변수가 있어요. 그러면
내가 매개변수를 넣는 순간 이 매개변수를 가지고 이 함수 이름이
하는 그런 행동을 한 다음에 그 결과를 반환해주는 게 함수라고 생각을
하거든요. 그러면 이 모든 걸 함수로 짰다고 생각을 해봐요. 예를 들어서
나중에 이 함수를 바꾸고 싶어져. 그런 경우 되게 많거든요. 프로그래밍
하다가. 이제 뭐 굉장히 퓨어한 쪽에서는 또 아 그러면 그 함수를
바꾸는 건 말이 안 된다. 새로운 함수를 만들어야 된다. 아니면 새로운
오브젝트를 만들어서 여기다 또 랩핑해서 이상한 짓을 해야 된다.
라는 말도 안 되는 약을 파는 사람들 도 있는데. 그러면 그 암수를 바꾸는
데 그냥 제 얘기는 그거예요. 자동차가 고장이 났어. 그 부품에 하나가
좀 문제가 생겼어. 이 부품을 이렇게 개량만 하면 좋아져. 그럼 개량하는
게 좋은 거 아니에요. 그 부품을 낮추면 이제 다른 부품을 올려야 돼.
그건 아니잖아요. 그래서 그런 개념 으로 이제 고치는 일이 생각보다
많아요. 그리고 뭐 그런 퓨어하게 이제 뭐 op를 되게 사람들이 이해
못하는 수준까지 굉장히 추상화를 시킨 사람들은 이미.
약을 팔다가 많이 망했다고 보고 이제 요즘은 그런 얘기는 좀 덜
들리거든요. 그래서 오히려 사람들이 이제 제가 말하는 쪽인 이렇게 함수를
고쳐 쓰는 쪽을 흔히 하는 것 같아요. 근데 재밌는 거는 함수를 만들었어요.
무슨 함수든 간에. 그 함수를 고쳐요. 그쵸? 그러면 그 함수의 행동이 약간
바뀌는 경우가. 행동이 바뀌니까 함수를 고치는 거지 사실은. 그럼
바꿔요. 그러면 이 함수를 호출하는 모든 코드를 확인해야 돼요. 과연?
내가 바꾸는 거 전에 있던 그런 행동을 이제 거기에서 이상하게
이제 해석을 해서 그거를 쓰고 있지는 않았는지. 아니면 이 함수에서
잘못 반환한 값 자체를 또 어떻게 뭔가 해갖고 이상하게 돌려쓰고
있지 않았는지. 그걸 확인하는 게 정상이에요. 그쵸? 그러면 내가
함수를 딱 고치는 순간 딴 데 가서 이 코드를 바꿔야 되는 거야. 아니
확인해야 되는 거야. 이 함수를 어디서 호출하는지 다 찾아가고.
이게 물론 저는 이제 가정 자체가 제가 라이브러리를 가졌을 때. 가정
자체가 제가 라이브러리에다가 클로즈소스 해갖고 바이너리를 만들어갖고
남한테 파는 그런 경우는 아니라고 생각하는 거예요. 내가 소스코드를 다
가지고 있다는 전제하에. 그게 대부분의 이제 회사들이 그렇게 많이
하니까. 남의 라이브러리를 갖다가 쓰는 경우도 있지만 굉장히 많은 이제
코드를 내부에서 개발하는 게 정상적인 회사라고 좀 보거든요. 지금. 그럼
이제 다 찾아가고 고쳐야 되는 거예요. 근데 이 코드가 정말 한 번만 쓰이는
함수였어. 딱 한 번만. 그러면 이 함수를 호출하는데.
자체가 있어야 되는 거예요. 그냥 함수 아니고 코드로. 그러면 그거 하나
고치는 것만으로 아 난 고쳤구나. 그리고 넘어갈 수가 있는 거죠. 아 이게 뭐 큰
문제냐. 딴 데다 돌아다니면서 함수 찾아보면 되지. 이런 얘기 할 수 있어요.
이제 이건 어찌 보면은 Git이 이제 가져다 준 이제 장점 중의 하나가 Git은
이제 자기가 체크인 한 다음에 풀 리퀘스트 넣고 이렇게 하는 경우가
많잖아요. 워크플로우 자체가. 그렇기 때문에 이제 웹이나
아니면 이동 중에 모바일폰 이런 걸로 이제 코드 리뷰를 볼 수 있다는 거죠.
얘가 이 체인지를 이제 마스터 브랜치에 두려고 해. 그럼 코드 리뷰를 보면서 아
이걸 바꿨구나. 오케이 라고 해줘야 되는데 바뀐 코드에는 함수가
바뀌었잖아. 그 함수를 호출하는 코드가 뭐가 있는지 리뷰어는 모른다는 거예요.
그럼 코드를 바꾼 사람이 이거를 다 제대로 처리했다고 생각을 하기에는
되게 애매한 게 그러면 코드 리뷰 안 하고 말지. 코드 리뷰를 한다는 거
자체가 이 사람이 실수할 거 있다고 생각을 하는 거고 그걸 좀 더 잡아주기 위해 보는
거고 이 알 수 없는 보이지 않는 코드의 실수가 더 큰 거거든요. 그럼 이제 거기서 코드 리뷰가
어려워져요. 그럼 내 컴퓨터로 와서 코드를 또 다시 찾아서 보고 이런 일을 해야 되죠.
그래서 그런 부분에 이제 약간의 문제점이 있다고 얘기를 하는 거예요.
그래서 제가 기본적으로 생각하는 함수는 코딩 스탠다드에서 제가 하는 거는
재사용이 가능한 함수. 그러니까 재사용할 지금 여러 번 호출을 하거나 아니면은
코드를 몇 번, 몇 번, 몇 번 이러고 만들어야 되는 거죠.
그니까 논리적으로 이거는 여러 번 호출이 될 수밖에 없는 코드들. 예를 들어서 제가 지금
뭐 매트릭스 클래스를 만들고 있어. 그 매트릭스 상에서 멀티플라이 하는 일 있잖아요.
이거는 지금 당장 코드에서 한 번만 할지라도 이거는 굉장히 정형화된 그런 기능이고
이제 굉장히 많은 곳에서 나중에 쓸 거라는 게 뻔히 보이는 상황이니까
이건 함수로 만드는 게 맞는 거죠. 똑같은 얘기로 중복되는 코드가 보여요.
그게 한 줄이든, 한 줄은 괜찮아.
한 세네 번이 보여요
그럼 저는 이건 반드시 함수로 가야 된다고 생각을 해요
왜냐하면은 나중에
어 이게 뭔가 문제가 되는 부분이 다 나와
그러면 얘를 고칠 때 한 군데만 고치면
나머지 세 군데에서 여전히 뻥나는 거잖아요
그럼 이게 함수로 돼 있으면 그거 하나만 고치는 것만으로
아 그렇구나 이거 하나 고치는 게 맞는 거구나
그러면 이제 호출하는 다른 데서 또 이제 살펴는 봐야겠죠
근데 이제 그래도 여러 군데 찾으면서 고치는 것보다는
한 군데 고치는 게 훨씬 더 실수할 가능성이 적다는 거죠 이 경우에
그래서 함수는 재활용이 될 때는 반드시
여러 번 사용되는 똑같은 코드라면 반드시 함수가 되는 게 맞고
그리고 굉장히 단순한 함수
그러니까 단순하면 할수록 좋죠
그 안에 막 if else 50개 박는 이런 거 말고
그런 함수면 좋고
아 그러니까 반복되는 건 함수 반복되지 않는 건 함수가 아닌 거
이 개념으로 저는 굉장히 까탈스럽게 굴어요
근데 재밌는 건 뭐냐면
반복되지 않는 거임에도 불구하고
함수를 인정하는 경우가 제가 가끔 있어요 가끔
그게 뭐냐면
이제 함수가 그러니까 하나의 코드를 짜는데
코드가 너무 길어지는 거예요
막 1000줄 2000줄 3000줄 이런 정도까지
그럼 이제 그 안에 막 변수들도 수십 개가 왔다 갔다 하고
실제 중간에 코드 불러 100줄 있는 데서 쓰는 변수인데
뒤에서 다시 딴 변수 써가지고 덮을 수도 있고
여러 가지 문제가 있거든요
그럼 이제 그때는 함수를 따고 가고
따로 만들어 쓰는 경우도 있었죠
거기에서 오는 단점은 함수를 한번 호출할 때
이제 스택 옮겨야 되고 메모리 점프해야 되고
이런 것 때문에 성능이 약간은 떨어지지만
야 까짓 거 100줄 200줄 돌리는 함수에서
한번 그 스택 이렇게 뭐 푸쉬하고 팝하는 게 얼마나 걸리냐
괜찮다라고 가는 경우였는데
이 똑같은 문제는 사실은 그 스코프 지정하는 그 브래켓 있잖아요
중괄호 브래켓 C나 뭐 자바에서
그거를 한번 중간에서 이렇게 그
함수로 만든 코드 불러 거기에 중괄호를 넣어주는 것만으로도
사실은 지금 말했던 이제 변수가 섞이고 이런 문제는 해결이 돼요
근데 이제 그거는 좀 핵이지 않냐
여전히 보기가 어렵지 않냐
이런 식으로 얘기가 나오는 경우도 있고
그래서 그 부분에 대해서는 제가 어느 쪽으로 가도 크게 뭐라 그러진 않는데
아 뭐 요즘은 IDE에서 코드를 볼 때는
이런 중괄호가 있으면 그냥 이 중괄호 사이를 콜렙스 해버리면
이게 한 줄로 들어가서 이 사이에 코드가 있는데
지금 안 보여줄 뿐이야
이런 아이디어도 있고
C# 같은 이제 샵 리전, 엔드 리전을 넣는 것만으로 역시 콜렙스가 가능한 것들
그런 것들도 이제 비주얼라이즈 하기에는 나쁘지 않아요
그리고 이제 그렇게 콜렙스를 할 때 여기다 번호를 넣는 법이 있죠
코드가 천 줄 짜리야
근데 백 줄씩 열 개가 있는 거야
그러면 코멘트 넣고 1번 뭐 콜렙스하고
2번 뭐 콜렙스하고
3번 뭐 콜렙스하고 하면은 보는 것만으로
아 로직이 이렇게 가는구나 알 수가 있어요
그 넘버를 굳이 박는 이유 뭐냐면
음
이제 아까 말했던 코드 리뷰
웹에서 코드 리뷰 볼 때
웹에서 코드 리뷰 볼 때는 콜렙스 해주는 플랫폼이 아직 잘 없거든
그러면 이제 백 줄을 막 쭉 읽어가면서 이 코드가 뭐 하는 건지
스코프로 박힌 건 알겠는데
그렇게 헷갈릴 수가 있잖아요
그래서 그런 상황까지 막기 위해서
뭐 제일 위에 코멘트 달고 1번 뭘 한다
그리고 이 백 줄 이후에 2번 뭐 한다
그러고 스코프 받고
이렇게 하는 것도 저는 허용을 해요
그래서 개인적으로는
이제 아까 말했던 함수를 만듦으로 인해서
그 함수에서 뭔가를 고칠 때에는

여러 가지 더 확인해야 되고 이런 것 때문에
개인적으로는 함수 하나에 들어가는 걸 되게 좋아해요 모든 게
그냥 따로 뽑는 게 아니라
한 번 쓰는 함수면 그냥 원래 호출하는 함수에 넣어서 끝내라
그리고 그렇게 할수록
이제 컴파일러가 최적화를 좀 더 잘할 수 있는 가능성도 높아질 거라고
저는 그냥 생각을 하고
왜냐면 코드가 바로 가까운 데 있고
이제 함수로 만든 순간
다른 함수가 또 호출할 수도 있는 거니까
그래서 그렇게 제가 생각을 하고 있어요
그래서 제가 지금까지 말한 거는
함수를 만들 때
한 번만 쓰는 코드라면 함수를 만들지 말아라
정말 이게 워낙 정형화되고
누구나 호출할 수 있는 함수라는 게 명백하지 않은 이상은
그냥 코드에 넣고
나중에 이걸 두 번째 누군가 호출할 때는
함수를 만들어라
그 외에 아까 말했던 것처럼
코드가 엄청 길어지고 변수가 섞일 때
함수를 한 번만 쓰이는 코드라도
함수를 만들 수는 있지만
굳이 그렇게까지 안 가도 된다
저는 이 부분에서는 그렇게 까탈스럽게는 안 돼서요

하지만 제 입장에서는
함수를 만들지 말자는 게 좀 더 가까워요
그래서 코딩 스탠다드가 아니라
이거는 그냥 제가 preference죠
제가 이제 좀 더 낮다고 생각하는 방향
그러나 아주 강력하게
이건 잘못된 거야라고 주장할 수 없는 부분
그 다음 여기까지가 이제 제가 생각하는 코딩 스탠다드고
조금 더 하나가 더 나가면 되게 재밌어지는 게 뭐냐면
특히 이제 java라던가
이제 C에서 포인터를 쓸 때
이제 nullable
제가 옛날에 null을 좋아한다고 전에 얘기했잖아요
null을 사랑한다고 그랬나
그 null이라는 걸 넣을 때
어떻게 될 거냐
되게 재밌는 게 이거예요
함수를 호출해요
함수가 인자를 받아요
이 인자가 java에서 보면
reference 타입 object class고
C에서 보면 포인터 타입이야
그리고 얘가 반환하는 것도 역시 nullable이야
아까 말했듯이 class나 포인터 타입
그럼 이 함수는
포인터를 받을 때
reference를 받을 때
이 reference가 null일 수 있다고 가정을 해야 되냐 말아야 되냐
이 함수가 반환하는 값에 null이 들어갈 수 있냐 아니냐
이 문제가 또 생겨요
그럼 이제 제대로 코딩 못 배우고
또 이제 약발면서 약 받는 사람들한테 배운 사람들은
exception으로 다 처리하면 된다
null 들어오면 exception 날리고 null 받으면 exception 날리고
try, catch 여기저기다 떡칠하고
근데 저는 이거는 아니라고 보거든요
예전에 exception 비디오를 만들었지만
이거는 말 그대로
뭐라 그럴까
헛똑똑한 사람들이 하는 짓인 것 같아요 가면 갈수록
오히려 코드 메인터넌스 하기가 되게 어려워지고
그러니까 특정한 룰을 따를
그러니까 해야만 될 때도 있어요
근데 지금 이제 exception 추종자들이 하는 것만큼
그 정도는 너무 과한 것 같아요
그래서 그 전에 이제 다른 비디오에서
exception을 어느 정도로 박아야 되는지 말한 적이 있기 때문에
그건 넘어가기로 하고
이거는 솔직히 말하면 굉장히 간단하게 코딩 상태로는 안 돼요

이게 코딩 상태로 해결이 되는 부분이에요 굉장히 간단하게
어떤 함수도
인자도 null이 들어오지 않는다 끝
허나 정말 null이 들어오야 될 때면
변수, 그니까 인자 이름을 넣잖아요 parameter 이름을
거기에서 예를 들어서 이게 id였다고 해봐
id는 좀 이상하게 name이라고 하죠
string이 name만 있으니까
그럼 name 또는 null 이렇게 쓰면 되는 거예요
이름 자체는 name or null
그래서 제 코딩 스탠드에서는 parameter에 null이 들어올 수 있는 경우에


name or null로 해갖고
실제 함수를 호출하는 입장에서도
코드를 짤 때는 id로 보잖아요
어떤 parameter가 들어가고 그 이름이 뭔지
아 여기 null을 넣어도 상관이 없구나
그럴 때만 null을 넣는 거고
그렇지 않으면 null을 안 들어오게 하는 거죠
그럼 함수를 원래 만드는 사람 입장에서는
모든 매개변수가 null이 아니라는 가정화의 코드를 짜는 거고
그걸 이제 디버그 동안에
디버깅 하는 동안에 잡고 싶다면
assert를 박는 거죠
이게 null일 경우에는 assert를 써서
assert를 쏘고
그럼 디버깅을 잡고
프로덕션 도중에는 null이 들어오면
그냥 컴퓨터가 bug이 나게 하는 건데
아 컴퓨터가 bug이 나면 말이 안 되지 않냐
이런 얘기를 하죠
그 exception 애들이 하는 얘기지만
내가 가지고 있는 데이터 있잖아요
제가 호출하는 코드와 내가 넣는 코드
그러니까 우리 회사 안에서 모두 관리하는 코드는
null이 안 들어가게 코드를 짜면 돼요
null이 안 들어가게 데이터를 만들면 되고
null이 문제가 되는 건 내가 컨트롤할 수 없는 부분이잖아요
뭐 네트워크에서 패키지 들어오는데 null로 들어왔다거나 하나가
아니면 파일을 읽었는데 누가 파일을 핸드 모디파이하고 null이 들어왔다거나
그렇게 내가 바운더리와 갈리는 부분
그럼 그 부분에서 null인지 아닌지 확인을 하고
그 값을 reject해버리거나
아니면 거기서 exception을 던지면 돼요
한마디로 바운더리가 바뀌는 부분에서 exception을 바꾸면 되는 거고
그 외에서 exception을 던지면 되는 거고
그 외에는 내가 만든 코드는 반드시 null이 아니다
라고 가정하는 게
굉장히 코드 짱이 편해지고 깔끔해지고 이해가 쉬워져요
단순한 게 좋은 거라고
그러나 당연히 레퍼런스 타입이 있고
저는 null을 좋아하는 사람이고 null을 사랑하는 사람이기 때문에
null을 넣을 경우가 있어요
그러면 이제 or null 이런 식으로 넣거나
뭐 그렇게 하는 것만으로 깨끗해지는 거죠
반환 값은 뭐냐
똑같다고 봐요
반환 값은 함수는 기본적으로 null을 반환하지 않는다
그러나 getName이라고 하죠 getName
그럼 얘는 언제나 name을 반환해요 언제나 string을 반환해요
그런데 얘가 null을 반환해야 돼 상황이 있어
그러면 getName or null 이거를 함수 이름에 착각해 박아서
얘는 null을 반환할 수 있으니까 네가 처리해라
그러면 이게 재밌어지는 게 뭐냐면
코드 리뷰를 볼 때
웹에서 보는 것만으로도 null 처리를 제대로 하는지 안 하는지 알 수가 있는 거예요
그러니까 함수 인자 호출할 때는 조금 애매한데
왜냐면 함수 그 body를 보지 못하니까
최소한 return 값에서는 확실해져요 return 값에서
그래서 그거 이제 이렇게 하면은 실수를 만들 가능성이 굉장히 적어지는 거예요
왜냐면은 뭐 이제 포인터 류나 아니면 java 쪽에서 문제가 언제나
null 레퍼런스 하다가 뻥 나는 경우가 많기 때문에 그게 문제다라고 얘기를 해왔고
그걸 해결하는 방안으로 어찌 보면은 굉장히
이제 이렇게 exception을 쓰면은 다 막을 수 있어라고 하면서 모든 exception을 박으라고 했지만
생각보다 이제 뭐 java는 이제 함수 자체가 어떤 exception을 throw하는지 적어주고
그걸 catch 안 하면 문제가 생기니까 강요를 했었는데
코드가 굉장히 들어와지는 단지인데
단점이 있었고 그래서 그 이후에 많은 언어들은 exception을 catch하지 않아도 문제가 없게 했지만
그러면 코드를 보면 볼수록 얘가 exception을 던지는지 이 함수가 던지는지
아니면 이 함수가 다른 함수 10개를 호출하는데 거기서 던지는지도 모르겠고
그래서 어찌 보면은 한 번 너무 extreme하게 exception handling으로 갔다가
아 이건 정말 어렵구나 그래서 약간 돌아왔다가
아 이건 이대로 작동을 못 하는구나 라는 상황이 온 거 같아요
그래서 이런 부분은 이런 부분을 해결하기 위해 있는
이게 코딩 스탠다드죠
그래서 제가 오늘 말했던 코딩 스탠다드는 그쯔면 되지 않을까
함수는 반복될 때만 만든다 최대한
함수에서 뭐라 그럴까
4개 변수가 이제 들어올 때는 거기에 null이 들어올 때는 반드시 이름 자체에
o와 null이라고 넣어준다
반환값에 null을 반환할 수 있을 때는 o와 null이라고 넣어준다
그게 지금 제가 정형화 스탠다드고 업계 표준이라고 할 순 없어요
그렇게 null을 까탈스럽게 고민하는 사람들이 생각보다 없잖아요


이유 중에 하나는 이런 코딩 스타들을 까탈스럽게 하는 것 자체가
이제 이렇게 프로그래밍 잘 이해하고 그 정도 능력이 되는 회사들인데
그런 회사가 이제 뭐라 그럴까
웹 쪽에는 별로 많이 없고 생각보다
이제 게임 쪽에서 C++ 쓰는 회사에도 꽤 많은데
C++ 쓰는 회사는 이제 이 문제를 해결하기 위해
null이 될 수 없는 reference를 만들어 버렸잖아요
그 이제 포인터라는 게 있었고
그 외에 레퍼런스 만들겠지만
레퍼런스 null을 눌려면 넣지만 억지로
기본적으로 null이 안 된다 레퍼런스는 그 개념이기 때문에
오히려 그 문제는 이제 C++에서 스탠다드가 이제 나아지면서
그 언어적으로 해결을 한 부분이고
이제 그 외에 다른 언어들 이제 포인터와 포인터가 아닌 오브젝트
그니까 레퍼런스와 이제 value인 오브젝트를 구분하지 않는
그 꽤 많은
모던 프로그래밍 랭기지에서는
이 부분을 아직 제대로 해결을 못 한 거죠
exception을 하려고 했는데 못 했고
그래서 코딩 스탠다드에 이제 의존할 수밖에 없는
그래서 음 예
그래서 그런 코딩 스탠다드를 제가 쓰고 있어요
그래서 다음에도 아마
코딩 스탠다드가 꽤 길기 때문에
제게 언제 한 번 또 더 이상 말할
더 말할 게 있지 않을까 생각을 해요
그래서 음 오늘은 그 정도
포프였습니다
감사합니다
