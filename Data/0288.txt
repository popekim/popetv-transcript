안녕하세요 포프입니다. 오늘은 객체지향 프로그램에 대해서 얘기해 보려고 해요.
사실은 갑자기 최근에 그냥 아마 포프TV 슬랙창에서 사람들이 얘기하다가 갑자기 이거 한번 만들어야겠다 생각이 든 것 같은데
근데 무슨 내용이냐면 일단 객체지향을 최근 들어서 객체지향 프로그래밍이 싫다 이거 난 정말 싫어한다 라고 말하는 사람들이 생기고 있어요.
근데 생각해보면 이제 그거에 대해서 좀 말을 해보고 하려고 하고 시작은 아무래도 좀 용어 정리부터 조금 해야 될 것 같아요.
그냥 객체지향이 뭔지 아시는 분들은 그냥 2분 정도 거면 또 상관없지 않을까 생각을 하고
그래서
일단 이제 객체지향 프로그래밍 혹은 객체지향 프로그래밍이라고 부르는데 이게 오브젝트 오리엔티드 프로그래밍이거든요.
그래서 되게 깐깐한 그런 뭐라 그럴까 번역자들 저도 한때 그랬고 그런 사람들이 이게 객체냐 오브젝트가 객체가 돼야 되냐 객체가 돼야 되냐
이런 얘기를 되게 싸우는데 별 의미는 없는 짓이고
뭐 그리고 이제 오리엔티드니까 오리엔티가 방향을 정하다 이런 거거든요. 방향이 정해진 그래서 이게 지향적이다.
그래서 객체지향 프로그래밍 이렇게 얘기하는 건데
뭐 솔직히 용어 자체는 다 그냥 좀 쓸데없는 것 같아요.
그냥 영어권에서 객체지향 프로그래밍을 오브젝트 오리엔티드 프로그래밍으로 설명할 때는
자 이게 실제 세상에 존재하는 물체라고 가정을 하고 생각해보자라는 개념이에요.
왜냐면은 뭐 스크립트 언어 처음 쓰신 분들이나 그냥 뭐 이제 옛날에 C 계열로 해보신 분들은 알겠지만 모든 게 함수 기반이고 데이터는 저장되지 않습니다.

그냥 딴 데다 저장을 하고 이랬거든요.
그러니까 예를 들어서 함수가 a 더하기 b는 뭐 3일 뿐 이런 식으로 하는데 이걸 좀 더 발전을 시키면
음 그냥 전기 히터 이렇게 아니면 라디오 라디오로 할까 그냥 전기 히터로 하자 히터 같은 거 있잖아요.
이렇게 이렇게 올리면 점점 세지고 내리면 점점 약해지고
그러면 이거를 인터페이스라고 볼 때 이런 인터페이스를 올렸을 때 현재의 온도는 값은 어디 있어야 되냐 그러면 저 엉뚱한 데 저장돼있고 이런 개념이었는데
얘네 이때 얘기하는 건 오브젝트 오리엔티드 프로그램에서는 히터라는 거 자체를 그냥 오브젝트로 보면은 여기에 함수도 있지만 그 안에 있는 온갖 상태들이 있잖아요.
현재 온도가 몇 도에 맞춰져 있는지 그런 상태까지도 이 하나의 오브젝트에 들어가야 된다라는 개념으로 오브젝트 오리엔티드 프로그램이거든요.
그래서 이게 개체냐 개체냐는 아무 의미가 없고 제가 볼 때는 가장 가장 올바르게 말하는 것은 물체가 맞는 것 같아요.
그냥 현실의 존재는 물체.
그래서 이게 개체냐 개체냐는 아무 의미가 없고 제가 볼 때는 가장 가장 올바르게 말하는 거는 물체가 맞는 것 같아요.

그리고 오리엔티드도 무슨 지향이니 이런 말도 안 되는 한자어를 굉장히 힘들게 쓰는데 그냥 물체 중심의 프로그래밍이 그런 것 같아요.
아니 물체를 중점적으로 보는 그러니까 이거를 중심에 두고 모든 걸 물체로 이해하고자 하는 프로그래밍이 오브젝트 오리엔티드 프로그래밍이고.
근데 이제 이게 그래서 오브젝트 오리엔티드 프로그래밍에 대한 언어 정리는 제가 대충 했고 굳이 용어를 정할 이유는 없지만 그렇게 이해하자.
그리고 그럼 이제 왜 사람들이 그렇게 OOP를 요즘 싫어한다고 말을 하느냐.
솔직히 제 입장을 얘기하면 저는 OOP를 싫어하지 않아요. 좋아하는 것 같아요.
근데 OOP 수업을 듣다 보면은 거기서 듣는 거에서 과연 내가 현실에서 얼마나 쓰고 있고 과연 다른 프로그래머가 얼마나 쓰고 있고 과연 업계에서 얼마나 쓰고 있냐를 물으면 생각보다 적어요.
그게 문제야.
그래서 OOP를 듣기 때문에.
OOP를 듣기 시작하면은 여러 가지 개념들이 있어요.
아까 말했던 상태하고 인터페이스 그러니까 함수가 같은 클래스라는 거에 보통 들어가야죠.
같은 틀 안에 들어있다.
그래서 클래스 안에 아까 말했던 히터.
전기 히터라는 그게 있고 그럼 그 안에 온도 조절하는 함수가 있고 그럼 현재 맞춰주신 온도가 몇인지 그러면 그거에 따라 이제 전기를 내뿜어야 되잖아요.
열을.
그러면 그 열을 얼마나 세게 내뿜어야 되는지도 있어야 되잖아요.
출력을 얼마나 할 건지.
그런 상태가 이제 하나의 클래스에서 만든 오브젝트가 들어있다죠.
그게 전부예요.
사실은.
근데 제가 봤던 건 그거고 이제 문제는 OOP 수업을 듣다 보면은 OOP에서 빼놓을 수 없는 게 몇 가지가 있어요.
그래서 이제 뭐 인터페이스라든가 뭐 다용성 이런 거 다 좋은 거고 다용성은 이제 관리 측면에서 좋아요.
프로그램 하다 보면은.
근데 그 외에 상속이라는 게 있어요.
상속.
그럼 상속이라고 하면은 예를 들어서 뭐 프로그램 들어본 사람들은 다 알 거예요.
뭐.
여기 동물이 있고 개가 있고 동물은 뭐 다 걸으니까 그러면 여기 워크 메서드가 있고 거기에 뭐라 그럴까 강아지가 있고 뭐 고양이가 있으면 고양이하고 개는 걷는 모양이 다르니까 다른 거를 구현해줘야 된다.
허나 얘네가 공통되는 게 있다면 뭐 먹는 게 공통되니까 이시라는 건 공통되는 함수라서 그냥 둘 다 상속을 했을 수 있다 뭐 이런 식의 개념이 되는데.
이게 상속이.
상속이 하나일 때는 쉬운데 다중 상속도 있어요.
막 그 클래스 여러 개가 있고 이 부모로서 다 상속을 받는 거야.
얘한테도 받고 얘한테도 받고.
그럼 막 서로 상속된 메서드 간에 충돌이 일어나고 그래서 그런 거를 막기 위해서 자바 진영부터 시작을 해서 상속을 하나만 되되 나머지는 인터페이스다.
인터페이스라는 거는 그냥 너는 이런 행동을 해야 돼 라는 그런 규격을 정해줄 뿐이지 그 행동이 어떻게 진행되는지는 각 클래스마다 자식 클래스마다 만들어라는 게 인터페이스죠.
올바른 방법이에요.
그게 사실은.
근데 문제는 다중 상속도 솔직히 받는 경우가 없진 않은데 프로그래밍을 많이 하다 보면 생각보다 상속을 그렇게 많이 안 써요.
아까 인터페이스 상속받는 경우는 좀 쓸 수 있는데 정말 부모 클래스에 있는 모든 결과를 받아다가 쓰는 상속은 생각보다 없어요.
그래서 실제 우리가 학교에서 배우는 OOP의 개념에서 가장 중요한 거는 인터페이스하고 상태가 같은 데에 있다는 것보다.

그리고 두 번째가 인터페이스 상속을 받을 수 있어서 공통된 behavior를 정의를 해주고 각 자식 클래스마다 그 클래스가 공통된 behavior를 구현을 했을 때
그 인터페이스를 통해서 여러 개를 동시에 어레이를 긋던가 그런 컨테이너를 긁으면서 실행할 수 있는 그런 관리의 장점이 있을 뿐이지 생각보다 기능을 받는다.
내 부모한테 있던 기능을 받아갖고 그거를 그대로 실행한다는 개념의 상속의 개념은 생각보다 기능을 받는다.

그게 어찌 보면 그런 개념 자체가 현재에 잘 없어요.
실존하는 물체에서 물론 제가 부모님으로부터 어떻게 하는 거를 비슷하게 배워와서 그게 바뀐 거는 있지만 그거는 사람의 얘기고 그게 아니라 온갖 저희가 생각하는 뭐라 그럴까 아까 말했던 히터 같은 경우에 생각해 보면 히터는 우리가 모르는 히터일 뿐이고 얘가 어디에 상속을 받은 건 아니고요.




게 아니에요. 물론 히터 안에는
열을 내는 부품도 있죠.
하지만 이거는 그 열을 내는
부품을 가지고 있을 뿐이지
그거를 상속을 받은 게 아니거든요.
그러니까 이걸 상속을 받았다는 개념은
뭐냐면 전기 히터가
그 열을 내는 부품의 일부이다.
그러니까 일부가 아니라 그런 부류
중에 하나다. 같은 카테고리에
속한다고 봤을 때인데
방열판과 히터는 솔직히 전혀
같은 건 아니에요. 오히려 히터가
방열판을 안에 갖고 있는 것 뿐이지.
그러면 OOP에서 얘기하는
상속의 개념이 아니라
컴포지션이라고 하는 개념이 있죠.
컴포지션의 개념은 내가 이런
겉에 틀이 있고
그 안에 여러 가지 부품을 가지고 있다거든요.
예전에 한 번
제가 유니티 게임
컴포넌트 기반
게임 오브젝트인가? 그런 비디오에서 만들 때도
그런 얘기를 했어요.
이건 상속이 아니라 컴포지션이다.
사실 저희가
현실에서 보는 오브젝트들은
대부분이 컴포지션이에요.
그래서 오히려 오브젝트
오리지털 프로그래밍을 생각할 때 상속보다는
컴포지션의 개념이 사실
맞긴 더 맞아요. 왜냐하면
그게 더 일반적이에요. 그리고
실제 프로그래밍을 하다 보면 그런 경우가 더 많아요.
OOP 안에 모든 게
다 기능이 들어있지만
여기 아예 부품을 가지고 있든 아니면
다른 서비스를 호출을 하든
그건 OOP하고는 조금 벗어나는 거긴 하지만
서비스가 자체가 있다는 것 자체가
좀 글로벌적인 거라서
어쨌든
컴포지션을 통해서
오브젝트를 구성하는도는
저희한테 되게 일반적이고
그리고 저희 생활 속에서 일반적이고
그렇기 때문에 상속의 개념보다는
컴포지션의 개념이 사람들한테 훨씬 더 편한 게 아닌가
싶기도 해요.
그리고 상속, 다중상속 들어가고 이러면
실수를 많이 할 수 있는 이유도
아무래도 현실에서
덜 봤기 때문인 것 같고
그래서 제가 볼 때는
그게 제일 큰 문제인 것 같고
결국에는
프로그래밍이든 뭐든
내가
내가 일상생활에서 보고 알고
익숙한 거로 코딩을 할 때가 훨씬 더 편한 거예요.
그렇지 않으면
아 그 뭐랄까
전혀 나한테 새로운 거
전혀 내가 어떻게
릴레이트라고 그러거든요.
영어에서는 한국말로 뭐라고 그러는지 모르겠는데
내가 그냥 실제
아 새로운 걸 봤을 때
아 이게 이거랑 비슷하구나
라고 이렇게 떠올릴 수 있는 거면
쉽게 적용이 되는데
전혀 이색적인 거
전혀 이질적인 거면은
솔직히 굉장히 어떻게 잘해야 될지도 모르겠고
그리고 과연 내가 코딩을 짜놨을 때
다른 건 같이 일을 할 수도 있을지도 모르겠고
그런 단점이 있거든요.
그래서 그런 부분인 것 같아요.
그래서 생각보다 OOP에서
음
아까 말했듯이
상속이나 다중상속보다는
아까 말했던 그런 컨테이너의 개념
컨테이너가 이렇게 하나를
기능과 상태가 같이 있다는 거
그게 중요하고
아까 말했듯이
인터페이스는 그래도 중요해요.
왜냐하면은
여러 가지 클래스가 있을 때
얘네 클래스를 한 번에 훑으면서
똑같은 함수를 시행해 보고 싶은데
그럴 경우에는
제일 편한 게
인터페이스를 상속을 받아서
그 인터페이스 어레이로 애들 다 집어넣어 놓고
돌릴 수 있는 거죠.
그래서 그게 좋고
그리고 어찌보면은
옛날에 이렇게
OOP가 굉장히 복잡하게 상속을 받고 뭐하고
이러는 게
80년대에는 말이 될 수도 있어요.
사실은
왜냐하면 그때는
CPU가 모든 걸 하나로 돌렸고
데이터를 분산시켜 갖고
멀티스레딩해서 돌린다는 개념도 없었거든요.
없었던 게 아니라 잘 안 했거든요.
그러면은
그 모든 내가 돌고 있는 모든 오브젝트가 같은
메모리 구조를 가지고 있다가
그다지 중요하지 않았는데
요즘은 CPU 성능 향상이 없고
다만 CPU 수를 마구 늘리고 있잖아요.
그러면 똑같은 레이아웃을
메모리 레이아웃을 가진 그런 오브젝트들이나
똑같은 함수를 가지고 있는 오브젝트를 가져다 두고
그거에다가 이제
엠바라 그러더라고요.
CPU가 8개면은
전체 있는 오브젝트를 8개로 나눈 다음에
분산으로 처리하는 거.
그래서 8분의 1씩 처리하는 거.
그런 식으로 할 때는
요즘은 데이터 주도적인 프로그래밍이 더 많이 각광을 받아요.
그리고 데이터 주도적인 프로그래밍이 들어갈 때
다중 상속이 있고
이러면 굉장히 힘들어지기 때문에
요즘은 오히려 또
OOP에서 약간은 멀어지지만
그래도 한 클래스가 필요한 데이터를 담고 있다는
OOP의 개념은 사라지지 않고 있어요.
그래서 그냥
여태까지 모든 프로그래밍 패러다임을 봤을 때
새로운 게 나오면
사람들은 다 확 몰려가요.
왜냐하면 새로운 거가 좋다고 생각하는 사람들이 있으니까
그리고 써보고 문제점을 느끼고
아 이게 실제는 아이디어는 좋지만
현실에 적용이 좀 어렵다거나
아이디어도 나빴다거나
그런 게 되면은 서서히 좀 줄어들면서
나쁜 거는 안 쓰고 좋은 것만 쓰게 되는
그게 좀 이제 베스트 프랙티스 쪽으로 가는
그런 게 있거든요.
저는 OOP도 그랬던 거라고 봐요.
그래서 오히려 80년대의 그런 OOP보다는
요즘 실제 다들 실무에서 많이 쓰고 있는 OOP가
조금은 더 중간에서 가장 좋은
그 뭐랄까 프랙티스를 찾은 거라고 보고
그 상황에서 아직도 OOP 수업이라든가
책들이 80년대 마인드스에서 못 벗어나고 있다는 건
좀 아쉽기도 해요.
그래서 생각보다 OOP에서 배우는 모든 게 중요한 게 아니라
정말 중요한 것과 이런 것도 있구나 정도는
구분을 했으면 좋겠고요.
그래서 또 이제 뭐라 뭐지
뭔가 할 말 있었는데 까먹은 거 같아.
비디오 편집도 안 하는데 그쵸?
그렇게 돌아오는 길이고 생각이 안 나.
그냥 끊어야 될 것 같아.
아 망했다.
비디오 만든다 이런 경우가 없었던 것 같은데
잠깐만 1분만 생각을 해 보고 고민을 해 보죠.
그래서 OOP로 넘어갔다가 돌아오는 길이고
아 그런 것도 있어요.
OOP에서 솔리드 프린시플이라고
있어요.
솔리드 원칙 솔리드 OOP를 만들 때
과연 지켜야 하는 규칙들이 있어요.
뭐 SOLID라고 해서 하나씩 하나씩 이렇게
뭐 이렇게 나타내는 게 있는데
그거를 가르치는 학교도 있고
안 가르치는 학교도 있거든요.
뭐 이론적으로 이게 OOP의 올바른 이론이라고
가르치는 건 좋은데
그게 100% 맞는 것도 아니고
그거는 굉장히 이론적인 게 강해요.
그래서 이제 뭐 인벌션 오브 컨트롤이라든가 뭐 이런 거.


이런 것도 I였던 것 같고
그리고 Substitution Rule도 있는데
그거는 이제 SOLID S가 아니라 L이에요.
그게 이제 뭐라 그러다.
무슨 사람의 이름을 넣어 갖고
누구의 Substitution 이렇게 해 갖고
SOLID라고 했던 거 같아요.
그래서 그렇게 돼 있고
뭐 여러 가지가 있는데
솔직히 그거를 이해하고
음 그래 오브젝트를 만들 때
이렇게 가는 게 뭐 이런 이런 것도 나쁘지 않다.
이렇게 가는 게 뭐 이런 이런 것도 나쁘지 않다.
이게 사실은 옛날에 쓰던 방법이었다라는 거는 되게 좋아요.
그런데 음 솔직히 그거대로 모든 걸 만들다 보면은
솔직히 유지 보수가 정말 힘든 코드가 나오기도 해요.
그게 굉장히 기념상으로는 오브젝트마다 분리가 되어 있고
뭐 뭐 이렇게 컨트롤 인버션하고 다 이런 건 좋은데
그거를 전부 다 따라가기에는
굉장히 좀 탁상공론적인 디자인이 나올 수밖에 없는 것 같아요.


솔직한 얘기로.
그래서 거기서 들으실 때도 이제 Substitution Rule 같은 거는
솔직히 생각을 해보면 굉장히 도움이 되는 얘긴 하거든요.
왜냐면은 부모에서 하던 작동을
그러니까 내가 이제 부모가 있고 자식이 있는데
부모에서 어떤 함수가 있어서 그 작동을 하잖아요.
그럼 자식이 그걸 삼속을 할 때도
여기서 만든 그 기능 자체가 내부가 어떻게 바뀔지는 모르겠지만
그 의미 자체를 아예 바꾸면 안 돼요.
그래서 이 자식을 놓든 부모를 놓든
둘 다 제대로 작동이 가능할 정도여야 된다는 게
Substitution Rule인데
그런 거는 Interface라는 개념에 사실은 맞긴 맞아요.
근데 제가 뭐 예전에 말했던 이제
Dependency Injection에서도 좀 그런 비슷한 얘기했고
Inversion of Control, IOC라는 거 자체를 이제
사람들이 되게 잘못 이해를 하고 있는 부분도 요즘 있고
그런 걸 이제 원칙대로 따라간다고 따라갔는데
이게 잘못되는 경우도 있고
근데 그게 잘못된 원칙을 따라...
원칙은 맞는데 원칙을 이해를 잘못한 경우도 많죠.
그래서 모든 간에 OOP에서
제일 중요한 거는 그건 거 같아요.
아까 말했던 그 Interface하고
그 기능하고 데이터가 같이 들어가 있다.
그거를 중점적으로 이해를 하고
그리고 이제 Object Oriented Program 만들 때
상속이 깊어지고 여러 단계로 상속이 되거나
아니면은 다중 상속이 되는 순간
뭔가를 잘못하고 있을 경우가 많아요.
왜냐면 일상생활에서 그걸 제가 별로 보는 편이 아니기 때문에
그런 식으로 구성이 될 만한 게 그렇게 많지가 않아요.
제 경험상으로.
그래서 그렇고,
또 하나는 이제 코드가 깊어지고 상속이 많아질수록
코드 가독성도 떨어지는 건 사실이에요.
그래서 그런 부분에서는 오히려 요즘 추구하는 좀 더 뭐라 그럴까
컴포지션 쪽으로 좀 더 가거나
아니면은 데이터 드리븐 디자인 쪽에서 볼 땐
점점 이제 클래스가 단순해지고 있거든요.
그리고 Functional 프로그래밍 쪽에 영향도 조금 있는 거 같고
그래서 그렇게 말을 하고 싶고
음 또 하나 이제 마지막으로 그냥 걱정이 되는 건
이건 최근에 그냥
슬랙챗에서 허혁 씨라고 계세요.
그분이 이제 장난처럼인지 진짜인지 모르겠지만
IQ와 IQ 이제 내가 뭐 IQ 몇이다 이런 게 있잖아요.
그거와 그 사람이 할 수 있는 직군을 이렇게 분류하는 게 있어요.
그래서 뭐 IQ가 높을수록 자기만의 규칙을 만들 수 있고
IQ가 낮을수록 규칙을 그냥 따라야 되는데
그냥 IQ 정도에 따라 규칙을 따르는데 잘 따르는 사람
아니면 잘 못 따르는 사람, 대충 하는 사람
이렇게 나뉜다라고 얘기를 했는데 그게 100% 맞나요?
맞는지 아닌지는 모르겠지만
그 IQ의 개념을 떠나서 사람 성향상 그런 건 있는 거 같아요.
누군가 규칙을 만들어주면 그 규칙이 전부라고 생각하고 믿고 따라가면서
실제 그 규칙보다 뛰어난 말을 하는 사람도 있어요.
그 새로운 규칙을 만드는 사람들.
그런 사람들을 봤을 때 단지 내가 알고 있는 규칙과 벗어난다고 해서
얘는 아무것도 모른다, 멍청하다는 식으로 모르고 가는 사람도 있어요, 사실은.
근데 결국 두 개예요.
규칙이 있을 때 규칙을 못 따라가는 사람도 있고
그래서 이거는 규칙도 못 따라가서 모든 걸 망치는 사람들이 있는 반면에
규칙이 있는데 규칙으로 인해서 규칙이 오래돼서 더 이상 적용되지 않아서
아니면 규칙을 뭐랄까, 잘못 만든 걸 따라가서라든가
규칙 때문에 망가지는 부분도 있거든요.
그 망가지는 부분을 해소하기 위해서 규칙과 다른 걸 하고
그거를 규칙으로 만드는 사람들이 있어요.
그래서 제가 볼 때는 이제 OOP가 개념이 오래된 개념이고
처음에는 이제 이 규칙으로 갔었거든요.
가운데 규칙으로.
이 가운데 규칙으로 가면서 처음 나왔을 때는 당연히 규칙을 못 따르고
이상한 짓을 하는 사람들이 많았을 거예요.
요즘 DB 프로그래머 쪽에서도 아직은 좀 많이 보여요.
스파게티 코드가 쉽게 나올 수 있는 거기도 해요.
그 OOP가 없으면.
그래서 OOP를 이렇게 강요로 해서 그런 코드를 좀 줄였고
많은 순화 작용이 있었지만
그 OOP로 인해 나왔던 문제점들을 지금 해결하려는 사람들이 많고
이게 실무에 많거든요.
근데 아직도 OOP의 문제점은,

아직도 OOP의 문제점은,
아직도 OOP의 문제점은,
아직도 OOP의 문제점은,
아직도 OOP의 문제점을 직시를,
아직도 OOP의 문제점을 직시를,
문제점을 알긴 알 거야.
근데 그에 대해 해답을 못 찾아서 그냥 규칙대로 가고 있으면서
이거랑 조금만 벗어나면 그냥 아 이건 잘못된 거라고 우기면서
이제 좀 뭐라 그럴까.
밥그릇 찍히게 하는 사람도 좀 있는 거 같아요.
그게 뭐 흔히 뭐 저희가 이제 요즘 한국에서 말하는 거는
무슨 교 신자 이런 식으로 얘기해요.
무슨 뭐 언어를 넣든 무슨 뭐 학계 빠라고 그러든가
무슨 학계 신자라든가 그런 식으로 많이 뭐 자바교 신자 뭐 이런 식으로
특정 이렇게 거를 맹목적으로 믿는 사람들을 무슨 교 신자 이런 식으로
얘기 많이 하잖아요.
그래서 그런 게 되는 거 같고 그런 사람들이 자꾸 이상한 말을 좀 많이
하고 있지 않나 그런 생각이 들어요.
과연 그 사람들한테 이런 문제는 어떻게 해결할래 라고 했을 때
대답을 못 하는 경우가 많거든요.
아 원래 그런 거야.
이 책에선 이랬어.
저 사람은 이랬어.
라는 식으로.
그래서 차라리 뭐라 그럴까 저는 이제 코딩 프랙틱스라던가 굉장히
제가 중요하게 여기는 분이 확실히 있는 사람이거든요.
뭐 유지보수성 되게 중요시하고 가독성 중요시하고 그리고 뭐 내가
채용할 수 있는 프로그래머가 정말 뭐 슈퍼 프로그래머가 될 수 슈퍼
프로그래머의 확률은 굉장히 낮다 고 보니까 그렇다면은 뭐라 그럴까
뭐 뭐 뭐 속단말로 그냥 코드 몽키 급의 프로그래머가 들어와도 어떻게
얘네를 유지 보수를 시킬 수 있을까 까지 생각하면은 단순성이 되게
중요하고 가독성 중요하고 그리고 뭐 이렇게 뭐 뭐 이렇게 뭐 이렇게
뭐라 그럴까 음 아니 그게 제일 중요한 거 같아 저한테는 그리고
버그 없고 뭐 이런 것도 중요해야 되고 근데 뭐 그거야 뭐 중요한
거 따지면 끝도 없고 제가 제일 중요시하는 건 가독성과 유지보수성
이기 때문에 그 기준에서 맞춰서 볼 때 음 모든 거 그니까 그 기준에서
맞춰서 현실에 맞춰서 볼 때는 결국 이런 이런 게 더 맞지 않냐는 얘기를
많이 하게 되는 거죠.
그래서 아마 이 oop 비디오가 나가면 분명히 oop.
.
뭐라 그러지 이거를 교신자인가 oop 교신자 아니 뭐 그거라던가 아니면
oop 빠라던가 그런 사람들이 분명히 또 이렇게 뭔가 얘기를 많이 할
것 같아요.
그래서 뭐 솔리드가 되게 중요하다 라니 이걸 안 하면 뭐 뭐 뭐 제대로
제품이 안 나온다니 이런 이런 얘기들 근데 제가 이제 되게 존경하는 프로그래머
유영천 씨 말을 빌려서 그냥 이걸 끝내는 게 좋을 것 같은데 세상에서
가장 가장 가장 버그없고 튼실하고 가장 핵심적인 프로그래머 프로그램들의
대부분은 oop가 없이 만들어졌어요 사실.
순수 c로 만든 게 되게 많아요 생각보다.
그래서 이거는 그냥 oop의 원래 원칙 이 나와서 얘네가 해결하려고 했던
거는 해결을 못한 못한 게 맞아요 사실은.
근데 oop로 인한 장점이 있었고.
그리고 이거는 정말 어떤 프로그래밍 을 어떤 놈이 할 수 있냐의 문제
이거든요.
그러면 그냥 언어가 실수를 줄일 수 있는 언어올수록 좋은 거고 실수
를 줄일 수 있는 그런 개념이면 좋은 거예요.
왜냐하면 아까 말했던 코드몽키 급의 사람들은 프로그래머들은
이리저리 일단 실수를 더 많이 하기 때문에 그러면 그냥 실수가 어려운
그런 패러다임을 주면 되는 거예요 .
그런 코딩 스탠다드가 있고 그런 프레티스가 있고 그게 있을 때 그
사람들이 실수를 덜 함으로 인해서 소프트웨어 프로그래머가 더 잘
만들어진다는 거죠.
그래서 이런 패러다임을 도입해서 이것만 도입하면 정말 훌륭한 아주
아주 훌륭한 프로그램이 나온다는 건 절대 아닌 것 같아요.
그거는 프로그래머 개인의 역량 이고 이 사람들한테 어셈블을 주든
자바스크립트를 주든 뭐를 주든 똑같은 품질의 코드가 나오지만
그런 사람들은 어디에다 쳐박을 수는 없으니까 중간에 쓰기엔 뭐가
나은 거냐.
그래서 그런 장점이 있는 게 이제 새로 나온 패러다임들이 장점이
있는 거고.
그럼 그 패러다임에서 아 뭐라 그럴까.
.
역시 문제가 있는 부분이 있어요.
그 패러다임을 너무 광신적으로 썼다 보면 아까 말했던 그런 역량
이 아주 아주 훌륭하지 않은 프로그래머가 할 때 결국은 실수를 만들 수 있는
부분들이 있거든요.
그런 게 이제 oop에도 꽤 있어요.
아까 말했던 다중상속 이런 거를 시작을 해서.
그래서 그런 게 맞다고 우기는 순간 부터 저는 어찌 보면 oop 쪽에서 계속
깠던 c쪽은 이래서 문제야.
뭐 프로세셔럴 프로그래밍은 이래서 문제라고 했던 거랑 똑같은 과정을
겪어 하고 있는 거예요.
왜냐면은 c는 이래서 문제라고 했을 때 그쪽에서 한 얘기는 야 훌륭한
c 프로그램은 이렇게 잘 짜고 있어 그게 왜 문제야.
그렇잖아요.
근데 나는 어떻게 이게 문제라고 해 왔거든.
그래서 그러면서 이제 나는 아 내 쪽은 이래서 고칠 수 있어.
근데 딴 쪽에서 야 그건 너무 복잡 하잖아.
그건 문제야.
그러면 아니야.
그래도 훌륭한 프로그램 잘 짤 수 있어.

.
그리고 똑같은 논리를 딸 때랑 방어 할 때랑 전혀 반대되는 얘기를 하고
있는 거거든요.
그래서 그런 거를 잘 생각을 해야 될 것 같아요.
왜 프랙티스를 만들고 왜 패러다임 을 만들고 여기가 추구하는 게
뭐냐.
그리고 세상에 완벽한 건 없다는 게 되게 중요한 것 같아요.
oop든 뭐든 간에.
아 말이 길어졌어.
끊을게요.
포프였습니다.
