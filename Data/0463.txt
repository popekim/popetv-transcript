예 안녕하세요 포프입니다
제가 예전에 한동안
제가 쓰는 C++11
제가 쓰는 C++17
17
요런식으로 해서 비디오를 몇번
만들었었어요 그죠
그때 이제 만들다가
이제 관뒀었는데
왜냐면 제가 쓰는건 이미 다 얘기했다고
생각을 해서 관뒀었는데
사실 지나고 보니까
아닌것들이 몇개 보이더라구요
그게 특히 보였던게
요번에 이제 저희 포큐 아카데미
제가 하는 이제 온라인
제대로 된 온라인 컴퓨터 교육
서비스
그거를 만들고 실제 강의를
진행하면서 강의자료 준비하면서
아 이런거는 내가
잘 쓰는건데 그리고
필요한건데 업계에서
이걸 내가 말하지 않은것들이 있구나라는게
몇개가 나왔어요 그래서 그거에 대한
첫번째걸로 오늘
하나 만드는거에요
내가 쓰는 C++
욕같애
C++1X
12
11
17
뭐 이런거죠 조만간 20도 되니까
이름을 좀 바꿔야될것 같긴한데
거기서 이제 나온게
버라이어딕 템플릿 아귀먼트
아 버라이어딕 템플릿이라고도
하는것도 같아요 정확히 뭐냐 이게
한국말로 번역을 하면
가변 인자 템플릿이에요
어
어떻게 이걸 설명을 하면 좋을까
음 일단
템플릿 프로그래밍을 하시다 보면은
뭐 주로 안하시는게 좋지만 하실
경우들이 있어요 하시다 보면은
보통은 그
보통 매개변수를 숫자를 정해서 넣어줘요
첫번째 매개변수는 T
두번째 매개변수는 S
세번째 매개변수는
뭐 D V 뭐 이런식으로 해서
쭉 매개변수를 적는데
그게 아니라 나는 그
매개변수가 정해져있지 않고
아무거나
받을 수 있는 그런
매개변수를
5개 6개 7개
이렇게 자유롭게 넣을 수 있는 그런 템플릿을
만들고 싶다 그럴 때 쓰는게
가변인자 템플릿이에요 그저
그전에는 안됐었죠
아 이게 왜 필요하냐
그러면은 일단
함수에서도 그런게 있다는걸 한번
말씀을 드리면 아 요런게
필요하겠구나 생각을 하실수도 있어요
가장 대표적인 함수가
이제 프린트 F C에서 프린트 F
함수 보면은
프린트 F 프린트 F도 그렇고 뭐
S 프린트 F도 그렇고
처음 매개변수는 포매팅 스트링이잖아요
예를 들어서 내가
스트링 하나 그리고
인테저 하나 넣겠다라고 하면은
포매팅 스트링 열고 거기다 퍼센트 S
퍼센트 D
이런식으로 하면은 내가
2개 매개변수를 뒤에 추가로 넣을건데
아 하나가 이제 스트링이고
하나가 숫자다 라는 얘기죠
그리고 그 뒤에 이제
스트링 매개변수 하나 넣어주고 다시
컴마 찍고 숫자 매개변수 하나 넣어주고
그렇게 하면은 이게 아무 문제 없이 돌아요
그죠 그런식으로
이제 함수를 호출하고 싶다는거죠
아 매 아
그런식으로 함수를 호출했으니까
이제 템플릿도 그런식으로 써보고 싶다는거죠
실제 프린트 F
이제 내부가 어떻게 도는지 보면은
뭐 ba arg
뭐 이런거 하고 비긴 엔드해서
그걸 이제 루프를 알아서 돌아주는 그런
아 씬텍스가 있어요 문법상에
그래서 그런걸 지원하고자 하는건데
뭐 그렇게까지 지원하는건
아니고 템플릿은
아
그 실제 사용문법을 보면은
아까 말했던
가변인자 함수형 가변인자 보면은
보통 뭐
변수명 적고 그 다음에
점점점 찍으면 그게 가변인자
가변인자라는거에요
함수형 템플릿 선언할 때도
그렇게 할 수 있어요 이제는
t 하고 점점점을 찍으면은
이제 그게 가변인자로
여러가지 이제 데이터가 온다는
얘기에요 그 형도 다르고
아 어쨌든간에 뭐 수가
여러가지 올 수 있다
근데 이런 얘길 하면은 아 이걸 어디에
쓰지라고 고민할 수 밖에 없는 경우가 있어요
내가 템플릿을 만들 때 보통
흔히 뭐 템플릿 사용하는 경우가
뭐 STL 컨테이너 사용할 때
벡터 그러면 여기 들어가는 형
인트 뭐 이런식으로 많이 쓰잖아요
근데 벡터 안에 인트인트
느낌 또 이상하니까 말이 안되고
그럼 어디에 쓸까 이런걸 고민을 하면은
쓸 곳이 한두군데 정도가 있어요
사실은 이거를
구글에 가셔가지고
버라이어딕 템플릿 그리고
where to use 찾으면은 뭐
나오는 글이 하나 있어요 뭐
이 버라이어딕 템플릿을 쓰기에 가장 좋은 일곱가지
사용례에 나오는데
거기서 솔직히 한 다섯가지
한 다섯개는
뭐 말도 안되는 얘기고 거의 필요도 없는 얘기
그냥 뭐 망상하고 있는거고
그냥 억지로 리스트 만들기 위해
한 두개 정도 그나마 된건데
이거를 정확히 얘기하면요 쓰시지
않을 생각을 하면 제일 편해요
이게 그럼 그게 왜 있어 그런 말 하실텐데
이게 나온 이유는 솔직한 얘기로
유니크 포인터 때문에 나온거에요
이제 C++11
거기서 유니크 포인터 쓰시면은
유니크 포인터 처음 만들 때
아
포인터를 그냥 집어넣게 되어있으니까
포인터를 유니크 포인터 안에 집어넣고도
실제 C스타일 포인터를
계속 밖에서 쓰면서 뭐
지울 수도 있고 좀 이상한 난리를 질 수가 있어요
그래서 그런거를 막기 위해서
아 그러면은 템플릿으로
차라리 make_unique라는
새로운 템플릿을 만들어주자
그럼 make_unique를 만들어야 되는데
그 유니크 포인터에
담을 수 있는
뭐 개체들 클래스들 종류들
타입이 굉장히 다양하잖아요
그러면 그거를 new
해서 넣어줘야 되는데 결과적으로는
그 뒤에 들어가는 매개변수들이
클래스마다 다르다는 거에요
어떤 클래스는 생성자가
기본 생성자가 있고 어떤 클래스는 생성자가
뭐 인트인트 두개 받기도 하고
어떤 걸 생성자가
말도 안되게 뭐 플롯 포인터에다가
차 포인터 받고
이렇게 다양하기 때문에
그 모든거를 아우를 수 있는 템플릿을
만들 수가 없는거죠
그래서 아 그렇다면은
make_unique 해놓고 어떤 유니크는
형인지 적어두고 그 다음에
괄호를 열고 실제
생성하는 클래스
그 타입 클래스에 들어가는
생성자 매개변수를 쭉
나열하면은 그게 알아서
내부에서 그 생성자를 곧바로
호출할 수 있게 해주자
즉 템플릿을 만들어서 make_unique라는 템플릿을 만들고
거기에 인자를 넣으면은
실제 그 타입의 생성자를 호출
new 하고 호출해서
그게 포인터가 나오면 그걸 대입할 수 있게 만들자
즉 이거는 매개변수
forwarding이라고 해요
눈 그거 그대로
뭐 아까 int float int 넣었다면
그거를 그대로 new type
int float int 넣어서 생성이 되게
컴파일 도중에 다 일어나는 일이니까
그 순서가 맞고 타입이 맞다면
컴파일이 되니까
그래서 그런식으로 하기 위해서 나온게 사실은
버라이오딕 템플릿이에요
그래서 솔직히 이 버라이오딕 템플릿 쓰시다 보면요
쓸려고 보다보면은
쓸 수 있는 곳이 거의 요거
하나뿐이에요
내가 어떤 함수 아니면 이것처럼
어떤 생성자를 호출하고 싶은데
그
생성자에 들어갈 수 있는 매개변수가
워낙 다양하니까 왜냐면
제가 템플릿에 쓰는
그 클래스 타입
그거는 제네릭이고 그죠
거기에 따라 어떤 생성자가
들어가는지 미리 다 알 수가 없으니까
그렇게 매개변수 넣을 때 완벽하게 forwarding
해주는 기능으로 쓰자라고 하면
이게 말이 돼요
그리고 이거 나온 다음에 저도 게임을
몇 개를 이제
쉬핑을 했죠 그 중 하나가
그
헤일로 아 뭐였지
4G PC 버전 헤일로
4G PC 버전도 했고 마인크래프트도
했어요 거기에서
이제 되게 큰 코드베이스였고
솔직히
굉장히 크게 뜯어고치는 작업들이
많았거든요 그 상황에서
그 방대한
코드베이스를 훑으면서도 제가
이 버라이오딕 템플릿을
써야만 됐던 경우는
제가 조금 전에 말했던 그런
forwarding 그
아귀먼트 인자들을 forwarding 하는게 전부였어요
제가
했던거가 어떤건지 대충
말씀을 드리자면은
음
어쨌든
그 저희가 만들고 있는
엔진이 멀티플랫폼 엔진이었어요
하나에서만 돌면 안되고 여러개로
돌아야 되는데 그러면은
렌더링 엔진이
윈도우스 버전에서는 디렉텍스
같은거고 그럼 디렉텍스에서
이제 레퍼런스 카운팅을 쓰죠
그래서 이제 그런 레퍼런스 카운팅 하는게 있었고
그리고 그게 아닌
다른 플랫폼에서 이제
뭐 어떤 플랫폼인지 말은 안하지만
콘솔같은 어떤 플랫폼에서
레퍼런스 카운팅 없이 그래픽 라이브러리를
써야되는 부분이 있었어요
그래서 그런 라이브러리는 이제 그 개체를
가져다가 초기화
이니셜라이저 호출해주고 어쩌구 저쩌구
해주고 지우는거는 마지막에
어쩌구 파이날라이즈
라는 함수를 호출하면은 알아서 지워졌어요
그러면 어찌보면은 이거를
쉐어드 포인터라는 개념으로 보면요
그죠 쉐어드 포인터
참조 카운트 이런걸로 보면은
뭐 생성은 생성이지만
지워지는 부분에서 어쨌든 간에
지워질때 파이날라이즈를
호출해줘야 하는 경우였어요
그러면 원래는
소멸자가 호출해야되지만 그 대신 파이날라이즈를
호출해줘야된다 그럼 소멸자에는
아 이 타입에 파이날라이즈만
호출해주면 되잖아요
그러면 저희가 템플릿 클래스를 만들수가 있었어요
템플릿 클래스 만들고
여기에 어떤 타입이 들어오던 우리는
소멸자에서 그 타입에
파이날라이즈를 호출한다 그건 오케이
근데
처음에 생성할때가 문제였어요
이 템플릿 클래스를 생성할때
뭐
아까 이니셜라이즈 호출하고
이니셜라이즈를 호출할때 받는
매개변수가 여러개였거든요
어떤거는 무슨 메모리관리제를 받기도하고
어떤거는 그냥 무슨 숫자를
받기도하고 그리고 이니셜라이즈를
호출하는건 똑같은데 함수명은
거기에 들어가는 매개변수가 달랐어요
그래서 아 이거는
버라이드 템플릿 써갖고
그냥 생성자를 만들고 클래스의 생성자를 만들고
클래스가 생성되는 오브젝트가
생성되는 순간
아 그거에 이니셜라이즈를 호출하면서
그죠 이니셜라이즈를 호출하면서
생성자로 들어온 매개변수를 호출하면 생성은 끝나고
그리고 아까 말했듯이
자동으로 그 템플릿화된
생성 아 클래스가 지워질때
아까 소멸자에
디스 파이날라이즈까지 호출해서
그 소멸자가 아니죠 소멸자 안에서
그 실제 개체
파이날라이즈까지 호출해서 한번에 해결될
수 있구나 그래서 그렇게 한번
만든적이 있어요 근데 결과적으로 보면은
메이크 유니크랑 별로
다를뻔 없죠 메이크 유니크도 결과적으로는
자기 템플릿이 하나 있고
그 안에 아 뭔가를
생성한 다음에 가지고 있다가 끝날때
아 이제 알아서
디스트로이 아 디스트럭터
호출하기 위해 있는거니까 사실
엄밀하게 따지면 방법은 똑같았어요
그거를 그냥
다른 플랫폼에서는 그런식으로 구현을 안하고
이니셜라이즈 뭐 파이날라이즈를
호출하게 만들었기 때문에 어쩔수 없이 그랬던거죠
이렇게 보고나면은
정말
이제 버라이어틱 템플릿이
쓸 곳은 있어요 가끔 이렇게
여러가지 플랫폼을 하나의
클래스로 좀 감싸갖고 크게 문제가 없게
만들기 위해서 있는데
그 외에
다른거는 저도 이제 아까
말씀드렸던 일곱가지 말씀드렸잖아요
그거 찾아보세요 구글가서
버라이어틱 템플릿 웨어 투 유스
그거 보시면은 이제
그렇구나 볼 수 있는데 요 한가지
외에는 쓰실 일이 별로 없을거에요
그래서 제가 쓰는거지만
그냥 거기 있으니까 이걸
어디든 써보겠다고
괜히 엉뚱한데 쓰지 마시고
이게 나온 배경 그거를 아시면은
아 원래 그거 하나용으로 만들었는데
내가 요거를 조금 딴데서 쓸 수 있겠구나
고정도로만 생각하시면 좋아요
이게 뭐 언어에서 지원하는 기능이니까
굉장히 모든 곳에 엄청나게
쓸 수 있을거야 라고 생각하는거
자체가 이제 큰 오산이에요
템플릿 프로그래밍 쪽에선 그 생각하면서
저희가 코드를 굉장히 많이 말아먹었어요
C++ 프로그래머 등
그래서 템플릿 프로그래밍 할 때는
이게 어떤 용도인지 알고
분명히 쓰시라는
말씀을 드리기 위해서
오늘 비디오를 만들었습니다
아이고 숨차다
예 끊을게요 포프였습니다
