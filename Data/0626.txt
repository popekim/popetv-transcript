안녕하세요, 포프입니다.

오늘도 GUID, 아니면 UUID라고도 부르죠? Globally Unique Identifier. 그 얘기를 할 건데, 그 예전에 되게 오래된 그런 비디오에요. 제가 만든 비디오 중에 'GUID을 DB에 저장할 때 조금 조심해야 된다.' 왜냐하면 DB에서 기본적으로 인덱스를 잡는 방식이 클러스터 인덱스인데, GUID는 클러스터 방식이 잘 안되기 때문에 클러스터를 끄기 위해서 이상한 짓을 해야 되는지 GUID를 PK, Primary Key로 사용했을 때 그 얘기를 한 적이 있어요.

이제 그걸 열심히 생각하다가 최근에 알게 된 게 하나 있어요. 이게 .NET 9에도 들어온 걸로 알고 있는데, UUID가 스펙이 여러 가지가 있는데, 그중에 UUID 7이라는 게 있어요. 이 UUID 7은 뭐냐면 GUID를 계속 만들면 기본적으로 랜덤으로 만들잖아요? 그런데 얘는 현재 시간을 가지고 있는 GUID에요. 그래서 시간에 따라 숫자로 정렬하면 내가 어제 만든 GUID는 반드시 오늘 만든 GUID보다 전에 오게 하는 그런 GUID가 나왔어요. GUID가 128비트죠? 그중에 6비트를 시간 정보를 저장하는 데 쓰는 거 같고, 실제 122비트만 랜덤하게 생성하는 거예요. 그래서 이런 경우에는 'PK로 이 GUID을 집어넣어도, 클러스터 인덱스에서 아주 크게 문제는 일으키지 않을 수 있다.' 라는 이론적인 이야기는 나와요. 여태까지 실제 측정에서 나온 것들 보면 빨라진 게 한 자릿수라고 그랬어요. 

근데 이제 GUID가 SQL DB에 들어가는 것 자체가 솔직히 조금 애매하긴 합니다. 왜냐하면 GUID라는게 나온 가장 큰 이유는 데이터베이스를 이제 RDBMS를 꼽아 쓰면 Int 기반의 자동으로 증가되는 Identity Column을 넣고 그러면 DB 서버가 알아서 숫자를 하나씩 증가시켜 주기 때문에 언제나 Unique ID가 나올 수 있거든요? 단, 그 ID를 외부로 노출하는 걸 기본적으로 보안상의 문제로 No라고 하죠? 그럼 외부에 노출되는 건 실제 사용자네임 그런 걸로 노출하되 내부적으로는 ID는 DB 자동 Increment 되는 게 훨씬 효율적으로 저장할 수 있고 그런 중복도 없앨 수 있어요. 왜냐하면 결과적으로 이거 하나가 싱글턴이예요. 그 DB 인스턴스 하나에 돌면서 걔가 책임지고 올려주는 거니까. 그런게 있는데, 문제는 이게 일반적으로 여러분이 하시는 그런 제품 말고 굉장히 대규모 트래픽에서는 DB 
서버 하나가 이걸 담당하는 것 자체가 트래픽이 너무 많이 몰릴 수 있거든요? 그런 경우에는 확률적으로, 제가 이 확률적인 알고리즘을 그렇게 안 좋아하는데, 그 '확률적으로 충돌할 가능성이 훨씬 적은 숫자를 만들자' 그러면 결과적으로 랜덤하게 해시코드 만드는 느낌인데, 이게 당연히 32비트면 충돌이 생길 거고, 64비트면 잘 안 생기긴 한데 생길 것 같고, 그러면 무조건 늘리다 보니까 '128비트면 잘 안 생기겠지?' 그래서 그걸 랜덤으로 만든 게 GUID에요. 그럼 거기서 128비트에 랜덤을 했는데, 이제 거기서 6비트를 뺀 거잖아요? 그리고 122비트에 중복을 하자는 거잖아요? 같은 시간대에 어떤 데이터가 들어왔을 때 6비트를 잃은 상태에서 중복이 될 확률은 조금 높아져요. 근데 '동일한 시간에 그렇게 많은 데이터가 들어올 수 있냐?'를 물으면 우리가 흔히 생각하는 그런 랜덤 알고리즘으로 해시를 만드는 것보다는 훨씬 적은 확률이겠지만 Globally Unique한 걸 보장은 하지 않아요. 하지만 그냥 그렇다고 믿고 쓰는 거죠. 이걸 보장하고 싶다면 언제나 그걸 보장해 주는 싱글턴 한 놈이 책임져주는, SQL단에서 Int를 증가시키는 방법이 훨씬 나은 방법이에요. 저장공간도 적게 들고요. 그래서 성능에 문제없던 그런 게 좋은 건데, 그게 아니라면 GUID로 가도 상관없어요. '그래, 오케이.' 그냥 믿고 가는 거예요. 근데 언제나 GUID를 쓸 때마다 '얘가 언젠가 충돌이 나지 않겠지?'라는 이제 걱정을 하면서 저는 써요. 해시 충돌도 64비트에서 남은 걸 본 적이 없어요. 32비트는 많이 봤는데 64비트에서 굉장히 많은 바이트가 0이 아닌 이상은 나는 경우를 본 적은 없지만, 그래도 프로그래머니까 '어딘가에 있는 확률적으로, 그 작은 확률이라도 나올 수 있다'는 불안함이 있어요. 로또보다도 훨씬 낮은 확률이긴 한데, 어딘가에 기분 나쁜 끈적거림이 있어요.

그래서 '128비트에서 6비트를 써서 122비트다.' 끈적임이 더 많아졌죠? 근데 그건 일단 128비트나 122비트나 똑같이 눈 감을 수 있어요. '속도가 빨라졌다? 좋아' 하지만 DB에 그 GUID을 넣었을 때 일반적으로 사람들이 하는 행태를 보면 또다시 기분이 나빠져요. 그 기분이 나빠지는 게 뭔지 알아요? 아까 말했던 GUID로 어떤 Primary Key를 만들었다? 일반적으로 그 GUID를 그냥 외부에 노출을 해요. API를 통해 노출을 하든, 아니면 URL을 통해 노출을 하든 그냥 노출을 합니다. 그래서 보통 어떤 웹사이트 가 보면 어쩌고 저쩌고 하면서 내 사용자가 나오고 Users하고 밑에 보니까 GUID로 딱 적혀있는 경우도 있어요. 그럼 그게 실제 내 ID인데, 외부 노출용 ID인지 DB ID인지 모르겠지만 DB ID로 사용하는 경우들이 굉장히 많아요. 그걸 근데 잘 생각을 해봐요. DB의 클러스터 인덱스의 효율성을 높이기 위해서 내부적으로 DB를 UUID7으로 바꿨어요. 그리고 아무 생각도 안 했어요. 그 GUID가 곧바로 외부에 노출이 되기 시작을 해요. 그러면 거기서 이 GUID를 생성한 시점이 나오기 시작합니다. 이게 사용자 ID라면 이 사용자가 몇 월 몇 일 몇 시에 그 웹사이트에 가입했는지 정보가 나가요. 보는 순간 분석만 하면 알아요. 거기서 찾아올 수 있어요. UUID7의 장점과 단점 중에 하나가 생성 시간이 거기 안에 인코딩이 되어 있어요. 그래서 그걸 다시 찾아올 수 있어요. 그럼 이걸 공개하는 순간 개인정보 문제가 생기는 경우도 있어요. 특정한 경우에 그걸 악용할 수 있는 경우도 있어요. 그래서 생각 못 할 때 갑자기 나가게 되고, 그 순간에 갑자기 껄끄러워지는 여러 가지가 저도 UUID7이 나온 거 이후로 이런 의심을 했고, Stack Overflow로 검색하니까 다 비슷한 얘기 해요. '이게 속도 향상은 아직 10% 미만이고, 거기에 이런 생성 날짜가 나가는 게 문제가 될 수 있는 상황인데, 그걸 꼼꼼히 잡지 못하는 경우도 있고...' 그래서 그냥 '뭐 굳이 그러냐? 그냥 옛날 방식 쓰고 논 클러스터 인덱스를 받거나, 아니면 옛날보다 더 옛날 방식 그냥 그렇게 트래픽이 굉장히 높고 분산 시스템이 중요하지 않은 상황이라면 그냥 GUID 없이 DB에서 만들어주는 Iidentity Column, Int 값 그걸로 가는 게 훨씬 낫다'는 얘기 똑같이 해요. 저도 똑같이 생각은 해요.

어쨌든 간에 GUID를 사용함으로 인해서 문제가 있었던 것들을 조금이라도 해결할 수 있는 실마리가 보이는 게 있어서 그 설명은 드렸고, 그것 때문에 조심해야 할 것도 같이 설명하기 위해서 오늘 비디오를 만든 겁니다. 저는 이런 대규모의 스케일링이 필요한 시스템이 아니라면 Int DB ID를 훨씬 좋아합니다. 그게 끈적함도 없고, 저장도 효율적으로 되고 그렇습니다.

포프였습니다.