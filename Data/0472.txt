오늘도 C++ 11 그 이후쪽 얘기를 잠깐 할거에요
제가 오랜만에 C++ 얘기하니까 사람들이 와 신난다 이럴 수도 있을 것 같은데
지금 나온 거로는 거의 동났어요 제가 말할 것들은
왜냐하면 C++ 11에 나온 것 중에 별로 중요하지 않은 것들은
가능하면 쓰지 말아야 하는 것들은 얘기 자체가 안하니까
전에도 말했지만 C++ 제가 비디오 강의 만들면서
거기서 정리하고 나왔던 내용 아니면 제가 잘못 알고 있던 거를
새롭게 알게 된 내용들을 다시 말했기 때문에 이런 시리즈가 나온거에요
오늘 얘기할 주제는 Constant Expression
상수 표현식이라고 하는게 맞을까?
어쨌든 Constant Express 이렇게도 얘기를 많이 하는데
요거에 대해서 말씀을 드릴게요
제가 Constant Express가 나오기를 되게 오래전부터 기다리고 있었어요
그리고 그 이유가 저는 컴파일 하는 도중에
스티커가 나오기 전에
스크린에서 해쉬 값을 뽑아내기 위해서 그랬고
옛날 블로그를 보면 그게 지원이 안되는 상태에서
제가 별별 꼼수를 써가지고 한 그런 기록까지 쭉 나와있어요
근데 어쨌든 간에 Constant Express가 제대로 좀 지원이 되면서 쓸 수가 있어요
아주 좋아졌죠
근데 저는 Constant Express에 대한 개념을 제대로 못 잡고 있었어요
요번에 포큐아카데미 준비하면서
포큐아카데미 강좌 그거는 또
비디오 밑에 넣어놓을게요
비디오 밑에 설명에 광고에요
그거를 준비하면서 Constant Express 섹션을 만들었죠
나는 왜 이걸 기다려왔고 왜 썼고 이런 식의 쓸 수 있다 라고 해서
자료를 만든 다음에 딱 비디오 녹화하기 전에 또 검수를 부탁드렸어요
전에 말씀드린 그 괴수 프로그래머
형님은 아니죠 저보다 나이가 어리신지만
어쨌든 형님이라고 불러서 괜히 이제
제가 나이가 어린 척을 잠깐 해보고 그 괴수 형님한테
보여드려서 이제 설명을 이제 보여드렸는데 강의 자료를
보더니 이거 잘못됐다고 딱 집어 주시더라고요
아니 C++에서도 뭐 이거 여기서 해결하는 거 이렇게 하면 해결됐는데
그거는 아닌 것 같다 그래서 뭔가 좀 설명이 이상하다
이분도 C++보다는 C를 주로 하시는 분이기 때문에
요건 이상하다 정도는 확실히 아세요 훌륭한 컴퓨터 프로그래머니까
근데 본인이 정확히 뭐라고 설명은 일단은 못하겠다 라고 말씀하셔서
Constant Express를 정말 다시 한번 봤어요
정확히 이 개념이 뭐였는지부터 온갖 조사와 나오게 된 배경과 다 연구를 했어요
뭐 공부를 하고 찾고
근데 제가 느낀 건 뭐였냐면 비디오 강의에서도 말해요
Constant Expression에 대해서 정의를 내리는 사람이 공통되게 다 동의를 하지 않아요
이게 뭐다 저게 뭐다 얘긴 다 많고 얘는 이거다 얘는 이거다
이때는 이걸 써야 된다 아니다 막 의견이 분분분분해요
근데 결과적으로 제가 이 모든
사람들의 의견을 다 보고
결과적으로 내릴 수 있는 결론은 딱 하나였어요
그러니까 논리적으로 말이 되는 설명 방법을 찾았어요 논리적으로
그래서 그게 이제 제 비디오 강의에 들어가 있고
그거를 짧게 줄여서 여기서 잠깐 말을 하려고 해요
자 Constant Expression이란 뭐냐
이게 과연 Constant랑 어떻게 다르냐라는 거예요 사실은
Constant가 있었는데 Constant Expression은 뭐야
자 Constant하고 Constant랑은 다르다
Constant Expression이 일단 다른 거예요
뭐 Constant Expression인 변수 함수 말고
변수는 당연히 Constant에요
그러나 그게 중요한 게 아니라 어쨌든 둘은 다른 거예요
Constant는 어떤 값이 한번 대입이 되면 변할 수 있냐 없냐 그게 전부예요
상수다 그게 전부인 반면에 Constant Expression은 뭐냐면요
프로그래머의 의도를 보여주는 거예요 어떤 의도
요 코드 아니면 요 변수 아니면 요 함수
요게 컴파일 도중에 다 실행이 돼서
그 결과 값이 컴파일 도중에 결정이 됐으면 좋겠다는 제 의도예요
물론 그 의도가 컴파일러가 완성을 못 시켜도 패스는 해요
근데 이게 중요한 게 왜 이거냐면은
이 의도가 왜 나왔냐라는 거거든요
그래서 왜 그걸 굳이 그래야 되는데
라고 생각을 하면은 사실 이거는
제가 별로 안 좋게 보는 템플릿 메타 프로그래밍이라고 있어요
C++에서 템플릿 프로그래밍이 나왔었죠
그게 나오게 된 이제 제 개인적인 이제 믿음은
주 이유는 당연히 제네릭한 컨테이너를 지원하기 위해서 나왔다고 생각을 해요
그런데 C++가 이제 컴파일을 다 해야 되는 언어다 보니까
그 제네릭한 어떤 타입도 들어갈 수 있는 컨테이너 배열 같은 것들은

그게 어떤 타입, 어떤 타입도 들어갈 수 있다는데
그 타입 자체는 컴파일 도중에 결정이 돼서
각 타입마다 맞는 어레이 배열용 코드를 컴파일을 따로따로 해주는 게
템플릿 프로그래밍의 시초였다고 저는 생각을 해요
근데 보니까 사람들이 템플릿 프로그래밍이
실제 해놓으면은 컴파일 도중에 결정이 돼버리네
코드를 자동으로 만들어주네
그러면 내가 코드 한량이 줄겠는걸?
그 생각을 하면서 이 템플릿 프로그래밍을 적용해서
정말 엄청난 데 막 악용을 했어요
그 악용한 거 일부가 바로 이런 거에요
어떤 함수를 호출을 해서 그 함수에서 결과를 받아내고 싶어요
뭐 대표적인 예는 Fibonacci 수열 이런 거죠
Fibonacci 수열 5가 무슨 값이냐 그러면 나오는 값은
함수를 다 돌리면 결정이 돼요
그러나 이거의 함수를 재기적으로 호출하다 보니까
실행 도중에 재기적으로 호출하면 시간이 너무 걸린다
차라리 컴파일 도중에 이 모든 함수가 실행이 되게 해서
그냥 숫자 하나만 딱 나오게 하자
이거를 템플릿 메타 프로그래밍으로 할 수가 있었어요
제가 템플릿 프로그래밍 메타 프로그래밍은 나쁘다라는 비디오였나
거기서 이거의 단점을 좀 얘기했죠
그런 단점들이 있기 때문에 이거를 쓰는 거 자체가 좀 많이 문제가 있었어요 사실은
가독성도 딸리고 템플릿 메타 프로그래밍의 한 함수를
실제 실행 도중에 똑같은 함수를 쓰려면 다른 함수를 또 만들어야 되고
이런 문제점이 보이니까 이거를 좀 언어적으로 제대로 지원해주고자 나온 게
컨스트 익스프레션이라고 저는 일단은 설명을 해요
왜? 컨스트 익스프레션을 쓰면 함수를 함수대로 쓸 수가 있어요
똑같이 함수대로 써요 피보나치 함수를 써요
단 함수 앞에 컨스트 익스프레션을 달아나요
그럼 무슨 의미냐?
야 난 이 함수가 컴파일 도중에 실제 최종 값까지 결정될 수 있으면
컴파일로 네가 값을 결정해서 그 마지막 상수 하나 반환해줘
그런데 그게 불가능하다면 예를 들어서
피보나치에 1 넣으면 당연히 나오지만
피보나치에 다른 변수를 넣어요 a 인테이저형 변수
그럼 a가 뭐가 들어갈지 모르니까 컴파일 도중에는 판단이 불가능하거든요
그럼 그런 경우에는 실행 도중에 함수를 실행시켜줘
이 두 개가 가능한 게 컨스트 익스프레션이에요
즉 이 함수를 실행 중에도 돌려도 되는데
난 최대한 가능한 한 컴파일 도중에 다 evaluation해서
최종 값만 줬으면 좋겠어라는 게 컨스트 익스프레션이에요
자 그럼 이렇게 하면은 아까 말했던 템플릿 프로그래밍에서
가독성이 딸린다거나 무슨 디버깅 한 게 어렵다는 거
왜? 컴파일 도중에 함수가 돌아보는데 어디에 브레이크 포인트 걸어서 디버깅 할 거예요
그러나 이거는 아니거든
실제 함수기 때문에 브레이크 포인트는 걸 수가 있죠
그리고 실행 중에 다른 값 넣어 보면서 이제 디버깅 가능하고
그래서 함수처럼 진짜 함수처럼 돌고
단 컴파일 도중에 최종 마지막 최종 값을 만들어줄 수 있는 함수를 이제 만들 수가 있게 된 거예요
그래서 이거를 하는 순간 템플릿 프로그래밍 악용하고 남용 막 했던 그런 코드들
웬만한 거 많이 걷어낼 수 있어요
그럼 잘 된 거죠
근데 여기서 또 한 가지 단점이 생길 수가 있죠
이 함수에서 어떤 이제 값을 넣으면은
요 함수의 최종 결과 값이 컴파일 도중에 결정이 될 수도 있고
실행 중에 결정이 될 수도 있다고?
그러면 저는 컴파일하고 난 당연히 컴파일 도중에 결정이 됐다고 생각했는데
아닌 경우도 있잖아요
그럼 내가 생각했던 거랑 똑같은 결과 안 나오잖아
그럼 짜증이 나죠
그래서 이런 것도 또한 방지할 수 있는 방법까지 같이 들어왔어요
그게 뭐냐
fibonacci 함수 아까 const expression이에요
요거가 함수가 있어요 함수를 호출해요
그럼 반항 값이 있죠
그 반항 값을 그냥 int a에 넣으면은 두 가지 버전 다 돌아도 똑같이 돌아요
아까 말했듯이 컴파일 중에 결정이 돼서 a에 최종 값으로 48이 들어오든
아니면 실행 중에 함수로 호출해야 되든 어쨌든 결과는 a에 들어와요
근데 이때 나는 이 함수에서 함수가 컴파일 도중에 evaluation 다해서
최종 값만 주게 강요를 하고 싶다 그러면은
아까 int a return 값을 집어넣는 변수 앞에 const expression을 또 붙이면요
이거는 컴파일 도중에 결과가 안 나오면은 컴파일 에러가 아예 나 버려요
지금 무슨 얘기냐?
const expression int a = fibonacci 1 했어요
그럼 컴파일 중에 다 컴파일이 되고 최종 값을 뽑을 수 있으니까 1이 반항되면서
문제 없이 이제 컴파일이 돼요
그러나 이게 fibonacci 하고 b를 넣었어요 어떤 변수를
그러면 얘는 함수가 b가 어떤 값인지 결정이 되지도 않았는데
이 함수를 돌려하고 최종 값을 뽑아낼 수가 없잖아요
그러면 얘가 그게 불가능하니까 얘는 함수 호출하겠다고 딱 나와요
근데 함수 호출에서 결과가 나오는 거를 const expression int a로 집어넣기 때문에
야 나는 니가 이게 컴파일 도중에 이 변수는 반드시 판단돼야 된다는데
이 함수 자체가 그렇게 않기 때문에 불가능해
그러면 이거는 내가 할 수 없는 이 컴파일 에러가 나와요
그래서 템플릿 메타 프로그래밍 하면서 반드시 컴파일로 해서 되게 하려고 했던 사람들은
앞에 const express만 넣으면 되고 그게 아니라 그냥 이거는 실행 중에 돌아도 괜찮은 건데
그냥 두 버전을 같이 한 함수에 넣기 위해서 쓴 거라면은 그냥 int a만 넣어도 되고요
그래서 그런 식으로 해서 이 템플릿 프로그래밍에 있어서 단점을 다 걷어내고
그리고 새로 const express 드로움으로 해서 나올 수 있는 단점까지도
이제 보완을 한 꽤 괜찮은 훌륭한 그런 게 나왔어요
물론 const expression 처음 나왔을 때부터 지금까지 역사를 보면은
버그 있어갖고 이것저것 좀 고쳤고 좀 문제 있는 것도 고쳤고
아직도 스펙이 좀 많이 바뀌고 있죠
그만큼 제 생각에는 const expression을 제대로 이해한 사람들이 없다는 거기도 해요
표준위원회도 이게 과연 뭐하는 건지에 대한 합치가 없는 상황에서
이리저리 만들다가 문제 발생해서 고치고 고치고 이런 게 아닐까라는 생각이 들고요
그래서 어떤 함수, 멤버 함수를 뭐 const expression으로 만들었다
그러면 이거는 뭐 const expression으로 만들어진 멤버 함수는 메소드죠
이거는 또 const expression인 거죠
const다 이런 식으로 일단 기본적으로 되어 있다가 최근에는 또 아니다로 바뀌었고
뭐 여러 가지가 많아요
그래서 const expression과 const는 반드시 같이 가지는 않아요
다른 건데 딱 const expression이 const를 보장할 때는 언제냐면은 변수에 붙을 때
왜? const expression int에 의하고 이제 실행 중에 넣어서 대입까지 했다면
이거는 상수라는 거죠
그래서 그거 하나 빼고는 const expression이 반드시 const인 경우는 최신 스펙에서는 없는 것 같고
옛날 한 중간 스펙 11인지 14에선지 한 번 있었던 것 같아
11이었던 것 같아
그래서 이거는 또 어느 버전 스펙선에 따라 또 왔다 갔다 하는 약간 좀 애매한 거
그러나 제가 말씀드렸듯이 업계에서도 학계에서도 정확히 이게 뭐다라는 모든 동의를 못 내리고 있고
제가 지금 이 const expression이 이제 스펙이 바뀌어가는 과정
그리고 정말 과거에 어떤 코드들을 const expression으로 바꾸고 있는지를 볼 때는
템플릿 메타 프로그래밍 남용하는 거를 막기 위해서 제대로 들어온 게 const expression이다라고 저는 정의를 할 수밖에 없어요
원 저자의 목적은 그게 아닐 수도 있지만 어쨌든 간에 모든 거는 어떻게 쓰이냐에 따라 하는 거기 때문에
const expression을 그렇게 이해하면은 훨씬 깔끔해요
밤에 편히 잠을 잘 수가 있어요
이거 해답 나오기 전까지 저는 잠도 못 잤어요
어쨌든 뭐 그렇다
그래서 이렇게 말씀을 드리면
c++ 10x 11 요거 아니에요 10x라고 해서
고거에서 이제 const expression에 관련된 내용은 요정도로 제가 마무리를 지을 수 있을 것 같고
혹시라도 이제 다음에 또 c++ 이제 신 스펙에 대해서 새로운 스펙에 대해서
괜찮은 것들이 조금씩 더 보이기 시작하면 설명은 해드릴게요
근데 스펙에 나오는 거 다 쓰지 마세요
아마 80% 정도는 버려질 내용인 것 같아요
업계에서 배우기 시작하면
그 정도로 설명을 드리고
뭐 c++ 얘기 많이 듣다 보면은
아 뭐 쓰지 마라 써라 이런 얘기 많죠
그거 확실히 알고 싶은 분들은 제 동영상 강의를 보시면 됩니다
포프였습니다
