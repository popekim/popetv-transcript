오늘은 오랜만에 그래픽 프로그래밍 얘기를 다시 해볼게요.
최근에 잠시 또 정지 중단을 했지만 사이드로 진행하던 게임 프로젝트
가 좀 있었어요.
좀 재밌을 것 같아서.
그거를 하면서 이제 아무리 봐도 기존 엔진을 쓰는 건 별 의미가
없어서 자체 엔진을 만들었는데 저 말고 다른 분이 이제 렌더링
엔진 쪽을 좀 많이 만들었거든요 .
그 사람도 해보고 싶다고 해서 만드는 동안에 제가 예전에 게임
회사 다니면서 했던 그런 기법들을 많이 설명드리고 그걸 구현하게
만들곤 했어요.
그래서 그중에 하나 나왔던 게 압축 버텍스 포맷이에요.
뭐냐면 이게 사실은 스페이스마리 만들 때도 그랬고 제가 이제 헤일로
참가할 때도 그랬고 주로 쓴 기법 이거든요.
이 개념이 뭐냐면 일단 이렇게 설명 을 드릴게요.
캐릭터 하나를 만드는데
메모리가 얼마나 될까 텍스쳐는 따로 빼죠 이미지니까 텍스쳐는
뭐 1024 곱하기 1024면 대충 그게 이제 인맥 포함해서 한 3회가 먹는
다고 보거든요.
그래서 그런 것 좀 빼고 순수하게 모델 버텍스 그러니까 모델이면
삼각형으로 만들어진 거잖아요 3d 모델이 그럼 그 삼각형 때문에
내는 삼각형 때문에 드는 메모리 가 얼마나 될까를 볼게요.
일단 기본적으로 보죠.
캐릭터 모델을 만들면 거기에
삼각형이 몇 개 있을까 폴리곤 이라고 그러죠 폴리곤이 몇 개 있을까
를 생각해보면 돼요.
폴리곤을 생각을 해보자고요.
폴리곤이 과연 몇 개 있을까 그러면 제 기억으로는 스페이스마리 만들
때도 그렇게 하이폴리곤은 아니 었어요.
좀 많이 줄여서 썼는데 그거만 해도 실제 몇 만 폴리곤이 나왔어요
.
그럼 요즘 게임 같은 경우에는 최소한 캐릭터 모델 하나에 한 3만
폴리곤 정도 잡을까요 2만 정도 잡죠 2만 폴리곤이라고 해요.
2만 개의 다각형이 있다.
그럼 폴리곤은 3만 폴리곤 정도 잡을까요 2만 폴리곤이라고 해요.
보통 이제 사각형을 보통 폴리곤 이라고 하니까 게임 쪽에서는
게임 모델링 쪽에서는 그걸 삼각형 으로 나누면 4만 폴리곤이 되는 거예요
4만 삼각형 4만 삼각형이면 이제 보통은 요즘은 정점을 다 스플릿
하잖아요.
그러면 그 정점 아 스플릿 안 할 수도 있구나 스무스 노바리면
.
근데 보통 한다고 보면은 뭐 아니 안 한다고 봐도 그럼 안 한다 좀
이렇게 적게 잡죠 적게 낫겠다 그럼 4만 개면은 거기에 원래 삼각형
이 3개씩 있어요.
3개씩 돼야 되는데 정점이 3개가 삼각형이 하나니까 총 정점이
12만 개가 돼야 되는데 이거를 한 반 정도 재활용이 가능한다고 보고
한 6만 개 정도라고 보는 거예요.
그러면 모델 하나 만드는데 정점 포인트가 6만 개가 필요하다.
그럼 6만 곱하기 각 정점마다의 사이즈를 보면은 그게 메모리겠죠
일단 6만은 적어두고 6만 그러면 한 정점에 무슨 데이터가 들어가냐
위치가 들어가야죠 위치하면은 xyz 그쵸.
그러면 이게 플롯으로 3개예요 플롯이 뭐냐면 4바이트 그쵸.
그러면 12바이트 아이고 이렇게 생각하면 헷갈리는데 그냥 플롯 3개 이렇게
하죠 플롯 3개 그리고 텍스처를 씌우려면 uv 코올렌션이 들어가야
되죠.
여기에 uv 그러니까 텍스처 0 0이 들어가는지 1 2이 들어가는지 텍스처
에서 어느 부분을 이 버텍스에 집어 넣을 건지 그럼 그게 플롯이 2개
잖아요 u하고 v 그럼 플롯이 5개예요.
그 다음에 제가 조명을 받으려면 은.
법선이 필요하잖아요 표면이 어디로 향하고 있는지 가리키는 법선
그게 xyz죠 3개예요 그러면 xyz 8개예요.
근데 노멀맵핑 하려면 탄젠트 들어가 고 바이노멀 들어가야 되죠 그럼
3개씩 또 추가를 해요 그러면 내가 몇 개였어 1 2 3 4 5 6 7 8 8개였죠
8개에다가 6개를 추가해야 되는 거예요 그럼 14개가 돼요 14개 이게
끝이냐 음 봅시다.
14개가 끝이냐.

끝일 수도 있고 아닐 수도 있는데 14개에다가 텍스처 맵을 두 개를
따로 이렇게 겹치고 싶으면 uv가 하나 더 들어가야 돼요 보통은 많이
집어넣거든요 그럼 16개가 돼요 최소 16개예요 거기다가 스키닝
을 하거나 이러면 본을 보통 4개 스키닝을 하니까 그러면 스키닝
에 들어가는 정보가 들어가는데 일단 그건 빼자고요 복잡해지니까
그러면 지금 제가 계산한 게 16개 맞죠 위치 노멀 탄젠트 바이노멀
.
맞죠.
16개예요 그러면 16개면은 아까 말했듯이 4바이트씩이니까 플롯
하나가 64바이트거든요 그럼 64바이트 에 제가 아까 삼각형이 6만 개라고
했던 거 같아요 그죠 그럼 계산을 해 보자고 칼큘라이터 뽑아서 아니
적어둘 걸 그랬네 그 정점이 6만 개라고 그랬던 거 같은데 64에다가
6만 개를 해봐요 그러면 이게 3.8메가에요.

모델 안에 3.8메가에다가 이제 lod 몇 개 하면은 이게 또 엄청나게
많아지는 거예요 그래서 제가 최근에 만들었던 게임은 버텍스만 거의
몇백 메가 1기가 먹은 적도 있어요 워낙 모델이 많으니까 게임 안에
그리고 왜냐하면 3.8메가라고 해도 lod를 보통 하나 둘 세 개를 만들
잖아요 그러면은 그게 보통 2배 정도 3배 정도가 돼요 그러면 그것만
해도 일단 8메가.
그러면 10메가 정도라고 보시면 돼요.
그럼 모델 하나에다가 10메가 최소한 그 모델 그 버텍스 하나에
그 가격에 나오는 거거든요 그리고 여기서 그럼 캐릭터가 다른 게 열
개가 돈다 그럼 그게 100메가야 그리고 이제 배경 같은 거 들어가
야 되죠 그것도 막 버텍스 10만 개 넣고 이런 경우도 있어요 어떤
애들은 그건 잘못된 거지만 그럼 결과적으로는 제가 예전에 옛날
게임 돌릴 때도 한 10년 전에 게임 돌릴 때도 한 프레임에 처리했던
삼각형 수가 한 10만 개 정도는 됐 어요 못 해도.
지금은 이제 그것보다 한 별배는 많겠지 10배는 좀 무리겠다 최근에
본 건 50만 개 찍은 적도 있구나 그럼 50만 개만 해도 그 수가 엄청
나잖아요 사실은 그리고 문제는 메모리를 먹는 문제뿐만이 아니라
예를 들어서 메모리를 제가 이걸로 먹어놨어요 그러면 이제 메모리
가 gpu에 들어가서 이 메모리를 처리 해야 될 거 아니에요 그럼 그 메모리를
트랜스퍼하는 과정도 있거든요 cpu에서 gpu로 그럼 그 속도 문제도 있고
메모리 많이 먹는 문제도 있고 이런 것도 있는 거예요.
그래서.
그래서.
저희는 압축 포맷을 많이 써요 압축 포맷이 뭐냐 아까 말했듯이
위치는 xyz가 이제 플러스로 들어가 있으면 4바이트 식이거든요 근데
만약에 이 뭐라 그럴까 모델 자체가 엄청나게 크지 않고 한 모델은 언제나
조그맣고 이거를 다른 위치에 이렇게 위치만 시키는 그런 개념이라면
여기서 과연 4바이트에 필요한 그런 정밀도가 필요 없을 수도 있어요
그러니까 예를 들어서 내 숫자가 언제나 0부터 한 50까지만 왔다갔다
왔다갔다 그러면 여기는 그 정도의 정밀도가 필요 없을 수가 있거든요
그럼 위치를 플러스 32비트짜리 4바이트 짜리 넣는 대신에 16비트에
넣을 수가 있어요.
물론 c에서는 16비트 플러스를 제대로 지원을 안 하지만 gpu에서는 지원
을 해요.
그럼 그거를 16비트로 넣어놓고 그 gpu에 얘기해줄 때 나 이 포지션
은 사실은 f32 플러스 32가 아니라 플러스 16이야 라고 넣어주면 쟤
내가 알아서 판단해서 뽑아와요 .
그럼 이제 문제는 c에서 c++에서 f32가 아니라 f32가 아니라 f32가 아니라
f32가 아니라 f32가 아니라 f33이 되는거에요
그리고 gpu의 자리에서 f32를 넣어서 32비트 플러스를 16비트에 어떻게
저장하는지 그것만 잘 알면 되는 거죠.
그래서 예를 들어서 위치를 16비트 를 줄일 수 있었다 그럼 이미 위치
에서 절반이 잘리는 거죠 그리고 ub는 어때요 ub는 0부터 1 사이 잖아요
보통.
근데 언제나 0부터 1 사이라고 가정할 수가 있다면 이것도 16비트
로 넣을 수 있는데 이거를 노멀라이즈로 넣어요.
노멀라이즈드 의미가 뭐냐면 인테리어로 넣는데 0을 0으로 두고 16비트의
최후값이 2에 16승-10승입니다.
그러면 1.0을 2에 16승 마이너스 1로 맵핑을 한 다음에 그 중간 값을 그냥 놓아주는 것 뿐이에요.
그러면 2에 16승이면 한 6만 5천 되는 건가?
그러면 한 6만 5천인가 3만.. 6만 5천 맞을 것 같아요.
그러면 6만 5천 단위가 있는 거예요. 0부터 1 사이에 단계가 6만 5천 개가 있기 때문에 정밀도는 충분하거든요.
근데 만약에 유비가 0, 1이 아니라 마이너스 1까지도 가고
마이너스 1부터 1은 상관이 없는데 0에서 1을 넘어서 2, 3까지 가면 좀 골아파지는 건 있는데
그런 경우에는 똑같은 얘기로 0에서 최고까지를 정해주고 우리는 최대 16까지만 맵핑을 할 수 있다.
그럼 0에서 16까지만 해주고 아니면 마이너스 16까지 16까지만 해주고 이 중간 값을 단계별로 나눠서 저장을 한 다음에
쉐이드에서 불러와서 그 마이너스 16이나 16을 곱해주면 되는 거죠.
그래서 그렇게 유비를 저장을 한다면
그것도 32비트짜리가 16비트로 들어가요.
그리고 실제 이거는 굉장히 많이 해요.
포지션을 16비트로 줄이는 경우는 좀 덜해요.
왜냐면 정밀도 문제가 있을 수 있는 경우가 많기 때문에
그래서 뭐 포지션은 두더라도 유비를 그렇게 줄였다 예를 들어서
그럼 유비 2개를 줄이면 32비트 총 4개 있었잖아요.
유비 1하고 유비 2하고 2개 합쳐서 반으로 줄어드는 거예요.
그게 가능하고 세 번째 재밌는 건 그거예요.
노말.
노말은 언제나 그 반으로 줄어드는 거예요.
그 범위가 노말라이즈된 노말이죠.
그러니까 정규화시킨 노말은 마이너스 1부터 1 사이예요.
X든 Y든 Z든.
그리고 노말은 뭐라 그럴까
노말라이즈된 거면 정규화가 된 거면
XYZ 그니까 길이 구하는 공식 있잖아요.
X제곱 플러스 Y제곱 플러스 Z제곱 하면은
언제나 값은 1이 나와야 되죠.
이 속성을 이용하면 되게 재밌게 인코딩을 할 수가 있어요.
일단 X든 Y든 Z든 마이너스 1부터 1 사이라고 했어요.
그러면 이 단계를 과연 우리가 뭐라 그럴까
압축을 할 수 있냐 질문하면 가능한 거 같아요.
마이너스 1부터 1 사이를 16비트로 넣으면은 총 6만 5천 단계로 들어가는 거잖아요.
그러면 그거를 노말라이즈를 해서 넣으면은 충분히 정밀도가 나와요.
그럼 XY를 그렇게 집어넣어요.
마이너스 1부터 1까지 마이너스 1부터 1까지.
그럼 Z는 어떻게 되냐.
안 넣어도 돼요.
왜냐고?
X제곱 플러스 Y제곱 플러스 Z제곱은 1이어야만 되거든.
그러면 이거를 X하고 Y값만 있으면 Z는 구할 수가 있어요.
단 단점은 Z가 플러스가 나올 수도 있고 마이너스가 나올 수도 있죠.
그러면 이게 플러스인지 마이너스인지에 대해 정보.
그니까 C에서 인코딩을 할 때 X하고 X제곱 Y제곱을 해보고
그리고 이제 이거에서 1 마이너스 뭐 X제곱 Y제곱하고 루트를 씌웠을 때
그리고 이게 이제 어떤 값이 나오잖아요.
플러스의 값이 나올 거잖아요.
그러면 이게 Z하고 맞는지 확인해서 맞으면은 양의 기호를 인코딩을 하고
틀리다면 음의 기호를 인코딩하면 돼요.
그리고 셰이드에서 곱해주면 하면 되거든요.
결론적으로 말하면 뭐냐면
XY만 저장을 하고 Z에다 마이너스 1을 곱해줘야 되는지 1을 곱해줘야 되는지는
결국에는 불리언 플랙 하나로 되는 거잖아요.
비트 하나면.
그러면 이 XY 중에 아까 16비트 다 쓴다 그랬죠?
15비트만 쓰고 1비트에 부호를 그냥 넣으면 돼요.
그래서 15비트에 그 마이너스부터 1까지의 값을 넣고 이 1비트에 과연 Z에 곱해야 될 값이 플러스에 마이너스에요.
이것만 넣으면은 노말이 딱 16비트 2개에 들어가요.
32비트 3개가 아니라.
탄젠트도 똑같이 들어가요. 그렇죠?
여기서 또 하나 재밌는 거. 바이노말은 안 넣어도 돼요.
그 이유는 이거에요.
바이노말의 개념 자체가 노말하고 탄젠트가 있을 때 이 두 개의 직교하는
벡터가 바이노말이에요. 맞잖아요.
그러면 이 두 벡터가 있으니까
이 바이노말은 계산으로 구할 수가 있는 거예요, 언제나.
그 취에다 코드 안에서.
단, 한 가지 차이점은
곱하는 순서에 따라
바이노말의 그 벡터가 향하는 방향이 달라져요.
이쪽으로 향할 수도 있고 이쪽으로 향할 수도 있어요
그니까 플러스 마이너스의 또 개념인데
이것도 아까 그 인코딩했던 것처럼 미리 계산해본 다음에
이게 내가 뭐 노말에다가 바이노말
그니까 크로스 프로덕트 하면 돼요 외적
외적을 했을 때 나오는 벡터랑
지금 내 그니까 뭐지 노말하고 탄젠트를
외적을 했을 때 나오는 벡터랑 바이노말이 향하는 방향이 같은가?
같으면은 그냥 뭐 플러스를 저장하고 틀리면 마이너스 저장하고
그러면 또 어딘가에서 한 비트만 떼놔서 저장하면 돼요
그럼 아까 노말에서 한 비트 떼갖고
노말 x, y에서 한 비트 떼갖고 저장했죠 노말 z를 위해
탄젠트에서 x, y에서 한 비트 떼갖고
탄젠트에 z를 저장하는 부호를
비트를 저장했어요
그럼 여기서 그냥 탄젠트나 노말에서 하나 더 빼갖고
한 비트만 더 빼서 y쪽에서
바이노말 방향은 어디를 가리키냐를 인코딩하면 되는 거예요
그러면 바이노말이 떨궈져 나갔죠
그럼 뭐 남았어? 없는 거잖아요
그럼 몇 바이트인지 보자고요
일단 12 바이트는 음
그 포지션을 제대로 해서 저장한다고 봐요 그냥
그건 압축 안 하고 12 바이트 들어가고
그 다음에 u, b 두 개는 저희가 16 비트씩 4개 해놓았으니까
이게 2 바이트 8 바이트예요
그럼 이게 아까 12 바이트였죠 20 바이트가 돼요
그럼 20 바이트 다음에 노말 탄젠트 다 합쳐갖고
그게 16 비트 2개 2개 해갖고 총 16 비트 4개 들어가잖아요
그러면 그게 16 비트 4개면 아 헷갈려
8 바이트예요 역시
그러면 아까 12 플러스 8 플러스 8이죠
그러면 이게 28 바이트가 되는 거예요
그럼 아까 계산했던 게 몇 바이트였어? 64 바이트 아니었나?
아 헷갈려
맞죠? 64 바이트예요
64 바이트가 이제 28 바이트가 된 거예요
그러면 28 나누기 64면은 몇 프로 절약이야?
54 프로 53 프로 절약이거든요
그러면 이렇게 하는 것만으로도 메모리가 절반으로 먹는다는 거예요
그래서 실제 버텍 모델이 엄청 많은 게임에서는 다 이렇게 나갔어요
스페이스마린도 엄청 이렇게 줄였고
심지어는 뭐라 그래 그 스키닝 하는 것도 엄청 그렇게 줄인 적이 있어요
스키닝에서 본 웨이트 있잖아요
본 웨이트랑 이제 어느 본에 어느 정도의 영향을 받느냐 보통 플롯으로 저장하는데
저희 스페이스마린 할 때 이거를 플롯이 아니라 uint16도 아니야
uint8로 저장했어요
256 단계로 그렇게 기억해요
그래서 엄청나게 줄였죠
원래는 32비트짜리 4개 들어가야 되는 게 8비트짜리 4개였으니까 그건 4분의 1로 줄인 거고
그래서 엄청나게 압축을 할 수가 있어요
그 대신 쉐이드에서 좀 더 많은 일을 하면 되는 건데
요즘 뭐 cpu보다 gpu가 빠르고
제가 볼 때는 gpu보다 메모리가 더 귀한 그런 상황이었기 때문에
그래서 이거를 모르겠어요
요즘 엔진을 쓰는 사람들은 자세히 고민을 안 할 것 같긴 한데
음 이런 저는 모든 엔지니어링의 기반이 결과적으로는 메모리 관리라고 보거든요
왜냐면은 메모리가 그냥 단순히 메모리 많이 먹는 그 문제가 아니라
메모리가 많아지면 많아질수록 실제 캐쉬에 들어가는 캐쉬 미스도 많아지고 속도에도 영향을 주고
최적화에 신경 쓰는 사람들 정말 메모리하고 이거에 신경을 많이 써야 되고
메모리를 알면은 어떤 언어를 돌리던 간에
좀 더 프로그래밍을 빠르고 효율적으로 잘 짤 수 있어요
그게 이유가 뭐냐면
어차피 컴퓨터는 메모리에 들어간 숫자를 어떻게 이해하고 어떻게 쓰느냐가 전부거든요
심지어는 우리가 말하는 컴퓨터 명령어라고 하는 컴파일된 언어에서 명령어들도
결과적으로 메모리에 있는 어떤 정해진 값일 뿐이고
컴퓨터는 그걸 읽어서 어떤 명령어로 인식을 해서 그걸 실행시키는 게 전부예요
그러니까 이거는 명령어다 이건 데이터다 이걸 아는 것 뿐이고
그래서 이런 저 수준에서 메모리를 고민을 좀 더 많이 하다 보면은
확실히 컴퓨터에 대한 이해가 높아져요
말도 안 되는 버거가 터졌을 때도 이걸 어떻게 고쳐야 될지도 볼 수가 있고
최근에도 그런 일을 했는데
그래서 오늘은 좀 굉장히 디테일하게 들어가서 말이 많아졌는데
이거에 대해 찾아보세요
compressed vertex format이라고 찾아보면은 더 나와요
이거 어떻게 하고 어떻게 하는지 저도 처음 할 때 당연히 찾아봐서 한 거기 때문에
제가 말하는 거로는 이런 게 있다 아 이렇게 가능하구나
숫자가 64바이트가 28바이트가 되구나 이 정도만 알아주시고
나머지는 찾아가면서 자세한 거 구현하시면 되지 않을까 싶어요
그걸 제가 찾긴 귀찮고
음... 아우 말 많이 했다 목이 갈라지고 있어
그럼 이 정도로 하고 머리 아파요 계산했더니 포프였습니다
