예 안녕하세요 포프입니다 음 잠깐만 볼륨 좀 끌고 스피커 예 포프입니다
음 오늘은 jwt 토큰에 대해서 말하려고 해요 jwt 토큰 잠깐만 이게 무슨 약자
였지 어 json 웹 토큰이구나 음 잘못 말했다 java 웹 토큰 이럴 뻔 했네
json 자체가 자바스크립트에서 나온 거기 때문에 이게 뭐냐면 최근에
제가 이제 아 오픈 id 커넥트 서버 를 만들려고 하면서 뭐 authorization
하고 뭐 authentication이 다른 거 잖아요 그래서 그거 이제 고민하다가
이제 뭐지 oas에서 하지 않는 그런 부분까지도 이제 오픈 id 커넥트가
해주니까 그런 부분을 고민하다가 뭐 authentication 토큰은 어때야 되고
authorization 토큰은 어때야 되고 막 이런
연락을 받는 그런 부분을 고민 하다가 뭐 authentication 토큰은 어때야 되고

여러가지를 보다가 그때 본 게 이제 jwt 토큰이라고 있어요 뭐 어찌보면은
제가 뭐 웹 쪽을 완벽히 전문으로 되게 오래 한 사람은 아니니까
잘 이미 나와 있던 걸 제가 제대로 모르고 있었던 것 같은데
jwt 토큰을 보면서 이제 아 이거를 무슨 뭐 뭐라 그러지
이제 오픈 id 커넥트에서 쓸 수 있겠구나 oas 쪽 토큰이 아니라 그래서
쓸 수 있겠구나 authentication 용으로 쓸 수 있겠구나 생각을
하다가 갑자기 그런 생각이 든 거예요 아니 그러면 왜 jwt 자체를 액세스 토큰으로 써도 되지 않을까
그러니까 이제 어스 토큰이라고 해야 되겠다 사실은 정확히 얘기하면
oas에 보면은 이제 oas로 이제 뭐 id하고 비밀번호 로그인을 하거나 그러면
토큰을 주잖아요 그래서 저희는 저는 그냥 access 토큰이라고 부르는데 아마 정확한 이름은
어스 토큰인 것 같아요 oas니까 authorization 토큰인 것 같아요 아 그니까 지금 제가 이렇게 이제 사실은 그냥
그러면은 보통 지금 현재
이 설명을 하려면
좀 많아지는구나 갑자기
oauth가 왜 나왔고 뭐 access 토큰을
가져와서 뭐 bearer 토큰을 가져와서
다른 리소스를 히팅하는 이런게 왜 나왔는지도 약간 설명을 해야 될 것 같은데
너무 길어질 것 같아 하기가 싫어져
간략하게 설명을 하면 이건 것 같아요 이제
저는 이제 뭐 반드시 이게 연관이 있는 거 아니지만
지금 저는 연관시켜서 많이 보고 있거든요
저희가 보통하는 RESTful 서비스라는게 있잖아요
RESTful 서비스에서는 기본적으로
한 번 내가 호출을 했을 때 그 호출 하나하나가
독자적인 호출이어야 된다 리소스를 가져오거나
리소스를 업데이트하거나 독자적인 호출이어야지만
서버 쪽에서 session 같은걸 유지 안하고
state를 유지 안하고 계속 내가 필요한
그러니까 리소스에 접근할 수 있다는게
기본적으로 RESTful이 많이 각광을 받는 이유라고 생각을 해요
이게 왜 필요하냐면
한마디로 만약에 제 서비스에
사람이 굉장히 많이 몰린다고 가정을 해봐요
뭐 동접이 한
만 명 정도다
그럼 이제 서버 하나로 버틸 수 있는 방법이
없잖아요 그래서
서버를 여러 대 두고 돌려야 되는데
스케일이라고 하는데 그럼 여기서
문제가 되는게 옛날처럼 서버
사이드 세션을 쓰게 되면은
처음 유저가 로그인할 때 서버 A에서
그 유저 로그인 정보를 가지고 있고
그 다음에 유저가
다른 리퀘스트를 막 해도 아 얘는
이미 한 번 로그인 했던 애라는걸
내가 서버 쪽에서 session으로 들고 있기 때문에
그냥 접근 권한을 계속 주는거죠
그래서 이게 어찌보면은 옛날에
스케일 러빌리티를 크게
고려하지 않은 방법 중에 하나였다고 생각을 해요
그러다가 이제 서버가 두개가 되면은
서버가 두개가 됐으니까
아 이제 갑자기 막
로드가 몰리면 서버 B로 B나 A
양쪽으로 보내주게 로드 밸런싱을 하면 되는데
문제는 서버가
이제 로그인 했을 때 유저가 서버가
session을 들고 있잖아요 서버 A가
근데 그 다음 리퀘스트가 서버 B로 가면은
로그인이 안 되어있는 상태이기 때문에
다시 로그인을 하라고 나올 수가 있었던 거죠
그래서 그거를 제대로 관리하려고
핵 중에 하나를 썼던 거는
이제 스티키 세션이라고 해서
로드 밸런스에서 일단 이 유저 브라우저를
A로 한 번 보냈다면
아무리 로드가 막 몰리고 난리가 나도
유저 A만큼은 서버 A로
보내는 거지 그래서 계속 한쪽
세션으로 보낸 스티키 세션이라는게 있었고
아니면 그 세션 정보를 이제 DB에
저장하는 방법이 있었는데
옛날엔 주로 스티키 세션을 많이 썼어요
일단 하니까
근데 이제 RESTful에서의 문제는
그냥 이 각
HTTP 콜 하나가
어찌 보면 리소스를 업데이트
뭐 하거나 가져오거나 뭐 딜리트 하거나
이런 거를 하나의
아토믹 액션으로 봐주는 건데
그렇게 되면 서버가 막
수천만 개가 있으면 그 중 하나만 가면은
상관이 없다는 개념이어야 되거든요
근데 이제 HTTP 콜 하나하나마다
아 얘를 로그인 할 수는 없잖아요
얘를 야 얘가 유저 아이디가 이거고
패스워드가 이거니까 로그인 한 다음에
이렇게 해줘 라고 할 수 없으니까
그 대신에 처음에 로그인 할 때는
이제 유저 패스워드하고 아이디를 받아오고
그럼 아 이게
유저 아이디하고 패스워드가 맞고
그리고 지금 얘가 로그인 하면서
이런 이런 이런 리소스를 쓰고 싶다고
허용을 했으니까
그 리소스에 권한할 수 있는
특별한 토큰을 주겠다는 얘기에요
그러니까 이거는 어떻게 보면은
어느 한 어느 정도
시간 동안
발리드한 키에요
그러니까 내가 만약에 보통 뭐 이거를
구이드로 주는 법도 있고
해쉬스트림으로 주는 법도 있는데
예를 들어서 내가 로그인 했을 때
아 나 이 정보에
예를 들어서 내 이메일에 접근하고 싶어
라는 권한을 주면은
그거에 해당하는 액세스 토큰을 주는 거죠
예를 들어 토큰이 abcd였다
그럼 그 다음부턴 나는 이메일 서버에서
내 이메일 가져와
이메일 보내 이메일 지워
라고 하는 이제
HTTP REST 콜을 계속 쓰면서
헤더에 어퍼라이전 헤더에
이 액세스 토큰 abcd만 넣어주면은
이제 이쪽에서 그 토큰을 보고
아 얘가 이 이메일 계정에 접근할 권한이 있구나
라고 해서 권한을 그냥 주는 거예요
아 그러니까
뭐라 그럴까 그리고 이 토큰은
보통 시간이 있죠 뭐 60분 안에 써야 된다던가
뭐 이런 개념들이
그래서 몇 분 뒤에 로그아웃 되고
이런 개념이 있는 건데
이거를 보통 뭐 어쨌든
그냥 액세스 토큰이 있으면
서버를 여러 개 쓸 수 있다는 건 좋아요
그냥 서버가 어디에 있든 아무리 스케일을 해든
그냥 그 서버에만 가면 되니까
근데 서버 뒤쪽에서는 어차피 문제가 뭐냐면
얘가 로그인해서
이 토큰을 받았고
이 토큰이 60분 동안만 사용이 가능하다라는
정보를 어딘가에는 저장을 해놔야 돼요
그래서
굉장히 단순하게 저장을 해두면
그냥 SQL DB에
적어놓으면 되죠 아 이 유저
아이디가 이 액세스 토큰이 있고
접근 권한 뭐 스코프라고도 하기도 하고
클레임이라고도 하죠 요즘은
뭐 스코프나 클레임이 이거고
이게 만료되는 시간은 여기까지라는 걸
DB에 박아두고 모든
웹서버에 request가 올 때마다
그 액세스 토큰 DB를 읽어서
아 얘가 지금 권한이 있나 없나
이 액세스 토큰이 아직까지 권한이 있는 건지 보고
있으면 허용을 하고 아니면은
리젝을 해버리는 스타일이었거든요
이제 문제는
결과적으로는 액세스 토큰을
DB에서 확인을 해야 되기 때문에
서버를 아무리
수만 개 수천 개를 늘려도
결과적으로는 DB가 보틀렉이 될 수 밖에 없어요
뭐 DB를 리플리케이트하고
리드홀리로 만들고
이런 법도 있지만 결과적으로는
보틀렉이 조금씩은 생길 수 밖에 없다는 거죠
그러면
그거를 또 해결하기 위해서
웨디스나 이런 계열의
맴캐쉬 같은 그런 스토리지를 만들고
거기에다가 액세스 토큰을 박아두고
뭐 이제 확인하면 되는 거니까
그리고 이거는 메모리에만 존재하는 거니까
무슨 뭐 익스파이어
내릴 타임을 제대로 집어넣어주면
그 뒤엔 또 액세스 토큰이 사라지기도 하니까
DB에서 매뉴얼하게
언젠간 지워줘야 하는 것보다는
좀 더 나은 방법이지만 역시
DB에 웨디스도 설치해야 되고
여러 가지를 여러 개 설치하다 보면은
서비스는 페일할
부분이 많아지는 거예요 포인트 오프 페일러가
많아지기 때문에 역시 뭐
뭐 많이들 그러는데
사실은 요즘은
아주 훌륭한 방법이라고 하기는
좀 그렇죠 여러 가지 설치해야 될 것도 많고
어찌 보면은
이제 웹 개발이 한동안 그냥
서버 하나와 DB 하나로 완성이 되는
그런 시스템이었다가 가면 갈수록 이제
이런저런 문제를 해결하기 위해서
새로운 것들을 도입을 하는데
뭐 굉장히 스케일이 크지만
크지 않은 곳이라면은
DB에서만 해도 충분한 것 같아요
근데 이제 스케일이 커지기 시작하면 이제 그때부터
복잡해지지만
한 가지 여기서 하고 싶은
또 우려의 말은
그냥 새로운 기술 나온다고 필요없는데
계속 이렇게 쓰시는 분들도 있거든요
웨디스도 나왔다고 해서 쓰고
근데 정말 필요한 곳 아니면은
안 쓰는 게 차라리 난 것 같아요
처음에는 나중에 그게 문제가 되면
점점 바꿔가면 되는 거지
어쨌든 원래 얘기로 돌아와서
그래서 어쨌든 액세스 토큰을 발행하는
방법도 그다지
이렇게 뭐
괜찮은 방법인데 역시 문제는 있었어요
그러다가 이제
제가 JWT 토큰을
보고 느낀 게 뭐냐면은
JWT 토큰은
토큰 정보가 그냥 JSON으로 만들어져 있어요
근데 이 JSON에 만들어서
이걸 또 이제 아까처럼
헤더 파일에 넣거나 이러거든요
그럼 그 JSON을 만든 다음에
그거를 뭐 base64로
인코딩하거나 이래갖고 그냥
인코딩을 해버려요 그러면 이걸
인코딩하는 순간 JSON이 나오니까
근데 재밌는 건 JWT에는
파트가 세 개가 있어요
JWT 안에는 파트가 세 개가 있어요
뭐냐면 헤더가 있고 이거는 뭐
이 JWT 토큰에 대한 정보죠
여기서 hash string은 뭘 쓸 거면
막 이런 것들
그리고 두 번째가 이제 payload라고 해서
실제 토큰 정보들
그리고 세 번째 파트가 이 첫 번째
두 번째를 합쳐갖고
hash를 돌린 값이에요
그러니까 hash를 전에 얘기했지만
보안 얘기하다가
똑같은 input이 들어오면 언제나 hash 값은
같아야 되거든요
그래서 이 세 가지를 만들어서 이거를
base64로 인크립트를 해갖고
처음 헤더를 base64 인크립트하고
닷 하나 찍고 두 번째 payload 부분을
또 base64로 인크립션하고
또 막 집어넣고
또 닷 하나 찍고 그 다음에 마지막에
원래 아까 hash 값 만들었던 거 있죠
그거를 마지막에 같이 넣어줘요
그럼 이게 재밌는 게 뭐냐
이 토큰 정보에는
이 JWT 토큰에는
그냥 아 이게 액세스 코디에만
주는 게 아니라 실제 그 안에
아 얘가 어떤 리소스에 대한
권한이 있는지까지 써있어요
그게 json인 이유가 그래요
그래서 payload 안에 이렇게 적혀있는 거죠
아 이거는 누구한테 발급된 거며
실제 누구한테 발급된 토큰이라는
정보도 있기 때문에
이게 OAuth를 넘어서서 이제
뭐지 openid 커넥터에서 쓰는
그런 토큰에도 쓸 수가 있는 거예요
제가 이름을 약간 헷갈리는데
제 생각에는 OAuth에 쓰는 게 authorization 토큰이고
제 생각에는 OAuth에 쓰는 게 authorization 토큰이고
그리고
openid 커넥터에서 추가로 추가한 게 아마 authentication 토큰일 거예요
그래서 하나는 리소스에
이제 접근 권한이 있다
그게 OAuth가 원래 주는 거고
openid 커넥터에서 추가한
또 다른 토큰은
아 이게 정말
이 토큰을 사용할 수 있는
정당한 사용자다라는 그런
identification까지 증명하는 부분이거든요
그래서 openid 커넥터가 그래서
OAuth+ 그 부분까지 해서
새로운 이제
약간 스펙으로 거듭나고 있는
이유기도 한데
어쨌든 여기에 누구한테 발급된지도 적혀있고
여기서 얘가 아 얘가 이메일
access 토큰으로는
이메일도 접근할 수 있고
유튜브도 접근할 수 있고 이런 게 다 적혀있는 거예요
유튜브도 접근할 수 있고 이런 게 다 적혀있는 거예요
그럼 우리가 생각하기엔 그렇잖아요
아니 이거를 json 파일로 가지고 있고
base64 encryption한 게 전부인데
이걸 니 헤더에 들고 있으면
니가 디크립트 한 다음에 여기다
유저가 주지 않았던 권한을
마구 추가해서 다시
디크립트해서 보내면은 서버에서는 그냥
어? 이 권한 있네? 그리고 주는 거냐
말이 안 되지 않냐라는 얘기를 해요
근데 그게 아니에요
저 마지막 파트가
이거를 뭐랄까
어떻게 얘기해야 될까
증명하는 그런 조건을 하는 거예요
아까 마지막에 그랬잖아요
첫 번째 꺼와 두 번째 json을 가져다가
아 인크립트를 하면은
그러니까 뭐 해쉬를 만들거나 뭐 해갖고
마지막에 만들어낸 스트링이라는 거
근데 그 해쉬에 쓰는 이제 키는
서버 쪽에서만 가지고 있는 거예요
왜냐면은 서버에서 처음에 만들어갖고
보내줬으니까
이걸 키를 하나를 쓰기 싫으면
퍼블릭하고 프라이빗 키를 쓰는 법도 있지만
뭐 그건 중요한 건 아니고
그래서 만약에 내가 이거를 서버에서 로그인해서
가져왔어 jwd 토큰을
그러고 봐서 아 중간에 페이로드를
내 마음대로 바꾼 거예요
아 나는 이제 이 유저한테 막 딜리트까지 할 수 있는
권한까지 내가 훔쳐와야지 이러고
딜리트 집어넣고
토큰을 넣어서 보내면 서버에서
그 처음 두 파트를 가지고 다시 한번
해쉬를 만들어 보는 거예요 그래서 그 해쉬가
파트하고 다르면 아 이거 조작된 토큰이구나
그래서 어 권한이 없음을
그냥 돌려줘 버리는 거예요
그래서 이거는 되게 재밌는 게 뭐냐면
예전에는
이런 모든 권한이 어디까지 있고 이런 걸
서버에 저장해 놓고 야 토큰 뭐네
내가 판단해서 db 긁어서
판단해서 아니면 리젝트할게
라고 하는 순간 db를 긁어야 되는 문제가 있었는데
jwd 토큰을
쓰면은
그러니까 jwd 토큰을
액세스 토큰으로 쓰는 게 아직 일반적인 건 아니에요
근데 제가 그냥 생각하는
시스템을 하다가
찾아서 딴 데서 한 군데서 그걸 하고 있는 걸 발견한 거죠
그래서
이게 아마 jwt io인가
그런 웹사이트에서 얘기를 할 거예요
그래서 다시 얘기를 돌아가면
그렇게 해서 이제
토큰을 받은 다음에
이 토큰을 제가 이제 나중에 다른
이메일에 접근할 때 토큰을 같이 보내주는 거예요
authorization 토큰으로
이제 헤더에 그럼 서버에서 받아요
서버에서 첫 번째 두 번째를
뜯은 다음에 이제
해쉬 인크립션을 해봐요 그리고 세 번째랑
같은지 확인해 어 갔네
유저된 거 아니네 이 토큰 익스파이어되어도
지금까지 아직 괜찮네 그러면 오케이
그리고 접근을 허용해 주는 거예요
그러니까 접근 권한이 있음 없음을
db에 저장해 두는 게 아니라
json 파일에 저장해 두되
뭐라 그러지 이거 암호화 기법이라 그러죠
암호화 알고리즘에 의존해서
이 토큰이 변했는지 안 변했는지를
판단하는 방법이죠 물론
이제 암호화를 깰 수 있는
기술이 발전하고
그러면은 이거를 다 암호화를 깬 다음에
키를 찾아낸 다음에 그거에 맞는
이제 인크립션을 해서 보내는 법도 있을 거예요
분명히 그쵸?
그래서 이제
언젠가는 깨질 수 있는 기법이기도 한데
중요한 거는 이제 jwt 토큰을
이제 액세스 토큰을 쓰는 사람들은
접근 시간을 되게 짧게
만드는 경우가 흔해요 왜냐하면은
이제 그런 인크립션 키 같은 게
이제 뭐 256비트까지 가면은
아무리 컴퓨터가 빨라도
뭐 깰 수 있는데 걸리는 시간이 있거든요
아 그래서
어떤 경우는 만약에 5분 6분으로 하는 경우도 있고
뭐 길어도 60분 미만이면
60분일 거 같은데
그래서 차라리
이게 깨지더라도
문제가 없게끔
없게끔
오히려 그 뭐라 그럴까
아 그
시간
라이브 시간?
뭐라 그러지 타임 투 리브 아닌데
익스파이어 데이
익스파이어 데이 시간을 짧게 주는 거죠
그래서 그냥 보면서
이거의 장점은 뭐냐면
일단 여러 대를 띄웠잖아요
뭐 만 대를 띄웠든 천만 대를 띄웠든
그래서 우리가 그 서버 리소스 서버를 다 히트할 때
이 서버에서 이 사람이 과연 올바른 권한이 있냐 없냐를 판단할 때
DB를 히트하지 않아도 되기 때문에
사실 더 이상의 보틀렉이 존재하지가 않아요
그래서 어찌보면 리소스 풀
을 하는 경우에서는
굉장히 괜찮은 아이디어처럼 생각이 들었어요
아 이렇게만 된다면
일단 최소한 DB 히트하거나
아니면 뭐 액세스 관리 있는 거
확인을 그냥 CPU 상에서만 해결이 되니까
오히려 더 안전하겠구나
그 생각을 많이 했던 거죠
그래서 실제 아까 말한 것처럼
뒤지다 보니까
JWTIO라는 웹사이트를 가보면
걔네들이 이제
모든 액세스 토큰에 이렇게 쓰고 있더라고요
그래서 아 맞구나
거기 읽으면서 많은 걸 배웠고
그러니까 이제
액세스 토큰을 이제
발급해야 되는 그런 위치에 있는 서비스 중에서
아주 심각하지 않은 서비스들이 있잖아요
은행이나 이런 건 좀
약간 애매하기도 한데
그런 게 아닌 서비스들은
음...
이렇게 쓰면 되지 않을까 생각이 돼요
근데 어차피 은행
이런데도 막
오어스 토큰 쓰고 시작하면은 어차피
뭐 중간에 오어스 토큰 훔친 다음에
60분 안에 쓰는 이런 문제도 있긴 하지만
뭐 뭐든 간에 그렇게 심각한
서비스가 아니으면은
제가 볼 때는 JWT로 가는 게
서버 부하를 줄이는데
도움이 되지 않을까
나중에 그냥 스케일 러비티로 올라가
확장을 하는데도 좋지 않을까 생각이 들고
그럼 이제 한 가지 질문이 있어요
그래서 만약에 얘가 깨지면 어떡하냐
정말 깨졌을 땐 어떡하냐
그럼 그때는
이제 블랙리스트를 만드는 법이 있을 것 같아요
지금까지는 액세스 토큰이
모든 게 화이트 리스트였잖아요
서버에 접속하면은 내가 액세스 토큰을 만들어주고
난 서버에 저장을 해놓은 다음에
넌 이거에 매치할 때만 내가 허락해 줄 거야
라고 했는데
지금은 그냥 서버를 그냥
액세스 토큰을 주고 만약에 얘가
중간에 뭔가 문제가 생겼다는 걸 판단이 된다면
그 순간에 블랙리스트를
올리면 되지 않을까 싶어요
DB에 블랙리스트를 올려놓고
이제 뭐라 그럴까
이제 다음에 리퀘스트가
올 때마다 이게 블랙리스트 테이블에
있냐 없냐 확인하면 되는 거죠 사실 그 시간 동안
그러면 일단은
DB 테이블에 들어가는 토큰 수도
굉장히 적으니까 실제
현재 존재하는
살아있는 토큰 중에서 뭐 블랙리스트 들어갈 게
솔직히 얼마나 되겠어요 한 1%? 2%?
그러면 그게 이제
예전에 화이트 리스트 하는 것보다는 한
100분의 1로 주는 거죠
그런 방식으로도 충분히
지금 하고 있는
액세스 토큰의 방식을 그대로 흉내낼 수 있지 않을까
생각이 들어요
그래서 그 정도면 이제 제가
JWT에서 봤던 게 충분한 것 같고
그냥
뭐라 그럴까
엔지니어로서 굉장히
재밌는 토큰이다
암호화 기법에 의존해서 토큰에
밸리데이티를
밸리데이티를
토큰의 유효함을 아님을 증명하고
옛날에 서버에다 의존했던 거
그런 거를 그렇게 했고
아
점점
스케일러비티를 신경 쓰는 요즘 세상에서
좀 더 도움이 되는
토큰인다라는 생각을 했어요
저도 가능하면 이걸 점점 쓰고 싶다는 생각을 많이 하고
음
아직 뭐 제가
오픈 아이디 커넥트 서버로 완성을 안 시켰기 때문에
확실히
결과는 어떻게 될지 모르겠어요
그래서 그냥 액세스 토큰 같은 거 만드는
분들 계시면 한번쯤 이런 방법도
생각해 봤으면 좋겠다는
거에서 비디오를 만들었어요 그냥
음
오늘도 유익한 웹 개발
자료 포프티미는
네 여기서 끊죠 포프였습니다
