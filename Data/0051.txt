네 안녕하세요, 포프입니다.
오늘 이야기해 볼 거는 C#에 대해서 한 번 더 이야기해보려 해요.

사실, 얼마 전에는 그냥 뭐 하다 든 생각인지는 모르겠는데… 뭐 하다가 든 생각인지는 말할 수 없을 것 같고요. 기업 비밀이 좀 있기 때문에. 제 기업 말고 다른 기업, 얼마 전에 그런 생각이 한번 들었어요.
“C#이 C++보다 더 빨라질 수 있겠구나.” 라는 생각을.

일단 몇 가지 잘못 생각하시는 것들에 대해 이야기 좀 할게요. 흔히들 생각하시는 것이, C#이 C++에 비해 너무 느리다? 그렇진 않아요. 느리긴 느려요, 현재로선. 아무래도 C++처럼 이렇게 직접적으로 하드웨어나 메모리 주소를 접근하거나, 메모리 관리를 직접하거나 그런 게 아니기 때문에 당연히 C++가 C#보다 빨라요, 현재로는. 근데 그것도 당연히 어떻게 짜느냐 나름이겠지만요.

근데 뭐, C++는 당연히 여러 가지 위험이 존재하죠. 메모리를 잘못 건들면 메모리 릭도 생길 수 있고, 뭐 이것저것 할 수도 있고. 근데 C#도 Virtual Machine 때문에 메모리 릭이 여전히 생길 수 있다, 이런 이야기도 있는데… 뭐, C++로 난리 칠 수 있는 것보다 C#으로 난리 칠 수 있는 것이 훨씬 적기 때문에 여전히 C++가 위험성이 더 많죠.

그리고 C#은 아무래도 개발 속도도 빠르고, 개발 툴도 C++보다 좀 더 낫고요. 그 이유는 사실 RTTI, Runtime Type Information 때문인데, 그거 덕분에 IDE에서 지원할 수 있는 여러 가지 도구가 많은 거죠.

뭐, 뭐든 간에… 느리긴 느려요. 근데 제가 얼마 전에, 작년인가, 한 리서치 작업 중에 복셀 에디팅이 있었거든요. 복셀로 에디팅하는 걸 했었는데, 저 C#으로 발랐거든요? C#하고 이제 DirectX 내부적으로 해서 SharpDX인가, SlimDX인가… SharpDX였던 것 같아요. 그걸로 프로토타입을 하나 만든 게 있는데, 마인크래프트 큐브나 이런 거 엄청나게 했었는데도 불구하고 속도가 그렇게 느리지 않았어요.

물론 C#에서는 Parallel for가 자동적으로 지원이 되기 때문에 CPU도 거의 90%, 100% 이용할 수 있는 장점도 있고, 굉장히 프로토타입 한 것도 빨랐고. 개인적인 생각으로는 물론 C++로 갔으면 최소 10%, 많으면 20% 정도까지도 속도 향상이 있을 수 있었을 텐데, 그래도 C#이 그렇게 느리지 않았고 충분히 쓸 만한 정도였어요. 심지어 툴을 다 이걸로 만들어도 되겠구나, 그 생각까지 했으니까요.

근데 현재 C++가 빠른 이유가 역시 기계어로 컴파일이 된다는 거잖아요. 언어 자체도 기계어로 곧바로 컴파일하기 좋은 언어고. 타깃 플랫폼용 최종 instruction set, CPU에서 지원하는 move, add, multiply, right shift, left shift 이런 거부터 시작해서, 벡터 유닛이 있으면 float 타입 하나하나 계산할 것을 float 4개를 한 번에 써서 계산하는 SIMD 같은 것도 있고. 그런 걸로 컴파일이 되니까 빠른 거예요.

근데 여기에 문제점이 새로 나온 게 뭐냐면… 제가 최근에 생각하게 된 건데, PC용 게임 만드시는 분들은 알겠지만, Visual Studio 안에 instruction set을 어떤 걸 지원할 건지 고를 수 있는 옵션이 있어요. SSE1, SSE2, 그다음 SSE3, SSE4… 이런 것들. 그리고 또 뭐 AVX 같은 것도 있고요.

사실 인텔 쪽에서 계속 새로운 instruction set을 리서치하면서 발전시키는 거거든요. 그러면 AMD도 자기네 규격이 있다가도, 인텔 CPU가 워낙 dominant(지배적) 하니까 따라가야 해요. 근데 AMD는 항상 약간씩 뒤처져 있고. 그래서 인텔은 계속 새로운 걸 만들어 나가고 있죠.

그럼 인텔의 새로운 instruction set 용으로 컴파일을 해보자라고 생각을 하면, 컴파일러 옵션을 고쳐야 되잖아요. 그럼 기계어를 뱉어내줘요. 근데 문제는 이걸 AMD나 오래된 CPU에서 돌리면 안 돌아요. 그래서 C++의 문제는, 그러면 어떻게 할 거냐? EXE 파일을 플랫폼마다 만들어줄 거냐? 근데 그러는 사람은 거의 없죠. 왜냐하면 EXE 파일을 새로 만들 때마다 QA 새로 해줘야 되고, 테스트 새로 해줘야 되고, 이래저래 비용이 높아지니까 안 해요.

보통은 가장 낮은 instruction set을 골라요. 지금 현재 웬만한 CPU는 SSE1, SSE2는 다 지원할 거예요. 그래서 SSE2 정도로 맞춰놓고 컴파일해서 배포해요. 그러면 고성능 CPU를 충분히 못 살리는 거죠. 실제로는 벡터라이제이션만 잘해도 20~30% 성능 향상은 충분히 있어요.

근데 이걸 C++ 쪽에서 해결하기가 쉽지 않아요. EXE 파일을 여러 개 만들어서 실행할 때 분기 처리하는 것도 애매하고, EXE 크기도 커지고. 그래서 아직은 쉬운 해결 방법이 없어요. 물론 움직임은 있지만, 그건 컴파일러 제작사와 CPU 제작사가 같이 해결해야 할 문제죠.

근데 C#으로 가면 그게 훨씬 간단해져요. 왜냐하면 C#은 컴파일 언어가 아니라 Intermediate Language로 바꿔놓고, 실제 실행 시점에 JIT 컴파일을 하잖아요. 그러면 실행하는 동안 플랫폼을 확인해서, “아, 여기선 SSE4를 지원하네? 그럼 이 float 계산을 묶어서 SIMD로 돌려야지.” 하고 바로바로 최적화를 할 수 있는 거예요. 실행 시점에 고성능 하드웨어의 효과를 즉시 이용할 수 있는 거죠.

물론 이게 쉽지는 않아요. 벡터라이제이션 같은 건 코드 전체 분석이 필요하니까요. 배열의 의존성 문제도 있고. 그래서 C++ 컴파일러가 오래 걸리는 이유도 그런 분석을 하기 때문이죠. 그래서 아직은 C#에서 완전히 하기엔 무리가 있겠다 싶지만… 모르죠. CPU 벡터라이제이션이 미친 듯이 올라가면, 간단한 알고리즘만 돌려도 C# 성능이 C++에 가까워질 수도 있겠다. 어쩌면 더 빨라질 수도 있겠다.

그건 좀 먼 미래 같지만, 컴퓨터 업계에서 5년, 10년이면 금방이니까요. C#뿐만 아니라 Java도 마찬가지고요. 마이크로소프트만큼 컴파일러를 잘 만들 수 있는 회사는 몇 안 되니까, 그냥 편의상 C#이라고 말하는 거예요.

그래도 여전히 문제는 있죠. 가비지 컬렉터. 이건 아직도 남아 있고요. 그 얘기는 다음 기회에 또 하기로 하고요.

오늘 하고 싶었던 말은, “C#이 빨라질 수도 있겠다.” 라는 거예요. 웬만하면 써보세요. 굉장히 좋아요. 저는 5년 안에 모든 게임을 C#으로 만들 수 있다고 생각해요. 물론 가비지 컬렉터만 잘 해결된다면요.

오늘은 그 정도고요. 다음엔 또 다른 주제로 찾아뵙지요. 할 말은 많아요, 아직도.
예, 포프였습니다.
