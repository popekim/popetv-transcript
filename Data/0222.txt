얼마전에 생방송을 할 때 제가 머신러닝의 기초 개념에 대한 얘기를 했었잖아요
거기서 나왔던 질문 중에 라이브 챗에서 어떤 분이 visc에 대해서
어떻게 생각하냐고 물어보셨는데 제가 처음 한 말 visc가 뭔지도 몰라요
visc를 쳐봤어요 벤쿠버 아일랜드 무슨 스쿠터 커뮤니티 이거 아닐
텐데 visc cpu라고 쳐보래요 그래서 visc cpu라고 쳤는데 제가 라이브
로 하는 도중에 읽을 시간이 많지 않잖아요 그래서 한 1~2분 읽어보고
이거 제가 볼 때는 이미 cpu 아키텍처 중에 있는 아웃 오브 오더 익스큐션
이라고 있는 게 있는데 그거랑 별로 다를 것 같지는 않은데 그거보다
이게 가지는 메리트가 뭐죠 그리고 넘어갔어요 그래서 이제 그분이
나중에 읽어보게 되고 좀 자세히 비디오로 만들어달라고 말씀을 하셨
거든요 제가 그럴 일은 없을 것 같아요 라고 말을 했는데 읽었는데
.
어 재밌어 그래서 비디오를 만드는 거예요 그분 제가 이름은 까먹었는데
이건 말해줘서 정말 고마워요 일단 visc를 말하기 전에 현재 cpu 아키텍처
부터 말할게요 뭐 예전 엑스박스 360에서 썼던 파워 pc 이런 좀 구
cpu 말고 인텔 같은 cpu 좀 오히려 잘 나가는 cpu 회사 amd도 똑같아요
그런 회사 보면 cpu에서 되게 재밌는 게 뭐냐면 어셈블리 레벨까지 내려
가면 모든 명령어가 있어요 뭐 a를 b에 옮겨라 a와 b를 더해라 a와
b를 빼라 이런 명령어들 그리고 각 명령어 하나하나가 실제 cpu가
er 쓴 명령어랑 1:1로 대입이 되고요 그 명령어 하나마다 이제 보통
우리는 alu라고 하거든요 그러니까 뭐 산술 처리 유닛 산술 처리 장치
그래 그런 게 있는데 결국 거기서 그걸 하는 거예요 a하고 b를 더하는
거 a에 b에 옮기는 거 이런 것들 근데 이게 연산 따라 그 사이클이 들어가요
그러니까 cpu가 몇 번 생각 틱틱틱 하고 cpu가 덜 들어가요 cpu가 몇 번

돌거든요 그 cpu가 도는 사이클이 이거는 세 번 사이클이 걸리고
이거는 다섯 번 사이클이 걸리고 이거는 열 번 사이클이 걸리고 이런
게 있어요 그리고 그걸 또 외에도 a와 b를 더한 다음에 c에 넣고 c와
d를 더하면 c 값이 나올 때까지 기다려야 되잖아요 그러면 사이클이 갈 때까지
cpu는 아무 짓도 안 하고 멈춰요 다음 연산을 처리 못 하고 그래서
그런 거를 이제 해결하기 위해 이런 cpu 연산들이 이렇게 순서가 있을
때 cpu 자체 내부에서 기계예요 기계에서
기계에서 분석을 하는 거예요 여기 뭐 명령어 10개 있고 10개가 있는데
이 서로 간에 서로 참조하는 게 없어 그러면 이 처음 명령어 처음 10개
있는 명령어 중에 몇 개를 실행하다 딱 멈춰 있을 때 이 다음 명령어를
곧바로 놓아서 실행을 시켜요 그걸 이제 out of order execution이라고 해요
o 라고 하는데 그러니까 순서대로 명령어를 쭉 실행하는 게 아니라
순서를 바꿔서 서로 이게 뭐라고 하죠 dependency가 없으면 순서를 바꿔서
딴 거를 기다리는 동안에 실행을 시켜준다는 게 o의 개념이에요 xbox
360엔 그게 없었어요 그래서 그래서 좀 느렸고요 cpu가
인텔 측엔 주로 있어요 그래서 아마 다 있을 거예요 지금은 그래서 그런
게 이제 cpu 자체에서 최적화로 나오는 거예요 기계 쪽에서
그래서 문제는 이게 아까랑 cpu라 했잖아요 cpu 하나가 cpu의 코어가 뭐
4개 8개 달려 있잖아요 4개면은 각 cpu가 그 일을 하는 거예요 그래서 cpu
하나의 프로그램이 될 때 다른 코어는 놀고 있더라도
이거를 보내지 못하는 거야 그래서 같은 cpu에 어차피 병목이 있고 다른 건
놀 수가 있다 이걸 고친 게 fisk예요 그래서 fisk의 개념은 뭐냐면 약간
소프트웨어 레이어드 있고 하드웨어 레이어드 있는데 가장 간단하게 말하면 이거예요
프로그램을 딱 돌려요 그러면 이 프로그램이 곧바로 이 코어 0번에서
실행되는 게 아니라 실행이 되는데 뭐 일단 뭐 앞에 10개 얘기한 거
있잖아요 그럼 위에 5개를 코어 0번에서 실행을 하다가 다음 거 이게 스톨이 되고 있는데 다음 거가
스톨이 되고 있는데 다음 거를 돌릴 수가 있어 독자적으로 그러면 이거를 다른 cpu에 주겠다는 거예요
그러니까 한마디로 아 인스트럭션 단위의
음 잡 시스템이라고 하죠 그게 맞는 것 같아요 그렇게 보면 그럼 이제 얘네가 말하는 것의 장점은 뭐냐면
그러면은 cpu가 이제 여러 개로 분산이 되기 때문에 오히려 속도가 빨라진다 맞는 얘기예요 그래서 이게 지금은 cpu 아키텍처로 나와있고 이 아키텍처가
이 아키텍처를 만든 회사 이름을 제가 지금 까먹었는데 어디 적어놓은 게 있을 거야
그래서 지금 이게 스타트업의 회사고 음 잠깐만요
안 적어놨나 안 적어놨네 그래서 결과적으로 얘네가 하려는 게 뭐냐면 아키텍처를 만들었고 이 아키텍처를 이제 라이선싱을 주겠다는 거예요
arm 회사가 그렇듯이 그래서 amd 에서 투자를 했고 삼성에서 투자를 했다고 알고 있고 자기네 갖다 쓰려는 거죠 근데 인텔은 투자를 안했어요
제가 볼 때 인텔은 비슷한 걸 들고 나올 거에요 이 정도의 개념이면 못 들고 나올 리가 없어요 그래서 이거의 개념은 한마디로 모든 cpu 코어를 하나로 보자
근데 하나로 볼 수 있는 방법이 두 가지 방법이 있겠죠 첫 번째는 기존에 존재하는 그런 소프트웨어라면은
out of order instruction 하는 것처럼 분산을 시키고 근데 소프트웨어 레이어가 있기 때문에 그 분산하는 것은 조금 느릴 수도 있는데 결국에는 남아있는 ALU라던가 사이클이 더 많기 때문에 그게 더 빨라진다는 얘기고요.
두 번째는 자체 컴파일러 그건 이미 있는 거 같아요 그래서 프로그램을 이제 컴파일 할 때 보통은 뭐 인텔 x86용으로 x64용으로 컴파일을 하잖아요
그걸 떠나서 이제 얘네 비스크 용으로 컴파일하는 컴파일러 나오겠죠 그러면 그 아까 말한 그 디스트리뷰션 이런 소프트웨어 버추얼 하드웨어 이거 있잖아요
그 그 레이어를 좀 덜 쓸 수 있겠죠 알아서 분산을 시켜주고 중간에 배리어 걸어주고 잡을 수 있겠죠.
그 레이어를 좀 덜 쓸 수 있겠죠 알아서 분산을 시켜주고 중간에 배리어 걸어주고 잡을 수 있겠죠.

그런 면에서는 이게 분명히 메리트가 있는데 여기서 두 가지 주의해야 될 게 있어요. 두 가지.
아 그 전에 이 얘기부터 하죠. 제가 옛날에 언제나 그 얘기를 했어요.
세상이 완벽했다면 프로그래머는 절대 멀티스레딩을 할 이유가 없다라고.
그 이유가 뭐냐면 정확히 멀티코어를 쓸 이유가 없다는 얘기인데
이제 멀티코어 쓰고 멀티스레딩 하다 보면은 이 레이스 컨디션이 있잖아요.
막 스레드 0에서 변수 A 고친데 스레드 B에서 변수 A 고치면 누가 먼저 덮었느냐에 따라 달라는 이런 것들.
그런 현상이 없기 위해서는 그냥 싱글코어로 가면서 모든 거를 이제 순서대로 시간을 쉬어가는 거죠.
너는 이만큼 시간을 쉬어서 너 실행하고 동시에 실행되는 건 없어요.
이 다음에 네가 실행되고 다음에 네가 실행되고 이렇게 하는데 시간을 잘게 잘게 잘게 쪼개면 멀티스레딩 같아 보이니까.
그게 자바스크립트가 도는.
그 원리이기도 하죠.
그래서 저는 그렇게 되는 게 맞다고 하는데 그게 안 된 이유는
하드웨어의 발전이 불가능하니까.
더 이상 CPU 클럭을 높이는 게 불가능하잖아요.
물리적인 원리 때문에.
그래서 저는 과학에서 얘기하는 물리적인 한계점에 맞고
그 다음부터 코어를 던지면서 사람들이 싱글트로이드로 코딩을 짜놓은 습관을 멀티트로이드로 바꿔야 되는데
그래서 그 잠깐은 좀 힘든 기간이 있었고
저는 언제나 얘기했거든요.
그거는 세상이 완벽했다면 멀티트로이딩은 절대 필요가 없다.
근데 이 비스크라는 게 그거를 갖다 줄 수 있는 거긴 해요.
비스크가 들어오면 그런 코어간에 프로그래밍 분리는 비스크 레이어가 해주는 거기 때문에 하드웨어에서
프로그래머는 제일 신경 쓸 게 없는 거예요.
그냥 모든 걸 싱글트로이드로 짜버리면 되는 거예요.
싱글트로이드란 말이 좀 웃긴데 싱글코어로 짜고
스레드는 여러 개 나올 수도 있어요.
근데 동시에 실행만 안 되면 되는 거예요. 사실.
뭐 결국 타임쉐어링이죠.
그래서 뭐 그렇게만 되면 되는 거고
OS에서 아예 뭐라 그럴까
레이스 컨디션이 안 나게 막아줄 수가 있는 거죠.
어떤 의미에서 모든 거를 리젝션으로 실행해 주고
코어 하나에서만 실행하고
이거를 분리해 주는 게 전부니까
코어 하나에서만 실행하게 되면 되는 거예요.
그런데 여기서 주의해야 될 게 뭐냐면
아까 두 가지 있다고 그랬죠.
첫 번째는 아 그럼 비스크에 싱글코어 프로그램을 집어넣으면 빨라지겠구나.
아 그럼 비스크에 싱글코어 프로그램을 집어넣으면 빨라지겠구나.
아 그럼 비스크에 싱글코어 프로그램을 집어넣으면 빨라지겠구나.

왜냐면 이미 싱글코어 프로그램은
이미 싱글코어에 최적화 돼서 나왔어요.
싱글코어에 돌렸는데 엄청 느린데
그걸 싱글코어에 돌리는 프로그램이 적다고 보거든요.
그래서 그거를 단지 비스크에 넣는다고 해서 빨라지진 않을 것 같아요.
물론 가끔 정말 엄청나게 느린 것도 몇 번 봤어요.
그런 건 빨라지겠지만 일반적으로 게임 같은 경우는
이미 싱글코어에 나왔다면
싱글코어에 잘 도니까 나온 거예요.
그런 게 아니라 뭐
가끔 포토샵이나 이런 거 싱글코어에서 막 엄청 속도를 늘리고
그런 거는 빨라질 수 있겠죠.
뭐 Visual Studio 링크도 그렇고.
그 정도.
두 번째.
과연 비스크를 쓰면 멀티스레딩 하는 것보다 빠를까?
인텍스에서.
아니라고 봐요.
이게 재밌는 게 뭐냐면
제가 좀 전에 프로그래머는 완벽한 세상에서는
절대 멀티스레딩 코드를 짤 필요가 없다고 그랬죠.
근데 이건 완벽한 세상이 아니에요.
누군가가 이 밑에서 저희가 할 일을 대신해 준 것 뿐이에요.
누군가가 이 밑에서 저희가 할 일을 대신해 준 것 뿐이에요.
근데 중요한 거는
이게 절대 저희가 직접 코어 수가 몇 개인지 봐서
그 코어에 딱 맞춰갖고
매뉴얼하게 코딩을 하는 것보다
성능은 느리게 나올 수밖에 없어요.
왜냐하면 이거는 보다 범용적인 시스템이고
자기가 이제 실행 중에 막 알아내야 하고
막 이렇게 찾아야 되는 건데
저희가 직접 짜면은 저희는 미리 코드를 하잖아요.
스레드 4개 있으니까 4개에 분리해서
4개면 이렇게 잡 시스템 만들고 돌린다 이런 식으로.
그래서 빨라질 수 없는데
이거를 어떤 개념으로 봐야 되냐면
생산성.
실제 프로그래머가 멀티스레딩을 직접 손으로 짜고
카드웨어가 어떤 건지 고민할 게 적다면
코드를 대충 싱글스레드로 짜버린 다음에
CPU가 이거를
디스크 CPU가 알아서 처리하게 만들어 주면
그리고 이게 충분히 빠르다면
그렇게 느리지 않다면
그게 왜 최적화를 더 신경 쓸 이유는 없잖아요.
그럼 그 순간에서
아 옛날에는 이 단순한 거 하기 위해서
이 엄청난 멀티스레딩 해야 됐는데
지금은 안 해도 돼.
이런 개념으로 갈 수가 있는 거죠.
그러면 생산성이라는 측면에서는 좋은 거죠.
그래서 그거는 무시할 수는 없을 것 같고
그리고 과연 비스크에서 그렇게 내가 직접
매뉴얼하게 멀티스레딩 멀티콜을 쓸 수 있는
기능을 줄지는 모르겠어요.
주면 좋겠죠?
근데 그건 잘 모르겠어요.
그래서 그 정도고
그래서 성능은 절대
인텔 최체보다 빠를 수 없다고 봐요.
당장으로는.
뭐 나중에도 그럴 것 같고
그냥 막자도 상관이 없는 그런 CPU가 있다면

그렇게 좀 나온다는 건데
또 이제 뭐라고 그럴까
그래서 제가 잠깐 찾아봤어요.
별로 오래 보지는 않았고
지금 몇 시간 본 건 아니고
잠깐 찾아봤는데
그래서 절대 성능이 빠를 수가 없는데
이러면서 봤는데
결과적으로 얘네가 프리젠테이션 한 게 있잖아요.
거기서 나오는 거는
성능이 진해가 빠르다고 나오는데
그 기준이 절대 성능이 아니라요.
와트 소모당 전력소모당 성능이 빨라요.
그러니까 이질로 말해서는요.
뭐라 그러나 똑같이 파워를 쓸 수 있는 최고 파워를 쓰면서 돌리면
제가 볼 때 인텔이 빠를 것 같고 똑같이 만약에 1와트를 쓴다 1와트
를 쓸 때 과연 어떤 cpu가 더 빠르 냐 그랬을 때는 비스크가 빠르게
나와요 퍼포먼스 벤치마크로는 근데 그건 자체 벤치마크고 자체
칩도 없죠 그래서 그래도 저는 그게 당연하다고 보고 그래서 왜 당연
하냐면 멀티코어 cpu가 들어가는데 코어 하나에만 전력 넣고 하나에
만 다른 거에 전력을 별개로 조절 한다는 게 좀 애매하잖아요 사실은
그렇게 효율적인 것 같지도 않고 그래서 코어가 하나가 만땅히 돌아
도 다른 코어도 적당히 돌고 있다고 보거든요 와트가 그래서 거기에
낭비하는 게 있는 걸 비스크는 어차피 다 분산되는 거니까 웬만
하면 비슷하게 와트를 전부 다 분산 을 시키면 모든 거가 100% 거의 활용
되고 있다고 보기 때문에 그것 때문에 빠르다는 얘기죠 그것 때문에 전력
소모가 적다는 얘기죠 그래서 지금 amd나
amd는 전력 소모가 적다는 얘기죠 그래서 지금 amd나 amd는 전력 소모가
적다는 얘기죠 그래서 지금 amd는 이제 인텔에 워낙 밀리고 있기 때문에
어떻게든 들어가고 있는 것 같고 삼성이 거기에 지금 돈을 투자한
이유는 제가 볼 때는 모바일 쪽 cpu에 관심이 있을 것 같긴 해요
그래서 그런 것 같고 이 비스크 란 시스템이 설사 범용화되고 누구나
쓰는 시스템이 되더라도 제가 볼 때는 당연히 인텔 쪽에서도 뭔가
비슷한 걸 만들 테니까 이런 방법이 다음 세대가 갈 방법이라고 생각
은 해요 최소한 5555에서 지네가 자동 분산하는 것만큼이라도 그렇게
되더라고 해도 이게 모든 cpu를 교체하는데 걸리는 시간은 한 10년 더 걸릴 수도 있고 10년이 걸린다고 보죠 10년 동안은 비스크용으로만 코드를 못 짜요
싱글스레디로 우리가 코드를 못 짜거든 그럼 과연 우리는 어떻게 해야 되느냐 아직까지도 멀티드레이딩 따로 팔거냐
그럼 나중에 또 트랜지션 할 때 또 괴롭잖아요 그래서 제가 생각하는 가장 좋은 방법은
제가 예전에 한번 말한 것 같은데 이제 c 샵을 쓰시는 분이면 패럴럴 4 그니까 배리어 시스템이죠 그니까
c 샵을 쓰시는 분이면 패럴럴 4 그니까 배리어 시스템이죠 그니까
잡큐 만들어 놓고 모든 스레드가 4개 면 스레드 4개 용으로 리스트를 만들어 놔 잡리스트를 그리고 쫙 돌린 다음에 끝날 때까지 기다리는 거
그거로 가면요 그게 잘 알 것 같아요 왜냐하면 그게 cpu가 하나면은 그건
q를 하나로 뽑아 주거든요 cpu가 4개면 4개로 뽑아주고 그리고 이제 c++ 17에도 그게 들어와요 이제
그래서 그런 개념 배리어 시스템 잡 시스템 태스크 시스템 그거죠 그걸로 가면요
그걸로 가면요
regarding option
a
a
d
d
d
d
d
d
d
에서는 10년동안 그러면 하이브리드 로 내부에서 내가 하는게 아니라
돌다가 모든게 비스크로 넘어가면 그때는 그거를 걷고 싱글스레드
로 바꿔도 그때 바꾸면 되니까 아니면 안 바꿔도 성능은 똑같을
테니까 거의 그래서 그게 맞는 거 같고 제가 생각하는 비스크는 굉장히
좋은 아이디어고 미래는 이렇게 갈 거 같고 비스크의 승자가 누가
될지는 저는 감히 예측할 수 없어요 전력으로 봤을 때는 뭐 arm이라던가
이런 회사가 당연히 잘 갔고 순수한 성능만으로 봤을 땐 저는 인텔이
결국엔 훨씬 나아질 거라고 봐요 제가 나중에 언젠가 만들 비디오
지만 저는 테크 회사를 볼 때 큰 회사를 볼 때 주로 리서치 파워로
보거든요 인텔만의 리서치 파워로 갇힌 회사가 별로 없어요 사실은
그래서 amd도 처음에 막 나왔을 때 막 뜨고 엄청 인기가 많았지만
하드웨어 엔지니어들이 amd하고 인텔 집사의 디자인 보면은 그때부터
예측을 했거든요 한 15년 전부터 10년전인가 10년전 10년전부터 예측
을 했어요 제가 아는 하드웨어 엔지니어가 amd 하드웨어 엔지니어들이 딱 한거
보고 디자인 보고 한 10년전부터 예측을 했어요 제가 아는 하드웨어 엔지니어가
보고 이 p는 필요가 없는 건데 왜 만들었지 이런 건 왜 했지라고
보고 인텔 거 보더니 음 필요 없는 게 없군 인텔이 결국엔 이길 거야
라고 했거든요 저한테 그런 개념 에서 인텔은 이 새로운 아이디어
가 당연히 뭐 특허가 걸려있겠지만 비슷한 다른 아이디어를 찾아가
고 이거를 더 낮게 발전시킬 거 같아요 그래서 두 가지 이 패러다임
은 결국엔 존재할 거 같고 그건 좋은 아이디어고 미래는 일로 갈 거라고
봐요 일단은 근데 누가 승자가 될 지는 가늠하기
어려운데요.
근데 저는 성능상으로는 인텔 전력 상으로는 애매하다 현재 이 정도
고 프로그래밍 하는 자세는 아까 말씀드렸죠 이거에 준비가 되는
프로그래밍을 하려면 가능하면 패럴럴4 잡시스템 테스크 시스템 베리어
락 이걸로 주로 가시길 바라고 그 정도면은 제가 비스크를 잠깐 보고
나서 제가 여태까지 믿고 왔던 가치관 제가 뭐 이렇게 주장했던 거랑 맞는
부분 이렇게 합쳐갖고 생각하는 게 그 정도예요 저는 당연히 이
게 완벽히 메인스트림 될 때까지 는 이거 전문용으로 코딩은 안
짤 거 같아요 아니면 제가 그렇게 해야 될 일이 있지 않는 이상 돈
받으면서 그래서 그 정도고 저는 패럴럴4를 그냥 쓸 거예요
포프였습니다
