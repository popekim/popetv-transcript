음.. 저번에 이어 요번에도 프로그래밍 얘기를 좀 하려구요
음.. 요즘 프로.. 제가 프로그래밍 얘기를 안 할 때마다
이렇게 뷰 수가 엄청 올라가요
그러면 이제 어 요즘 뷰 수가 막 프로그래밍 아닌 얘기를 너무 많이 하니까
뷰 수가 올라가는 게 부담스러워서 프로그래밍 얘기를 해서 뷰 수를 좀 줄여야 될 것 같아요
오늘 할 얘기는 그.. 뭐 주제부터 말하면
뭐 행우선, 열후선, 뭐 벡터, 매트릭스 이런 얘기 있잖아요
벡터, 행렬 이런 것들
그래서 제가 쉐이더 책을 쓸 때도 보통 사람들이 통용하는 그런 언어를 써갖고
아.. 뭐 행기준, 열기준 영어로 하면 로우메이저 어.. 컬럼메이저
그걸로 해서 이제 설명을 썼는데
어느 날 독자가 제 블로그에 와서
"이거.. 이거.."
이게 이래서 잘못 쓴 거 아닌가요 두 개를 잘못 쓴 거 아닌가요 그래서
생각을 해보니까 잘못 쓴 거 같아요 그래서 교정판에서 고쳤어
아니 에라타에서 고쳤구나 오타 그 제 블로그에서 유지하는 거
그 다음에 또 누가 왔고 원래 게 맞지 않나요 물어보는데
또 이렇게 생각하면 원래 게 맞아요 그래서 뭔가 이상해서
열심히 찾았어요 문헌을 이게 정확히 왜 이렇게 되는 거고 뭐가 문제인지
그래서 결론적으로 얘기한 거는 그 문맥상에서 행기준 열기준이라는
말을 쓰는 거 자체가 말이 안 되는 거였어요 그리고 실제 제가 여기저기
사람을 보니까 다들 헷갈려하고 있어 그래서 오늘 좀 이거를 확실히
잡으려고 그래요 좀 그러니까 뭐 말하다가 또 제가 틀릴 수 있어요
워낙 헷갈리는 부분이기 때문에 근데 제가 이해하는 거에서 확실히
좀 잡을게요 일단 시작을 어디부터 할까요 행기준과 열기준이 뭐냐
행기준과 열기준은 그러니까 로우 메이저 컬럼메이저는
정말 벡터와 행렬을 곱하는 순서하고 상관이 없고 뭐 행렬이 앞이냐
벡터가 앞이냐 이런 거 있잖아요 행렬 곱하기 벡터 아니면 벡터 곱하기
행렬 어떤 게 맞냐 이거랑은 전혀 상관이 없어요 그냥 그 문맥상에서
열기준에서 행기준 얘기하는 순간 그냥 그냥 포기하세요 그건 전혀
말도 안 되는 얘기예요 로우 메이저 컬럼메이저가 어디서
나오는 거냐면 메모리에 이게 어떻게 들어가느냐의 얘기예요 사실은 예를
들면 뭐 벡터로 얘기하긴 좀 뭐 하니까 행렬로 얘기할게요 행렬로
하면은 행이 4개가 있죠 위부터 아래까지 그리고 컬럼이 4개가 있어요 열
이라 그러죠 좌우로 이렇게 있을 때 그럼 총 16개의 값이 있는 거예요
4 곱하기 4면은 그러면 16개의 값을 어떤 순서로 저장할 거냐 이게 로우
메이저 컬럼메이저예요 예를 들어 제일 윗줄에서 첫 번째 두 번째
세 번째 네 번째를 플롯 어레이 4개 딱 저장을 하고 그다음에 두 번째 줄로 넘어가서
두 번째 행으로 넘어가서도 첫 번째 열 두 번째 열 세 번째 열 네 번째 열을 5 6 7 8 로 저장하고 이게 로우 메이저예요
컬럼메이저는 그 반대로 첫 번째 줄에 첫 번째 거 저장하고 두 번째 줄에 첫 번째 거 저장하고 세 번째 줄에 첫 번째 거 저장하고
네 번째 줄에 첫 번째 거 저장한 다음에 다시 첫 번째 줄에 두 번째 열을 저장하고 두 번째 두 번째 두 번째 이런 식으로 가는게 컬럼메이저예요
한마디로 한국말로 열...
기준
이게 전부예요
그러면
그
이게 또 오해가 왜 생겼냐 그러면 벡터에서 비슷한 말이 있어요
벡터를
그 표기할 때 그니까 수학 공식에서 표기할 때 벡터를
왼쪽에서 오른쪽으로 1 2 3 4 이렇게 표현하는 경우가 있고 아니면 위에서 아래로 1 2 3 4 표현하는 경우가 있어요
왼쪽에서 오른쪽으로 표현하는 거를 행 벡터라고 해요
로우메이저 벡터 가 아니라
그리고
열로 넣는 거는 컬럼벡터예요
컬럼으로 보이기 때문에 컬럼메이저 가 아니라
그러면 행 벡터 열벡터가 전부예요
이제
그래서 그 용어가 헷갈리면서 많이 헷갈려한 거 같은데
그러면
이거는 메모리 레이아웃이거든요
그 외에는 정말 아무것도 아니에요
그래서 제가 쓴 책도 오류가 있었 고 아직도 이 판에도 오류가 있고
남이 쓴 책에도 굉장히 많은 오류 가 많아요
어떤
어떤 벡터와 행렬을 곱하는 순서를 얘기할 때
열 기준, 행 기준을 말하는 것 자체가 잘못된 거예요
완벽히 잘못된 거예요
그러면 어떻게 설명을 해야 되냐
그러면 이런 방법 있잖아요
매트릭스가 뒤에 온다
뭐 포스트 매트릭스 멀티플리케이션
뭐 프리매트릭스 멀티플리케이션
저는 그냥 설명을 이렇게 해요
행 곱하기, 그러니까 벡터 곱하기 행렬 순서냐
행렬 곱하기 벡터 순서냐
왼쪽에서 오른쪽으로
그럼 이거를 보면
당연히 행렬 곱하기 벡터를 할 때는 벡터가 열일 수밖에 없죠
왜냐면 첫 번째 줄과 열과 곱해서 첫 번째 엘리먼트 뽑아내고
두 번째 행과 다시 열 곱해서 두 번째 엘리먼트 뽑아내니까
그 반대로 벡터 곱하기 행렬이면
벡터가 앞에 있고 행렬이 뒤에 있으니까
벡터는 좌, 행으로 돼야 되고
행렬은 열로, 세로로
그래서 이렇게 곱해서 4개를 나와야죠
그래서 이렇게 곱해서 4개를 나와야죠
그러면 저는 그래서 가장 올바른 표현은
그 벡터 곱하기 행렬의 순서가 뭔지를 말하는 게 맞는 거 같아요
그럼 이 책에서는 벡터 곱하기 행렬의 노테이션이죠 표기법을 쓴다
아니면 이 책에서는 행렬 곱하기 벡터의 표기법을 쓴다
그게 전부예요
그러면 또 하나 웃기는 게
아 왜 이렇게 노테이션이 두 개냐 뭐가 맞는 거냐
이런 얘기를 해요
이게 또 종교전쟁이거든요 종교전쟁
근데 제가
제가 말하는 건 둘 중에 맞는 건 없어요
그냥 다른 표기법일 뿐이에요
그러면 가끔 그런 사람이 있어요
아니다 이거는 오픈GL이 맞는 거다
오픈GL이 뭐냐면
행렬 곱하기 벡터예요
오픈GL이 맞는 거다
왜냐면 수학 책에서 그렇기 때문에 라고 해요
문제는 모든 수학 책이 그렇진 않아요
그냥 예전에 쓰였던 수학 책 중에서
많은 수의 수학 책이 그렇게 표기법을 하고 있었고
사실 이 표기법을 반대로 돌려도
전혀 수학 공식상으로는 문제가 없어요
근데 재미있는 게 있어요
재미있는 건 뭐냐면
그럼 저는 개인적으로 뭐를 좋아하냐 라고 얘기하면
저는 그 반대를 좋아해요
벡터 곱하기 행렬을
아 수학적인 기반이 없어서 그런 거 아니냐
물론 제가 수학적인 기반이 없을 순 있는데
뭐 제가 뭐 수학과를 나온 것도 아니고
하지만 고등학교 때 수학 하나만 잘했던 애기 때문에
그건 아니라고 봐요
저는 왜 그게 맞냐고 보냐면
뭐 수학자들은 모르겠고
프로그래머 입장에서는 여태까지 저희가 프로그래머로서는

수학을 할 때 모든 거의 연산자가
모든 거의 연산자가
왼쪽 곱하기 오른쪽이었어요
우린 곱하기 할 때도 왼쪽부터 오른쪽으로 보지
오른쪽에서 왼쪽으로 안 보거든요
이 벡터와 행렬을 곱할 때는 보통 어떤 개념이 있냐면
저 이제 게임 쪽이라던가 웬만한 컴퓨터 프로그래밍 쪽에서
벡터는 보통 위치 포지션이거나 아니면 방향을 가리키잖아요
그러면 이거를 어떤 변환 행렬로 변환을 하겠다
그럼 그 값으로 이 값이 나와야 된다
라고 보는 거거든요
새로운 벡터가 나와야 된다
그러면 상식적으로 생각할 때
아 벡터가 이미 있고
왼쪽에 있고
여기다 어떤 변환 행렬을 곱해서
새로운 벡터를 받아야 된다
저는 이 개념으로 보기 때문에
왼쪽에서 오른쪽으로 보고
실제 컴퓨터에서도
C++ 같은 거에서도
오퍼레이션 오버로딩을 하면은
오버로딩이 아니라
어떤 오퍼레이션을 쓰면은
곱하기 나누기 보통 왼쪽에서 오른쪽으로 가잖아요
그거랑 일치되게 만들기 때문에
이게 맞는 방법이라고 봐요
맞는, 맞다기보다는
다른 방법이 틀리다기보다는
이게 좀 더 직관적인 방법이라고 봐요
그래서 저는 그 방법을 선호하고
그렇게 되면 당연히
저는 언제나 행렬을
그니까 벡터를 행으로 보고
행렬은 이제
뭐 컬럼메이저 로우메이저 상관이 없어요
어차피 이 상황에서
곱할 때는 행으로 곱하는 게 전부죠
내부적으로 어떻게 저장이 돼있던 간에
그게 전부예요
오픈 G에는 그 반대죠
오픈 G에는 그 반대인데
저는 오픈 G를 조금 이해가 안 됐던 게 뭐냐면
뭐 오픈 G는 수학 쪽을 따라서 그렇다고 좋아요
다 좋아
근데
잘 생각을 해봐요
저희가 매트릭스가 있고
벡터가 있으면
주로
벡터하고 행렬을 곱하는 경우가 많지
행렬과 행렬을 곱하는 경우는 적다고요
그래픽 쪽에서
왜냐하면
변환 행렬 하나 나와 있고
거기다가 버텍스
그니까 폴리건수에 따라 다르지만
폴리건수 곱하기는 좀
3이라고 보면
버텍스 한 10만 개는 좀 구라고
버텍스
그니까 한 게임에 한 프레임에 10만 개 정도는 그래요
근데 한 오브젝트에서는
캐릭터 같은 경우는 2만 개까지도 갈 수 있다고 보니까
3만 개도 가능하고
최소 만 개
그럼 만 개 버텍스에 행렬을 곱해요
그러면 아까 말한 대로
오픈 G의 방식이면 행렬 곱하기 벡터잖아요
그러면 벡터는 4개가
플론 4개가 딱 한 자리에 있으니까
이미 벡터죠
그러면 벡터 프로텍스 쓸 수도 있고
빨리 할 수가 있어요
메모리 위치도 바로 옆에 있기 때문에
그리고 이제 행렬을 곱하니까
이게 오픈 G에서 행 기준으로 저장을 했으면
그니까 매트릭스를 첫 번째 행을 하나로
연속되게 저장을 했으면
그냥 벡터 멀티플라이 하는 거 있죠
벡터 프로세서
그걸 한 번 곱하면 끝이에요
그러면 그거 4번 딱 곱하면
새로운 벡터가 나오거든요
그래서 저는 오픈 G를 처음 볼 때
아 그렇게 하려고 이걸 만들었구나 라고 하고
스펙을 까봤는데
행렬이
열 기준이야
그럼 말은 뭐냐면
벡터 빼놓고 행렬을 열
첫 번째 행에 첫 번째 열
두 번째 행에 첫 번째 열
세 번째 행에 첫 번째 열
이거를 한 줄로 저장을 한 거예요
그래서 이거를 곱하려면
벡터 곱하기를 못해
그러면 메모리에서 이거 플롯 하나 빼오고
네 칸 떼서 하나 더 빼오고
하나 더 빼오고
하나 더 빼오고
그래서 계산을 해야 돼요
그래서 보면서
아니 이 훌륭한
최적화 기회를 왜 놓셨을까
라는 생각을 했어요
그에 비해
DirectX도 여전히 최적화되어 있진 않았어요
왜냐하면 DirectX는 또 매트릭스를
행 기준으로 저장을 해
그러니까 첫 번째 행 1, 2, 3, 4로
근데 곱하는 거를 보통
이제 뭐
어느 쪽으로 곱할 수는 있는데
그 DirectX에서는
옛날 기본 방식 자체는
이제 벡터 곱하기 행렬이었죠
그러면 여전히 얘네도 문제 똑같아요
이 첫 번째 뭐 몇 번째 이거 떼어갖고 저장한다는 거에요


근데 이거의 장점은
제가 행 기준 행렬을 그나마 좋아하는 거에 장점은
상식적으로 이해가 돼
왜냐하면 요즘 이미지를 다룰 때도 그렇고
문서를 볼 때도 그렇고
뭐 어떤 데이터를 다루든 간에 요즘은
대부분이 그러잖아요
첫 줄 쭉 가고
그 다음 줄로 돌아가서 쭉 가고
뭐 텍스트를 저장할 때도 그렇고
언제나 한 줄에 있는 걸 저장하고
다음 줄로 넘어가잖아요
이미지도 똑같죠 보통
이미지 저장할 때
X 쭉 저장하고
그 다음에 Y, Y, Y 가니까
그래서 그런
상식적인 부분에서 저는 맞다고 봐요 이게
그래서
뭐
그래 좀 느리긴 하지만
아이 그래
내부적으로 내가 메모리를 따로 뜯어갖고 쓸 일이 있으면
그래 이거 나쁘지 않다
버틸 수 있다 이건데
오픈GL은
뭘 하려고 한 건지 이해가 안 돼요
그냥 이해가 안 돼요
왜 그랬는지조차 이해가 안 되는 거야 이거는
굳이 그럴 이유가 없는데
왜 왜 최악의 방향을 두 개로 골라갈까
그냥 행 기준으로 저장을 해버렸으면
곱하기라도 빨라질 텐데
그래서 제가 오픈GL을 좀 안 좋아하는 것 중에 이유가 하나가
그 오픈GL 버전 1 나올 때는 하디웨어 가속기도 거의 없었고 이랬을 때니까
그냥 순수하게 그냥 수학에서 나온 그 노테이션을
그래픽으로 짜갖고 휙 날려버리자 이 개념이었던 거 같아요
근데 수학적인 노테이션에서는
뭐 행 기준이니 열 기준이니가 문제가 없죠
메모리에 문제가 있는 게 아니니까
메모리 레이아웃에 문제가 있는 게 아니니까
근데 처음 이거를 만든 사람들 자체가
그 컴퓨터 내부를 잘 몰랐던 거 같은 느낌?
그런 느낌이 있어요
그냥 어떤 게 더 빠르고
어떤 게 더 빠를 수 있냐는 개념에 생각 없이
아 그래 어차피 10벡터 쓰니까
저장도 10로 해버리자 이 개념으로 한 거 같아요
그래서 보면서 오픈GL을 이렇게 하나하나 보면서
정말 이거는 리얼타임 렌더링 하드웨어 가속을 위해 만든
그 APA가 아니었다고 생각을 하고
그래서 오픈GL이 어느 순간에는 한 번
API 컴퓨터빌리티 백코드 컴퓨터빌리티 있잖아요
후방 후환성 그거 깨버리고 새로운 버전을 만들어야 된다
디렉텍스가 그래 갖고 훨씬 나아진 거거든요
근데 다행히도 이제 뭐 불칸이라던가 이런 APA가 나오고 있죠
근데 아직도 그게 저는 크게 믿기지 않는 이유가
그거를 끌어갈 만한 막강한 세력이 없어요
오픈GL이 옛날에 잘 나갈 때는 제 생각에 딱 두 번이었는데
한 번은 마이크로소프트가 디렉텍스 만들기 전에
오픈GL을 통해 갖고 게임 돌릴 때
옛날에 둠 같은 거 윈도우스에 돌린다고 하면서
오픈GL로 가속됐다고 그러면서 막 광고하고 마소가 그랬어요
그때 마소가 오픈GL에 엄청나게 돈을 쳐부었어요
뭐 오픈소스인데 지네 애들 돌려 갖고 오픈소스에 컨트리뷰션 하는 거예요
지네가 써야 되니까
그러다가 오픈GL의 한계를 알고 디렉텍스를 만든 회사를 사 갖고
자기네 API를 만들고 그걸 계속 개량해서
현존하는 그래픽 라이브러리 중에는 가장
APA 중에는 가장 성능이 높은
가장 성능을 생각해서 만든 API죠
그리고 이제 두 번째는 모바일이 뜨면서
애플이 이제 자기네 돌려야 되니까 가속을
오픈GL ES를 엄청 미는 거예요
근데 애플도 새로운 거 만들어 나갔죠
메탈 API인가
그 이유도 똑같은 거라고 전 봐요
오픈GL의 한계가 보이는 거예요
이 후방 호환성부터 시작해서 막 별별 이상한 성능 자체도 말이 안 되고
이제 뭐 소스 코드도 다 보이는 그런 문제도 있고
예를 들어서 쉐이더 코드 같은 경우
그거 좀 이따 얘기할게요
그래서 지네도 만들어 나갔어요
지금 하나 이거 밀고 있는 애들은
제가 볼 때 구글 하나밖에 없거든요
왜냐면 안드로이드에서 하드웨어 가속을 오픈GL로 해야 되기 때문에
근데 구글도 생각이 있으면 지네 API를 또 생각을 하고 있을 거 같아요
불칸으로는 제가 볼 때는
한 회사가 끌고 나가는 라이브러리가 확실히 통일성 있고
잘 나오는 경우가 많아요
오픈소스는 확실히 사람마다 이제 생각하는 아젠다도 다르고
사람마다 이제 뭐가 중요한지에 대한 가치관도 다르기 때문에
저는 오픈GL 자체가 이제 성능, 고성능의 그래픽을 그리기 위해 만든 API는 아니라고 봐요
그냥 리얼타임 렌더링이, 리얼타임 어플리케이션이 아닌
그냥 수도 리얼타임
한 초당 15프레임 정도 나오는 정도를 예상해서 만든 거지
게임처럼 60프레임 나오기 위해 만든 API는 아니었다고 보고
그 뒤에 막 어떻게든 막 서로 고치면서 패치를 했는데
이게 더 중구난방이 되다 보니까
옛날 API 있고, 요즘 API 있고, 이거 쓰면 느리고, 저거 쓰면 빠르고
말도 안 되는 API가 나와버린 거죠
그래서 제가 가끔 스크립트 언어에 대해 하는 얘기랑 똑같이
음... 뭐라 그럴까
자기가 놀면서 테스트하긴 좋지만
프로덕션용으로 나가기엔 참 안 좋은 API가 아닌가 생각이 돼요
뭐 그런 개념에서 이제 PS3 같은 경우도 내부적으로는 오픈GL이지만
자체 API를 쓰죠 오픈GL을 안 쓰죠 거의
그래서 아까 잠깐 얘기하려고 그랬는데
아까 얘기하려고 했던 쉐이더 부분
이 디렉텍스 쉐이더랑 오픈GL 쉐이더랑 다른 게 뭐냐면
디렉텍스 쉐이더는 자체 컴파일러를 줘요
그래서 제가 컴퓨터에서 쉐이더 코드를 짜고
HLSL로 컴파일을 하면은 그거를 이제
쉐이더 드라이버가 이해하는 어셈블리로 바꿔주거든요
그러면 이제 그 어셈블리를 이제 게임을 실행하는 도중에 로딩을 하면은
이제 각 드라이버마다 그걸 어떻게 처리할지는 좀 다르니까
안에서 다시 한 번 컴파일을, 실시간 컴파일을 조금 더 해서
일단 컴파일 타임은 그렇게 늘릴 수가 없죠
아무래도 쉐이더는 그러니까 어셈블리는 좀 더 단순한 언어니까 그 순간에서
근데 오픈GL은 그게 없어요 그 스펙 자체가 없어서
쉐이더 코드 그대로 변수 이름 다 있는 코드 그대로
이제 로딩을 한 다음에 그거를 이제 드라이버한테 컴파일을 다 해라 그렇게 해요
그러면 일단 드라이버 컴파일 시간이 늘릴 수밖에 없고
그리고 또 하나 이제 게임 개발자 입장에서는
제 쉐이더 코드를 그렇게 플레인 텍스트로 저장하느라 자체가 싫은 거예요
그래서 그런 얘기를 하면은 오픈GL 커뮤니티에서는
제가 전에 C++ 커뮤니티 좀 깠던 것처럼 똑같은 얘기를 해요
아 오픈GL은 원래 모든 게 오픈되어 있는 거기 때문에 그게 당연한 거다
이게 올바른 방법이다 그걸 숨기는 게 틀린 방법이다 라고 우겨요
그러나 불칸에서는 그게 나와요 드디어 컴파일하는 방식이
오픈GL이 이제 그게 문제라는 걸 아는 거예요
게임 개발자들이 오픈GL을 피했던 이유도 뭐 여러 가지 이유가 있지만
이것도 그 중에 하나거든요
내가 미쳤다고 실행도 안 했잖아

근데 하나도 중에 텍스트를 로딩을 하고, 일단 그거 느리죠
그걸 이제 컴파일하는데 시간을 또 보내고
그렇다고 그 컴파일한 바이너리를 캐싱할 수도 없어요
왜냐면 그 드라이버 버전 바뀔 때마다 그 포마이트가 바뀔 수가 있기 때문에
그래서 오픈GL은 정말 뭐라 그럴까
요즘 들어 이제 모바일 때문에 많이 인기를 끌긴 했지만
그거는 순수하게 그냥 애플이 자기네 APAC이 없었다고 보고
지금은 다시 좀 시들어지겠다
누가 불칸이 뜨겠냐라고 물으면 저는 일단은 의심스럽다고 얘기부터 해요
뜰지 안 뜰지 확신은 안 쓰는데
이게 지금 내 시간을 투자해서, 돈을 투자해서 뭔가를 만들만큼
불칸이 뜨겠냐라고 물으면 저는 아니라고 봐요
이게 이제 1년, 2년 뒤에는 좀 다를 수도 있지만 그건 좀 더 봐야 되고
그에 비해 디렉트X는 이미, 뭐 12는 이미 뜰 거고요
왜냐하면 윈도우스 쪽에서나 뭐 이런 게 결과적으로는 뜰 거고
그건 마이크로소프트 엄청 밀고도 있고
음... 뭐 이게 크로스 플랫폼이 아닌 거에 단점은 있지만
저는 솔직한 얘기로
마이크로소프트가 디렉트X 자체를 크로스 플랫폼으로 만들어주면 좋겠어요
근데 그럴 수가 없는 이유가 있는데 지금
굉장히 큰 이유가 있지만
아니면 오픈제를 다시 돌아와서 오픈제를 정리를 해주던가
근데 문제는 마이크로소프트가 그럴 리가 없죠
자기네 자체의 AP가 있기 때문에
그래서...
예...
저는 그래서 오픈제에 대한 제 생각도 그거고
뭐 행기준, 열기준 얘기하다가 여기까지 왔는데
불칸에서는 그 행렬을 어떻게 저장하는지 모르겠어요
바뀌지 않았을 거 같은 생각인데
좀...
예, 상식적으로 봤으면 좋겠어요 옛날에 뭐 왼손잡이, 오른손잡이 얘기 때도 그렇고
그래서...
결과적으로는
제 책 틀린 거부터
이제 행렬 이런 거, 뭐 메모리 저장 얘기하는 거
효율성
그리고 오픈...
오픈지엘이 좀 이해가 안 되는 부분
내가 보는 오픈지엘과 디렉트엑스의 차이점
왜냐면 제품을 만드는 사람으로서
그 정도까지고
뭐 그런다고 해서 이제 어떤 플랫폼에서 오픈지엘을 밖에 지원 안 한다
그럼 저도 오픈지엘 써요
그러나 쓸 때마다 언제나 참...
좀 더럽단 생각을 해요
그래서 오픈지엘이 ES에서는 좀 클린업을 했지만
뭐...
그렇죠 웹지엘 쪽에서도 좀 그랬고
어쨌든 그 정도고
음...
예, 뭐 이 정도면 주저리주저리 할 얘기 다 했고
시청자도 많이 이뤘을 것 같으니까?
포프였습니다
