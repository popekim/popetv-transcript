안녕하세요 포프입니다. 오늘 제목은 좀 재미있게 나갈 거 같아요. 아마 이렇게 내보낼 거예요.
컴퓨터는 추상적으로 돌지 않는다.

제가 여태까지 하드웨어가 중요하다 이런 얘기를 해왔던 거랑 일맥상통하는 얘긴데, 최근 들어서 알고리듬의 의미를 제대로 드디어 들었어요. 여태까지 알고리듬은 ‘이런 게 알고리듬이다’ 이렇게만 알고 있었지만 제가 정의를 제대로 들은 적이 없었던 것 같아요. 그만큼 제 공부가 헛된 공부였다는 그런 얘기일 수도 있는데, 거기부터 얘기를 시작할게요.

지금 하려는 얘기는 한빛 강의에서 할 내용이기도 해요 사실은. 한빛 저자강의. 이 비디오가 나가는 순간 이미 저자강의는 끝났을 테니까 재탕하는 기분으로 아무 죄책감 없이 만들려고 하는 거죠. 그 외에 다른 내용이 있을 거예요 어차피.

최근에 넷플릭스를 뒤지다가 거기 보면 알고리듬이라는 티비쇼였던 것 같은데 하나 있어요. 딱 단편짜린데, 영국의 무슨 교수가 나와서 알고리듬을 설명해 주는 것 같아요. 근데 이 사람이 알고리듬이라고 하길래 전 당연히 되게 단순하게 컴퓨터 알고리듬이라고만 생각을 했어요. 근데 이 사람이 알고리듬의 예를 들면서 설명한 게 최소공배수인데, 유클리드의 최소공배수 맞을 거예요. 그거를 설명하면서 알고리듬은, 그냥 그 사람이 직접 말한 건 아니지만, 컴퓨터에만 있는 게 아니라 실생활의 어디에나 알고리듬이 있다 이렇게 이야기를 해요.

그리고 그 사람의 설명을 들으면서 제가 느꼈던 게, 아 세상은 알고리듬으로 도는 게 맞구나, 제가 느꼈어요. 그럼 그 이유를 그 사람이 든 최소공배수로부터 설명을 할게요.

최소공배수가 뭐냐? 그러면 대부분 아실 것 같지만… 최소공배수 맞나? 아닌 것 같은데, 최대공약수. 최대공약수인 것 같아요. 죄송해요. 영어로 들어서 한국말로 대입이 안되는데, 최소공배수나 최대공약수 둘 중에 하난데, 그 둘 중에 하나 제가 말하는 거 중에 맞는 거 보시면 될 거 같아요.

뭘 말하려 하는 거냐면, 숫자가 예를 들어서 두 개가 있어요. 21이 있고 28이 있어요. 그럼 이제 이 둘을 나머지가 없게 나눌 수 있는 분모 중 가장 큰 값이 뭔가를 찾는 거예요. 가장 큰 값이고, 나누는 거니까 최대공약수가 맞는 것 같아요. 뭐… 아니면 욕하세요.

그러면 21하고 28은 7로 둘 다 나눠지잖아요. 그리고 그게 동시에 나뉘는 가장 큰 숫자예요. 7×3=21, 7×4=28이니까. 그러면 그 값은 7이에요. 근데 이게 막 복잡해지면, 숫자가 막 15263 하고 85215조 막 이렇게 나가면은 이 숫자를 찾기가 그렇게 쉽지는 않죠. 그런데 이미 유클리드는, 유클리드가 맞을 거예요, 틀리지 않길 바라는데, 이미 그 분이 살아계시던 시절부터 수학적으로 최대공약수를 찾는 법을 설명해 왔고, 그걸 실생활에 적용하는 방법도 알고리듬을 만들어 놨다는 거예요.

알고리듬이 뭔지 설명하기 전에 최대공약수를 어떻게 찾는지 설명을 드릴게요. 이 비디오에서 얘기했던 내용은 뭐냐면, 네가 화장실에 타일을 깔아야 돼. 화장실이 직사각형이에요. 화면처럼 직사각형의 화장실인데, 거기에 타일을 깔고 싶은데 이 타일을 깨지 않도록 네모나게 다 들어가도록 크기를 찾고 싶다는 거예요. 결과적으로 그게 뭐냐면 윗면과 옆면의 길이가 다르잖아요, 그러면 이걸 공통적으로 나누는 방법 중에 가장 큰 값을 찾는 방법.

그러면서 했던 얘기가 뭐냐면 되게 간단했어요. 유클리드가 맞을 거예요, 그 사람이 정해놓은 바에 따르면 시작을 정사각형으로 시작을 하면 된대요. 정사각형의 길이는 짧은 변, 높이죠 지금은 저희가 볼 때는, 높은 변의 길이에 딱 맞는 정사각형을 만들어서 그거를 타일링을 한대요.

타일링을 하면은 한 타일이 딱 들어가고 나머지가 요 옆에 이렇게 남잖아요. 그럼 이제 거기서 남은 직사각형에서 짧은 쪽을 잡아서 정사각형을 넣어요. 그러면 이만큼이 채워지겠죠. 그리고 남은 건 이만큼이 남을 거예요. 그쵸? 그럼 다시 짧은 변을 잡아서 정사각형을 만들어 채워 넣어요. 그럼 다시 끝에 짜투리가 남고, 정사각형을 만들어 채워 넣고 채워 넣고 하다 보면 어느 순간에 딱 맞는 크기가 나와요. 그럼 그게 바로 최대공약수고, 그만한 타일로 화면을 다 깔아버리면 중간에 짤리는 부분 없이 예쁘게 깔린다는 거예요.

알고리듬으로 이걸 봤을 땐 되게 간단한 거예요.
일단 이렇게 넓이가 있으면 가장 짧은 면, 그죠, 좁은 면에 정사각형을 만들어 넣는다. 더 이상 정사각형을 넣을 수 없을 때는 다시 남은 부분을 똑같이 직사각형으로 떼서 짧은 변에 해당하는 길이를 잡고, 똑같은 과정을 반복하다가 그게 끝나서 딱 정사각형이 들어가는 경우, 더 이상 남은 공간이 없는 경우, 그게 바로 너의 최대공약수이다예요.

저는, 아니, 이 사람이 말했던 알고리듬의 정의가 뭐냐면, 알고리듬을 찾고 만드는데 걸리는 시간이라던가 노력은 굉장히 천재들이 만들 수 있는 영역이라고 얘길 해요. 그러나 일단 그 사람들이 알고리듬을 만들어 놓으면 어느 누구나 순서대로 따라할 수 있고, 순서대로 따라했을 때 언제나 원하는 결과가 나오는 것을 알고리듬이라고 해요.

그러면 들어보면은, 저는 맨날 컴퓨터에서 말하는 버블소트니, 뭐 정렬(소트)이나 그래프 시오리(Theory)니, 길찾기니 이런 것만 알고리듬이라 생각을 했었죠. 근데 결과적으로 그것도 하는 건 뭐냐면 이렇게 이렇게 정해진 룰이 있고, 그 룰대로 한 단계 한 단계 따라가다 보면 값은 보인다예요. 그게 알고리듬의 정의예요. 물론 알고리듬에 쉽게 걸리는 것도 있고 오래 걸리는 것도 있고 그건 다른 이야기고.

그럼 이걸 생각해 봤을 때, 제가 왜 세상은 알고리듬으로 돌아간다고 말을 했냐면, 저는 보통 여태까지 그걸 프로세스라고 이야기를 해왔어요. 이런 프로세스를 잘 잡으면 이게 된다. 근데 저희가 하고 있는 그 무수한 것들 있잖아요.

예를 들어서 내가 집에서 저기까지 가려면 어떻게 가나? 전철을 타고 갈 때 전철역에 가서 표를 사거나, 표를 이미 갖고 있거나, 표를 찍고 들어가서 1호선 어디에 갈아탄 다음 어디까지 가서 환승하고, 2호선 어디에서 다시 내리고 가면 갈 수 있다. 그게 반드시 효율적인 길은 아니지만 대충 효율적인 길이고. 요즘 사람들은 또 나오잖아요, 몇 번 출구, 몇 번 문에서 내리면 환승이 곧바로 있다. 그러면 기다리는 동안 몇 번 문까지 가서 거기서 기다리고 있다가 들어갔다가 내렸다가. 이런 게 알고리듬인 거예요.

심지어 커피를 내리는 법 이런 거 봐도 매뉴얼이 따라 나오잖아요. 순서대로.
1번, 커피를 간다던가.
2번, 꽂고 넣고,
3번, 물을 데우고,
4번, 뭘 하고 씻고 넣는다.

이거 자체가 그냥 알고리듬인 거고, 중간중간 보면 ‘표면이 뜨거우니 손잡지 마세요’ 이런 것들이 있잖아요. 그게 바로 사고를 막기 위해서, 안전하게 이걸 따라만 하면 내가 몸에 피해가 없고도 맛있는 커피를 만들 수 있는 과정을 정해놓은 게 순수하게 알고리듬이었던 거예요.

그래서 프로세스와 알고리듬의 정의가 모호해지면서, 아 이게 같은 거였구나 생각이 드는 거예요. 그러면 결과적으로 알고리듬의 정의라는 게 아까 말했듯이, 단계별로 따라하기만 하면 결과가 나오는 거고, 그걸 따라하는 게 일반인이 하기에도 멍청하거나 문제가 있는 사람이 아니면 어렵지 않은 것들.

저희가 사회에서 말할 때도 그런 말 많이 하잖아요.
“야 너 이거 이거 해. 이거 이거 하면 돼.”
이렇게 말하면은, 이걸 따라하는 사람이 되게 잘해요. 한두 개 실수는 하지만. 그런데 그것도 못 따라 하는 애들이 있잖아요.

그럼 알고리듬이 그 사람에게 너무 어려운 거거나, 그 사람이 일반 사람에 비해 그런 걸 따라 할 정도의 능력이 안 되거나, 지능이 안 되거나, 아니면 신경을 안 쓰거나. 아예 그들 중에 하나죠 사실. 그러나 따라만 한다면 쉽게 될 수 있는 부분이 그런 것 같아요.

여기까지 사회의 굉장히 많은 것들이 순서를 정해서 하는 것들, 규칙을 따라 하는 것들이 사실은 많은 알고리듬이라고 생각하면 돼요. 캔 따는 것도 똑같아요. 캔을 들어올린다, 딴다, 따진다. 이런 것들. 아니면 둥글둥글 캔 돌려 따는 것도 있잖아요. 그것도 똑같은 거고.

그러면 컴퓨터에는 왜 알고리듬을 많이 쓰냐, 그런 얘기를 하잖아요? 그냥 컴퓨터는 이렇게 정형화된 과정들이 있을 때, 단계별로 정형화된 과정들이 있을 때 그거를 굉장히 사람보다 빨리 돌릴 수 있는 기계 중에 하나예요. 그냥 그게 전부인 거예요.

그래서 컴퓨터가, 그걸 만드신 분이 그렇게 만들었겠지만, 주목을 받고 있고 온 세상이 컴퓨터로 돌아가는 이유도 그냥 저희가 당연하게 단계별로 만들어 왔던 과정들. 심지어는 예전 고대부터 불 붙이려면 장작을 쌓고, 짚을 넣고, 부싯돌을 해서 불이 오르면 바람을 후 불고… 이런 과정을 쌓아왔던 것들이, 그걸 컴퓨터로 옮기면 굉장히 빨리 할 수 있다는 거예요.

그리고 컴퓨터가 생기고 나서부터 저희의 일상이 빨라진 것도 있지만, 그만큼 저희가 무슨 일을 해도 빨리 처리하게 되고 효율적으로 살 수가 있는 거잖아요. 그래서 아 그렇구나 라고 생각을 했고, 결국 알고리듬이 현재 사회에서 돌고 있던 건데 컴퓨터를 도입해서 더 빨리 돌게 하는 것뿐이구나.

심지어는 정렬만 생각해도, 버블소트 이런 건 아시잖아요. 그것만 하더라도 실제 사회에서 우리가 여러 가지 숫자를 두고 숫자를 정렬을 하려면 어떤 방식으로 할 거냐? 그러면 끝에부터 보면서 제일 큰 거 찾아서 하나씩 바꾼다 이런 사람도 있고, 그게 제가 알기로는 인서트 소트일 거예요 아마. 그게 아니면 두 개씩 비교해 가면서 바꿔가는 애들이 있고, 큰 거 큰 거 계속 올라가게. 그게 버블소트고. 결국은 그거였거든요.

그럼 제가 옛날에 되게 그런 얘기를 많이 했어요. 좋은 엔지니어는 생활 습관부터 다르다는 얘기. 그게 어찌 보면 저는 뭘 본 거냐면, 아까 말했던 프로세스를 잘 따르는 사람들. 심지어는 프로세스를 자기가 만들 수 있는 천재 영역에 있는 사람들. 아주 뛰어난 천재는 아니겠지만, 천재와 중간에 있는 사람들.

그런 사람들이 결과적으로 프로그래밍에 봤을 때도, 그런 가속화된 단계별로 알고리듬을 따라가는 가속화된 컴퓨터를 어떻게 돌릴지를 안다는 거죠. 컴퓨터가 할 수 있는 건 그것뿐이니까. 그런 개념에서 제가 그런 얘기를 많이 해왔던 것 같아요.

니가 원래부터 남들보다 프로세스를 잘 따라, 또는 잘 따르려고 해. 아니면 남들보다 프로세스를 좀 더 잘 만들어. 그런 문제점을 발견하고 훨씬 더 좋은 알고리듬을 만들 수 있는 사람이야. 그러면 당연히 엔지니어도 나아질 수 있는 거고, 아니면 이게 훈련이 가능도 한 거죠.

근데 이 두 개가 분리되는 순간, “컴퓨터는 전혀 새로운 거, 내 일상은 전혀 새로운 거” 이렇게 생각하는 순간 이미 잘못 생각하고 있다는 거죠. 실제 도는 기반은 똑같고, 속도의 차이일 뿐인데.

그 얘기를 하고 싶었고, 두번째는 제가 추상화의 위험성에 대해서 되게 많이 얘기를 했어요. 예전부터 컴퓨터 어떻게 도는지 이해 못하는 사람들이 자꾸만 약 팔려고 이상한 컨셉 던져놓고, 결과적으로는 사람들이 못 따라해서 개발자들이 못 따라해서 그런 개념 다 망가지고 반짝 약 팔고 사라진다고 그런 얘기를 되게 많이 했어요.

그것도 똑같은 얘기예요. 아까 그 누구야, 그 비디오 나왔던 교수님이 말했던 것도 그렇잖아요. 알고리듬이라는 거는 일반 사람들이 되게 쉽게 따라할 수 있는, 차근차근한 과정을 거쳐서 되는 게 알고리듬이다라는 얘기를 했어요. 근데 추상화를 너무 해버리면 이런 추상화에 스텝 바이 스텝 가이드가 있는 게 아니라, 그냥 뭉뚱그려서 “아, 아트는 아름다운 거지” 이런 식으로 개념이 갈 수가 있는 거거든요.

그렇게 단계별로 쪼개서 구체적인 내용을 주지 못한 채, 그냥 약을 팔고 있는 거죠. 망상을.
“아, 이렇게 하면 이렇게 된대. 다 될 거야.”
이제 사람들이 질문을 하기 시작해요. “이런 이런 거에서는 문제가 있는데 어떻게 할까요?” → 답이 없어요. 그게 그 순간에 약 파는 게 나오는 거예요.

단점들이 나왔을 때 그 단점을 어떻게 개선해야 될 건지, 아니면 그 단점을 어떻게 줄이기 위해 노력할 건지에 대해 고민이 전혀 없는 진영들이 있어요. 그건 말 그대로 컴퓨터도 이해를 못하는 거고, 실생활에서 프로세스도 못 따라하는 거고, 자기가 프로세스에서 좋은 걸 만들기도 되게 어려운 사람 중에 하나예요.

그 사람들이 말도 안 되게, 이런 걸 다 무시하고 “이 약만 먹으면 최고의 프로그래머가 된대”라는 개념으로 파는 게 문제가 있는 거죠.

그래서 그냥, 그 비디오를 보고 최근에 또 제가 멘토링하는 이런 애들을 보면서, 분명히 나보다 빨리 배우고 일찍 시작하지만 뭔가 나보다 발전이 느리다고 느끼는 부분들이 있어요. 그러면 그런 걸 보면, 제가 아까 말씀드렸던 프로세스를 따르는 것일 수도 있고, 알고리듬을 따르는 것일 수도 있는데, 그거를 정말 빨리 습득해서 제대로 따라가는 능력.

그리고 뭔가 문제가 있을 때 그 프로세스나 알고리듬에서 “여기서 이거 하나를 고치면 내가 보던 문제가 사라지고 다른 부작용도 없을 것 같다”라는, 그런 프로세스 개선 과정, 마인드를 가진 사람들. 그런 부분이 좀 없는 것 같아요.

그것도 있고, 다른 것도 있지만 그걸 하나 느꼈고. 그래서 비디오도 보고, 강연하기 전에 질문 받았던 것도 그런 고민들이 많기에 그 강연을 하며 다 합쳐서 이 비디오를 만들었어요.

오늘 비디오의 제목은 “컴퓨터는 추상적으로 돌지 않는다.”
부제: “인생은 알고리듬으로 돈다.”

괜찮은 제목 같죠? 포프였습니다.
