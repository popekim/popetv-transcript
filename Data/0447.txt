예 안녕하세요 보프입니다
오늘은 또 프로그래밍 얘기를 할게요
프로그래밍 얘기를 할 때마다 왠지 뷰수가 떨어지는 그런 이상한 느낌이 있는데
사람들은 제가 헛소리 할 때도 좋아하는 것 같아요 이상하게
프로그래밍 얘기가 아닌
어쨌든 제가 프로그래머들 면접 볼 때 물어보는 질문이 당연히 좀 바뀌지만
꽤 즐겨 물어보는 질문 중에 하나가
뭐 해시 테이블을 만들 수 있느냐 중에 하나에요 사실은
직접 만들라고 시키는 경우도 있고 해시 테이블 해시 맵 이런 경우
이 질문을 묻는 이유가 뭐냐면
프로그래머로서의 실력을 좌지우지하는 건 결과적으로는
컴퓨터가 어떻게 도는지를 이해를 잘하는 거라고 생각을 해요
예전에 제가 컴퓨터는
뭐
문자 스트링을 어떻게 표현하냐 이런 비슷한 비디오에서도 말을 했지만
컴퓨터에 저장되는 모든 내용은 결국엔 숫자거든요
진짜 숫자에요
왜냐면 메모리나 이런 파일 시스템이 결과적으로는 이진수
뭐 1010 이걸로 저장이 되는 거고
그 이진수로 저장된 숫자를 어떻게 해석을 하느냐의 문제인 거죠 사실은
뭐 무슨 의미냐 그러면
되게 간단한 거잖아요 실제 의미에서는
예를 들어서 저희가 뭘 얘기할 때
야 이거 이거 이거를 우리가 1번이라고 하고
이거 이거 이거를 이제부터 2번이라고 하자
그럼 앞으로 우리는 야 1번 할래 2번 할래 이런 식으로 물어볼 수가 있는 거잖아요
그런 식으로 각 숫자에 대한 의미를 지정을 어떻게 해주냐에 따라
그 숫자가 글자가 될 수도 있는 거고
뭐 정수가 될 수도 있는 거고 실수가 될 수도 있는 거고
아니면 심지어는 명령어가 될 수도 있는 거예요
아니면 지금 화면에 보고 있는 이런 픽셀이 될 수도 있는 거고
결과적으로는 그 모든 게 적힌 숫자를 어떻게 해석하느냐의 문제예요
어떤 규칙으로 어떻게 볼 거냐
컴퓨터에서 실제 돌고 있는 머신코드라고 하는 오프코드
그것도 개념은 같아요
뭐 처음 몇 자릿수는 이제 명령어로 봐서
그 숫자에 따라 어떤 명령어인지 결정을 하고
그 뒤에 오는 뭐 세 자리 세 글자 뭐 뭐 이진수로 할게요
뭐 이진수의 세 자리는 뭐 매개변수 1 매개변수 2 이런 식으로 본다
뭐 이런 식으로 다 정의가 가능한 게 전부예요
그럼 왜 굳이 해시맵이냐
일단 컴퓨터 구조를 알고
그리고 아까 제가 봤을 때 수를 알면은
컴퓨터에는 모든 게 수로 저장된다는 이런 개념을 이제 가지게 된다고 그랬잖아요
해시맵이 저희가 가지고 있는 그 많은 컨테이너들
리스트라던가 맵, 딕셔너리 뭐 이런 것들
이런 자료 구조 저장체 컨테이너 중에
가장 그 모든 게 숫자를 표현을 한다는
그런 컴퓨터의 속성을
가장 잘 이용한 컨테이너예요
그리고 그 속성을 되게 잘 이용해서
점프 테이블 같은 개념을 만들어서
원래 같으면은 내가 무슨 바구니에 물체 500개를 순서대로 적어 내놨다면
아니 500개 물체를 정리를 해놨다면
500개를 하나씩 박으면서 판단해야 하지만
그냥 아 뭐 이 툴은 언제나 A 섹션에 있어
저런 음식물은 언제나 D 섹션에 있어
이렇게 레이블을 잘 막 박는 거죠
이런 것만으로 거기 가서 몇 개만 찾으면 되니까
참석도가 빨라지잖아요
그런 개념을 굉장히 약간 지니어스하게
그 컨테이너에 집어넣는 개념이라 그래요
그럼 이제 사람들 보고 그거 되게 많이 해요
저는 흔히 야 그래?
야 그 딕셔너를 하나 만들어 봐
그냥 클래스 딕셔너를 하나 만들어 봐
그럼 어떻게 할지 모르고 손을 뻗는 사람들이 있어요
아 이거는 그냥 O1이라고만 배웠는데
그 참석도 O1이라고? 그건 왜 O1인데?
그게 어떻게 도는지 생각해 봤어?
아니요 그냥 썼는데요
그럼 네가 나중에 다른 너만의 알고리즘을 만들 때
뭔가 이렇게 O1이나 이런 걸 해야 될 일이 있어요
그냥 그 컨테이너 문제가 아니라 알고리즘을 만들 때
근데 그 간단한 해시맵조차 도는 거를 모르는 사람들은
그런 알고리즘 자체를 짤 생각을 못하는 거죠
그러니까 기본이 되는 뭔가를 해보고
그 기본기가 있어야만 나중에 이..
아 기본기를 정리하고
아 이런 비슷한 거를 여기 적용할 수 있겠다라는 걸 알 수가 있는 거잖아요
그래서 어찌 보면 학교라는 거 공부라는 거
그런 거는 이제 그런 기본기를 가리키고 있는 거고
근데 요즘 뭐 학교 제도가 어떻게 됐는지
아니면 사람들이 공부를 안 하는 건지
아니면 가르치는 사람이 실력이 없는 건지는 모르겠지만
이런 기본기들 없는 사람이 너무 많더라고요
그리고 경력이 2년 3년 4년 5년 됐는데
실력이 여전히 주니어 단위 거나
주니어에서 못 올라가고 있는 사람들을 제가 이제 만날 경우가 있잖아요
면제로 볼 때도 있고
면접 보면은
이런 면접 보면은 그냥 손을 뒤지쳐요
그냥 뒤지쳐요
근데 본인들은 이런 거를 못 하는 것 때문에
자기 실력이 안 늘고 있다고 생각을 안 하는 거 같아요
말을 해가지고는요
기본기가 안 되기 때문에 안 느는 거라고
근데 이제 개념을 못 잡고 있다가
이런 친구들이 기본기가 갖춰진 사람들하고 일을 해보면은
이 기본기가 갖춰진 사람들은
당연히 새로운 회사 들어오면은 새로운 코드베이스고
약간 처음은 헤매지만
이런 것들이 굉장히 빨리빨리 습득을 하더라고요
아 이거는 그거랑 같은 거구나
오케이 넘어가고 넘어가고 넘어가고
이렇게 정리하면은 이런 저런 저런 패턴을 쓰는구나 끝이에요
그게 아니라 이런 기본기가 없는 사람들은
음...
그 그 패턴을 보지 못하는 거지
왜냐면 그 기본이 되는 패턴 자체를 모르니까
짝수를 모르는데
곱하기 4가 뭐 뭐 곱하기 곱하기 2랑 무슨 상관이 있는지
알기도 어려울 수도 있잖아요 사실은
그래서 그런 개념으로
그냥 세상에 있는 모든 라인의 코드를
하나하나가 색다르게 보이는 거 같아요
그래서 그 자기가 습득하는 거 같아요




학습해야 될 양을 줄이고 외워야 할 양을 줄이고
거기서 파생되는 걸 도출할 수 있는 방식을 못 찾다 보니까
계속 일은 많이 하는 것 같고 시간은 많이 하는 것 같은데
일은 안 나오는 거야 성과는 안 나오는 거야 이런 문제가 되죠
그래서 그러면 도대체 해시웹을 어떻게 만드는 걸까
뭐 이건 누구나 알고 있어야 하는 건데
모르는 사람들을 위해서 그냥 간단하게 설명을 할게요
제가 예전에 강의 중에 설명을 한 적도 있는데
뭐 그거를 배운 애들도 또 신경을 안 쓰는 건지
이해를 못 한 건지 이해를 못 할 때가 있더라고요
기본적으로 해시웹이라는 거는 아까 설명했던 거랑 같은 거예요
내가 여러 가지 물체들이 있는데
이 물체들을 일렬로 세워놓지 말고
야 너는 저기 바구니 A에 들어가 있어
너는 바구니 D에 들어가 있어
이거를 하고 싶은 거예요
영어로 하면 비닝이라고도 해요
그 비닝이 바구니거든요
비닝이라고도 해요
그러면 이걸 하고 싶다가 전부예요
그러면 중요한 거는 그거죠
아 그러면 내가 이 물체를 어떻게 찾아야 될까
제가 뭐 해시 테이블 해시 맵 이거를 이제 공통으로 쓰는 이유는
그냥 해시 테이블은 내가 이 값을 넣을 때
아까 말한 물체 하나를 넣을 때
이거를 이제 거기 빈에다 넣는 이게 전부고
해시 맵의 개념은
내가 빈에다 넣는다
빈을 결정할 때 쓰는 물체와
실제 빈에 넣는 물체가 다르다고 생각하면 돼요
어떤 개념이냐
제가 물체가 이런 두 도구가 있잖아요
그럼 거기 바코드가 있죠
그럼 그 바코드를 기준으로 바코드 끝이 뭐 오다 이러면
다섯 번째 빈 이렇게 넣는 방식으로 하는데
실제 넣는 물체는 이 물체라는 거죠
그래서 이런 실제 넣는 물체와 그 빈을 결정하는
그런 기준이 되는 게 다른 게 맵이고
그러면 거기서 키라고 하는 게
키라고 하는 게
키라고 하는 게 있겠죠?
꼭 밸류라고 하는 게 있어요
키가 아까 말한 바코드고
밸류라고 하는 게 물체예요
근데 일단 이걸 합쳐서 해시 테이블로 하나 생각을 할게요
컴퓨터에서 그렇게 생각하는 것이 편해요 일단은
해시 테이블은 내가 가진 물체를 가지고
여기서 어떤 바구니에 넣어야 될지를 결정해야 되는 거예요
그러면 아니 어떻게 결정을 해요?
이거를 굉장히 빠르게 수학적으로 계산할 수 있는 방법이 있어요
이유?
컴퓨터가 가지고 있는 모든 물체, 모든 개체는 숫자니까
그게 전부예요
그럼 예를 들어볼게요
가장 간단한 예로 알파벳을 들죠
대문자 A가 아스키 코드로 하면 65예요
그리고 소문자 A가 97이에요
아스키 코드로 하면
그러면 그리고 B는 그거보다 하나가 높아요
대문자로 할게요
그러면 아까 65가 A였으니까 B가 66
뭐 C가 67
이렇게 돼요
그럼 저희가 바구니가 10개가 있다고 생각을 해봐요
그럼 바구니에 일단 번호로 붙일 수 있겠죠
처음 건 0번, 마지막 건 9번
10개의 바구니가 있어요
그럼 65가 왔어요
내가 A하고 B가 왔을 때
이 두 개를 다른 바구니에 넣으면
그러면 다른 바구니에 넣으면 나중에 가서 찾을 때 더 빠를 것 같잖아요
한 바구니에 넣는 것보다
그럼 봐요
65고 얘는 66이야
그럼 얘네 둘을 숫자상으로 다른 바구니에 넣는 법이 뭐가 있어요?

10개 중에
나누기 연산을 하면 돼요
65에 나누기 연산 10을 하면 5가 나오죠
66에 나누기 연산 10을 하면 6이 나와요
그러면 A는 5번 빈에
B는 6번 빈에 넣는 거예요
그럼 C는 당연히 7번 빈에 넣겠고
그럼 10개가 돌아서 75가 되는 건 다시 A 빈에 들어가겠죠
아이가 5번 빈에 다시 들어가겠죠
그럼 들어가 있어요
야 그러면 나중에 내가 A를 찾고 싶어
그럼 어떻게 해야 돼?
그러면 어? A를 가져와
일단 봐서 A 나누기 10을 하니까 5가 남아
그럼 5번 빈에 있겠네?
5번 빈에 가서 봐요
여기 A가 있어?
어? 있네?
그럼 가져오는 거예요
이 개념을 자료 저장 구조로 만든 게
이제 해시 테이블이라는 거예요
물론 이제 제일 간단한 해시 테이블의 개념을 들면
한 빈에 물체가 하나만 들어갈 수 있다고 가정을 해요
그럼 예를 들어서
아까 말했던 알파벳이 있잖아요
그러면 65에서
70 아니 65에서 74까지
딱 그거만 이제 알파벳을 받아올 수가 있다
실제 존재하는 자료가 그걸로 한다
그리고 가정을 하고 시작을 하면은
그냥 배열을 10개를 만들어두고
배열을 10개 만들면 배열 인덱스가 0부터 9번까지잖아요
그죠?
그럼 0부터 9번까지 만들어두고
그럼 숫자가 들어올 때마다 A를 숫자로 변화해서
야 이 캐릭터는 뭐 나눠서 5니까
빈수대로 나누는 거죠
나눠서 5니까
그럼 이 캐릭터는 뭐 나눠서 5니까
이제 0번 1번 2번 이렇게 넣는 거예요
그럼 그 반대로
내가 만약에 아까 말했던 어레이수를 9개를 줄였어
그럼 나누기 9를 하면 되는 거예요 그냥
왜냐하면은
이 그 숫자가
0부터 9를 넘어서 10이 될 때
다시 나누기 9를 하면은
0이 돼 버리잖아요
아 그러니까
0부터 시작해서 9가 될 때
나누기 9를 하면은 나머지가 0이 돼 버리잖아요
그럼 0번째 빈에 다시 들어가는 거예요
그런 식으로 하면은 되는데
문제는 이제
지금 숫자가 10개인데
9개면은 당연히
이제 하나의 중첩된
중첩된 데이터가 2개 들어갈 수밖에 없는 거죠
그럼 배열에 그냥 넣는 거로는 안 되고
그 배열 자체가 각 배열의 요소
0번 빈 1번 빈 2번 빈 이게 리스트로 돼 있으면은
거기다 하나씩 넣으면서
아 0번 빈에 가서 있는 것들 다 훑어와
이런 식으로 해서 이제 저장은 할 수가 있죠
그러나 당연히 속도는 5 원이 아니겠죠
여러 개가 들어가 있으니까
그럼 그런 경우에는 당연히 뭐 빈수를 늘려서
내가 숫자가 60개가 있다
그럼 빈을 80개 박아주면은
나누기 80 하면은 다 빈마다 하나씩 들어갈 거고
빈 공간이 있을 거고
그럼 빈 공간을 좀 낭비하는 대신
빈수를 늘려서 어쨌든 간에 매번 하나씩 찾을 수 있게 하자
이런 개념이 생기죠
그러면 이런 얘기를 또 할 수가 있어요
야 근데 네가 지금 하는 거는
단순히 캐릭터 하나로 나누기 했기 때문에
숫자가 나와서 그렇게 찾을 수가 있는 거지
그럼 그게 아니라
캐릭터가 여러 개 있는 스트링 같은 거 문자요?
아니면은 정말 다른 오브젝트 같은 경우 어떻게 하냐
오브젝트에 막 이런저런 데이터 들어가 있는 거
근데 그것도 개념은 간단해져요
어차피 모든 건 숫자라니까 컴퓨터에서
그러면 이 오브젝트가 보여주는
가지고 있는 데이터를
그쵸?
가지고 있는 데이터를 어떻게 수를 바꿀 거냐가 전부예요
그리고 오브젝트 A와 오브젝트 B가 다를 때
이 두 개에서 어떤 수를 만들 때
그러니까 이 오브젝트 A는 언제나 같은 수가 만들어지고
그래서 오브젝트 B는 언제나 같은 수가 만들어지지만
이 A와 B의 데이터가 다를 때 다른 수가 만들어지게
뭔가를 만들어 놓는다면
그 값을 다시 나누기 몇을 해서
해시맵이나 해시태그를 집어 넣을 수 있다는 얘기죠
이 어떤 오브젝트에서 유니크한
그러니까 입력 값이 같을 때 언제나 유니크한
아웃풋 값을 만드는 함수가 해시 함수예요
그래서 해시 코드, 해시 함수
여기서 해시 넘버를 쓰자는 얘기가 뭐냐면
오브젝트를 가져다가 다 비교를 하면은
엄청나게 시간이 걸리니까
그거를 이 오브젝트는 시그네처가 이거야
여기에 이거에 대한 이제
이 입력 값은 언제나 해시 값이 나와
그럼 이것만 가지고 비교하는 것만으로도
두 오브젝트가 같을 확률이 높다라는 걸 확인할 수 있죠
단 예외는 오브젝트 A가 있고 오브젝트 C가 있고
데이터가 다른데 같은 값이 나올 수도 있어요
그럼 이런 다른 데이터를 가지고 유니크한
그런 정수 값을 만들 수 있냐
이거에 따라 해시 알고리즘이 있는 거고
다른 알고리즘을 꼽으면 어떤 성능이 어떻고 이렇게 나오는 거예요
아까 말했던 스트링 같은 경우는 정말 단순하게
스트링에 캐릭터가 10개라면은
캐릭터 10개를 그냥 다 더해버리고
그리고 나누었으면 하는 법도 있어요
나머지를 구하는 법
근데 문제는 AB 이렇게 된 스트링과 BA 이렇게 된 스트링의
해시 값은 같아지겠죠
두 개를 그냥 더하는 거니까
65, 66 더 하나
66에서 65 더 하나 또 하나
똑같잖아요
그럼 뭐 이런 걸 막기 위해서
첫 번째 오는 거에는 곱하기 16을 곱하고
다음에 오는 거는 곱하기 16을 또 곱하고
이런 식으로 할 수가 있어요
그럼 처음에 AB는 65 곱하기 16하고
플러스 B 한 다음에 나누기를 하고
BA로 오는 건 66 곱하기 10을 하고
이제 65를 더한 다음에 나누기를 하는 거
그럼 이러면은 최종 값이 달라지기 때문에
또 다른 해시코드가 나올 수 있죠
이런 식으로 이제 어떻게 해시코드를 만드느냐
이게 해시 테이블의 핵심이에요
요즘 나오는 언어들은
예전에 저희가 해시 테이블을 직접 만들 때는
그 해시 테이블에 직접 저희가 해시 값을 넣어 주던 거나
아니면 해시 메일을 만들 때는 키를 언제나 인테리어만 받게 하는 경우가 있었어요
그러면 니네가 어떤 오브젝트를 넣어도 상관이 없는데
이 오브젝트의 시그네처가 되는 해시코드는
프로그래머가 만들어서 넣어라 라는 개념이었고
요즘 이제 자바나 C# 쪽을 보면은
딕셔너리 같은 걸 보면은
키하고 오브젝트의 키하고 밸류의
어떤 오브젝트는 어떤 값을 넣을 수 있잖아요
이건 어떻게 되냐
그냥 모든 오브젝트 C#의 모든 오브젝트는
getHashCode인가? 라는 함수를 만들어야 돼요
그게 전부예요
내가 새로운 오브젝트를 만들고
이제 그걸로 getHashCode를 안 만든 채
만약에 거기에 넣었다 데이터에 넣었다
그러면 이제 자동적으로 지네가 오브젝트 단위에서
디폴트로 만들어 놓은 함수를 해주겠지만
내가 정말
뭐 가장 간단한 방법은 메모리 주소 따로 하는 거겠죠 당연히
근데 내가 정말 이 두 모든 필드가 같을 때
이 두 값이 같아야 된다라고 가정을 하면은
그 해시코드를 만드는 그런 알고리즘을 제가 만들어서
getHashCode 함수에 넣으면 되는 거죠
그래서 키로 오브젝트를 놓지만
결과적으로는 그 오브젝트에 있는 해시코드 함수를 호출하는 거고
그 해시코드가 뭐를 반환하느냐에 따라
어느 빈에 들어갈지에 결정이 되는 거고
그 해시코드가 서로 다른 오브젝트끼리 동일하다면
여전히 이거는 두 오브젝트 중에 하나를 덮어서 넣는 거예요
그 컨테이너 안에서
그래서 원래 작동 방법은
어차피 원래 작동 방법은
정수 기반
거기에다가 빈수대로 나눗셈 해갖고
넣는 게 정석이에요
그거를 조금 더 편하게 하기 위해서
C#, 자바 이런 애들이 오브젝트를 받을 수 있겠지만
그 방식은 역시 getHashCode란 함수
getHash인 것도 같아 함수 이름이
그 함수를 만들게 해서
똑같은 컨벤션을 따르게 했을 뿐이죠 사실
그래서
근데 이거를 그래서 결과적으로는
다시 처음 얘기로 들어와서
해시 테이블이 어떻게 도는지 모르고
해시 맵이 어떻게 도는지 모르고
자기가 이 되게 단순한 거예요
짜보고 짜보려고 하면 되게 간단해요
이것도 못 짤 정도의 사람들이
과연
해시 맵에서 아니면 오브젝트에서
getHash가 뭘 하는지를 알 수 있을까?
이걸 어디에 쓰는지는 알 수 있을까?
오브젝트 보면 getHash라고 나와요
가끔 어떤 라이브러리 보다 보면은
그 해시 코드로 뭘 할 때가 있어요
그리고 C# 오브젝트 보면은
제가 최근에 발견한 건데 사실은
다른 거 디버깅하다가
match라는 펑션이 있어요
그 타입 리플렉션 쪽에
match라는 펑션이 있고
mat, ch
서로 같냐
equal이라는 함수가 또 있어요
근데
제가 리플렉션 쪽이었는데 하는 일이
이 제가 가져왔던 라이브러리가
그 전 버전의 닷네에선 돌았던 거예요
닷네 코어가 아닌 거에서
근데 돌았던 이유가
디버깅을 열심히 하다 보니까
match 함수를 호출해서
뭐 애트리뷰트 같은지 확인하는데
그 match 함수를
이 라이브에 쓰는 오브젝트에서
약간 오버라이딩을 해서
한 필드를 무시하게 하고
나머지 필드만으로 이제
같은 걸 확인하게 하는 거더라고요
그래서 리플렉션 데이터 정보를 불러올 때
match 함수가 호출이 됐었으니까
그 전 버전 닷네에서 추측이에요
그게 작동을 했는데
닷네 코어에서는
match를 호출하지 않는 거 같더라고요
equal 함수는 지네가 오버라이딩을 안 했어요
그래서 equal 함수를 보니까
equal 함수는 그냥
오브젝트 equal 함수를 그냥 쓰고 있는데
match는 자기네가 원하는 대로
오버라이딩을 해놓은 거야
근데 닷네 코어에 오니까
match 함수를 호출 안 하고
equal 함수를 호출하는 거 같아요
그래서 이게 같다는
등가 비교를 못 하는 거예요
그게 아까 말했던 것처럼
해시코드 만들어 갖고
같은 거 비교하는 거라고 봐도
비슷한 거거든요
그래서 제가 equal 함수를
match 함수랑 동일하게
오버라이딩을 하니까 작동을 해요
그럼 제 가정도 맞는 거죠
그래서 그 코드를
다시
contribution 했죠
open-source 프로젝트였으니까
근데 이런 걸 보면은
나중에 이게 아니라
gethash로 해 갖고
뭘 하는 그런
라이브러리도 분명히 있을 거고
이런 equal match라는 것도
이게 왜 필요한지에 대해서
생각을 하게 되는 게
이런 내부 구조를 알아야만 하는 거거든요
이게 안 되는 사람들은
외부 라이브러리를 가져와서
거기에 버그가 있을 때
고치고 써야 되는데
고치는 것도 굉장히 힘들겠구나
생각이 들어요
왜냐하면
컴퓨터가 도는 가장 단순하고
가장 간단한 규칙적인
프로젝트 자체를 모르는 거예요
빌딩 블록을 모르는 거죠
한마디로
보면서
이게
학교들이 좀
너무 질이 떨어지고 있어서
생기는 문제라고도 생각을 하고
아니면
업계가 커짐으로 인해서
굉장히
저
임금
저
실력의
개발자들도
많이
필요해지게 되면서
그런 거에 대한
또 이제 약간
부작용이 아닐까
그래서
저






정작 그런 사람들한테
진실을 말해주고 있는 사람은
없지 않나
그런 프로그래머들한테
그냥 열심히 하면 된다
막 이런 식으로만 말을 하지
정작 뭐를 제대로 해야 되는지
말을 안 해주고 있잖아
이런 생각이 많이 들어요
그래서
뭐
또 교육 예의가 나왔으니까
광고해야겠다
이런 예의가 나왔으니까
뭐
제가 그동안
만들려고 하고 있던
온라인 스쿨 있잖아요
포큐 달 아카데미
이미 웹사이트는 있죠
대기도 받고 있고
그





그
그
그거를
하려는 거에 대한
조금 더 이제
확신도 많이 생기고
음
그거는 여전히
열심히 진행하고 있고요
처음에 약속했던 것처럼
2019년 1월 오픈을 목적으로
1월 초 목
1월
첫째 주 오픈이 목표예요
일단은
매달
매달이 아니구나
그
학기가 있는데
그 학기 시작하는
첫 번째 주
월요일인가
일요일인가
뭐
그걸로 이제 목적을
무조건 마치고 있고
그래서
1월 초
목표가 목적이고
그거에 대한 업데이트는
이제 최근에 들어서야
드디어
이제 회사 설립을 다 마치고
뭐
필요한 장비들을 다
구매를 했기 때문에
그
장비가
이제
구축이 되는 대로
제대로
비디오 녹화해 가면서
이제
업데이트를
차분차분
내보낼 생각이에요
뭐
역시 교육 쪽은
이상한
규칙도 많고
이상한
제안도 많고
그래서
회사 설립부터
되게 좀
괴로웠는데
어쨌든
그거 부분
해결됐으니까
뭔가 나오겠죠
그럼 오늘 하고 싶은 얘기도
얘기도 했고
광고도 했고
반짝
아
그런
그랬으니까
포프tv를 마치게요
예
포프였습니다
